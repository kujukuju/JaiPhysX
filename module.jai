//
// This file was auto-generated using the following command:
//
// jai ../ generate.jai
//



NDEBUG :: 1;
_MSC_VER :: 1939;
PX_ENABLE_FEATURES_UNDER_CONSTRUCTION :: 0;

PX_VC :: 16;

PX_WIN64 :: 1;

PX_X64 :: 1;

PX_SSE2 :: 1;

PX_CLANG :: 0;

PX_GCC :: 0;

PX_WIN32 :: 0;

PX_LINUX :: 0;

PX_OSX :: 0;

PX_SWITCH :: 0;

PX_X86 :: 0;

PX_A64 :: 0;

PX_ARM :: 0;

PX_PPC :: 0;

PX_NEON :: 0;

PX_VMX :: 0;

PX_DEBUG :: 0;

PX_CHECKED :: 0;

PX_PROFILE :: 0;

PX_DEBUG_CRT :: 0;

PX_NVTX :: 0;

PX_DOXYGEN :: 0;

PX_GCC_FAMILY :: PX_CLANG || PX_GCC;

PX_WINDOWS_FAMILY :: PX_WIN32 || PX_WIN64;
PX_LINUX_FAMILY :: PX_LINUX;
PX_APPLE_FAMILY :: PX_OSX;
PX_UNIX_FAMILY :: PX_LINUX_FAMILY || PX_APPLE_FAMILY;

PX_EMSCRIPTEN :: 0;

PX_INTEL_FAMILY :: PX_X64 || PX_X86;
PX_ARM_FAMILY :: PX_ARM || PX_A64;
PX_P64_FAMILY :: PX_X64 || PX_A64;

PX_LIBCPP :: 1;

PX_WINDOWS :: PX_WINDOWS_FAMILY && !PX_ARM_FAMILY;

PX_ENABLE_ASSERTS :: 0;

PX_OFFSETOF_BASE :: 0x100;

PX_SUPPORT_GPU_PHYSX :: (PX_X64 && (PX_WINDOWS_FAMILY || PX_LINUX)) || (PX_A64 && PX_LINUX);

PX_SUPPORT_EXTERN_TEMPLATE :: PX_VC != 11;

PX_PRIu64 :: "I64u";

PX_SIGN_BITMASK :: 0x80000000;

PX_MAX_F32 :: 3.4028234663852885981170418348452e+38;

PX_MAX_REAL :: PX_MAX_F32;

PX_MAX_BOUNDS_EXTENTS :: PX_MAX_REAL * 0.25;

PX_PHYSICS_VERSION_MAJOR :: 5;
PX_PHYSICS_VERSION_MINOR :: 4;
PX_PHYSICS_VERSION_BUGFIX :: 0;

PX_PHYSICS_VERSION :: (PX_PHYSICS_VERSION_MAJOR<<24) + (PX_PHYSICS_VERSION_MINOR<<16) + (PX_PHYSICS_VERSION_BUGFIX<<8) + 0;

PX_SORT_PARANOIA :: PX_DEBUG;

PX_SLIST_ALIGNMENT :: 16;

COMPILE_VECTOR_INTRINSICS :: 1;

FLOAT_COMPONENTS_EQUAL_THRESHOLD :: 0.01;

VECMATH_AOS_EPSILON :: 1.0e-3;

PX_PIDIV2 :: 1.570796327;

PX_STOMP_ALLOCATED_MEMORY :: 0;

PX_INVALID_U32 :: 0xffffffff;
PX_INVALID_U16 :: 0xffff;

PX_ENABLE_DEBUG_VISUALIZATION :: 1;

PX_ENABLE_SIM_STATS :: 1;

PX_SERIAL_ALIGN :: 16;

PX_SERIAL_FILE_ALIGN :: 128;

PX_SERIAL_OBJECT_ID_INVALID :: 0;

PX_SERIAL_REF_KIND_PTR_TYPE_BIT :: 1<<31;

PX_SERIAL_REF_KIND_PXBASE :: 0 | PX_SERIAL_REF_KIND_PTR_TYPE_BIT;

PX_SERIAL_REF_KIND_MATERIAL_IDX :: 1;

PX_MESH_SCALE_MIN :: 1.0e-6;

PX_MESH_SCALE_MAX :: 1.0e6;

PX_MIN_HEIGHTFIELD_XZ_SCALE :: 1.0e-8;

PX_MAX_SWEEP_DISTANCE :: 1.0e8;

PX_INVALID_NODE :: 0xFFFFFFFF;

PXC_CONTACT_NO_FACE_INDEX :: 0xffffffff;

PX_INVALID_BP_FILTER_GROUP :: 0xffffffff;

PX_MAX_NB_SOFTBODY_TET :: 0x000fffff;

PX_MAX_TETID :: PX_MAX_NB_SOFTBODY_TET;

PX_MAX_NB_SOFTBODY :: 0xfff;

PX_INVALID_OBSTACLE_HANDLE :: 0xffffffff;

PX_BINARY_SERIAL_VERSION :: "EEDFDB718C504480BB77F9B8DA353B60";

PX_VEHICLE_UNSPECIFIED_STEER_STATE :: PX_MAX_F32;

PX_VEHICLE_FOUR_WHEEL_DIFFERENTIAL_MAXIMUM_STRENGTH :: PX_MAX_F32;

PX_VEHICLE_NO_GEAR_SWITCH_PENDING :: -1.0;
PX_VEHICLE_GEAR_SWITCH_INITIATED :: -2.0;

PX_VEHICLE_UNSPECIFIED_TIME_SINCE_LAST_SHIFT :: PX_MAX_F32;

PX_VEHICLE_UNSPECIFIED_JOUNCE :: PX_MAX_F32;
PX_VEHICLE_UNSPECIFIED_SEPARATION :: PX_MAX_F32;

PX_MAX_NB_WHEELS :: 20;

PX_DEBUG_VEHICLE_ON :: 1;

PxPackValidation :: struct {
    _: u8;
    a: s64;
}

physx :: struct {
    PxI64 :: s64;
    PxU64 :: u64;
    PxI32 :: s32;
    PxU32 :: u32;
    PxI16 :: s16;
    PxU16 :: u16;
    PxI8 :: s8;
    PxU8 :: u8;
    PxF32 :: float;
    PxF64 :: float64;
    PxReal :: float;

    // Int-as-bool type - has some uses for efficiency and with SIMD
    PxIntBool :: PxI32;
    PxIntFalse: PxIntBool : 0;
    PxIntTrue: PxIntBool : 1;

    // types for direct-GPU API
    PxArticulationGPUIndex :: PxU32;
    PxRigidDynamicGPUIndex :: PxU32;
    PxShapeGPUIndex :: PxU32;

    PxVec2 :: PxVec2T(float);

    PxVec3 :: PxVec3T(float);

    PxVec4 :: PxVec4T(float);

    PxQuat :: PxQuatT(float);

    PxMat33 :: PxMat33T(float);

    PxMat34T :: struct(_Type: Type) {}
    PxMat34 :: PxMat34T(float);

    PxMat44 :: PxMat44T(float);

    PxTransform :: PxTransformT(float);

    /* enum for empty constructor tag*/
    PxEMPTY :: enum s32 {
        PxEmpty :: 0;
    }

    /* enum for zero constructor tag for vectors and matrices */
    PxZERO :: enum s32 {
        PxZero :: 0;
    }

    /* enum for identity constructor flag for quaternions, transforms, and matrices */
    PxIDENTITY :: enum s32 {
        PxIdentity :: 0;
    }

    /*
    \brief Abstract base class for an application defined memory allocator that can be used by the Nv library.
    
    \note The SDK state should not be modified from within any allocation/free function.
    
    <b>Threading:</b> All methods of this class should be thread safe as it can be called from the user thread
    or the physics processing thread(s).
    */
    PxAllocatorCallback :: struct {
        vtable: *PxAllocatorCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxfoundation_static "??1PxAllocatorCallback@physx@@UEAA@XZ";
    }
    PxAllocatorCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        allocate: (this: *PxAllocatorCallback, size: u64, typeName: *u8, filename: *u8, line: s32) -> *void #cpp_method;

        deallocate: (this: *PxAllocatorCallback, ptr: *void) -> void #cpp_method;
    }

    PxAllocatorCallback_Destructor :: inline (this: *PxAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxAllocatorCallback_allocate :: inline (this: *PxAllocatorCallback, size: u64, typeName: *u8, filename: *u8, line: s32) -> *void { return this.vtable.allocate(this, size, typeName, filename, line); }

    PxAllocatorCallback_deallocate :: inline (this: *PxAllocatorCallback, ptr: *void) { this.vtable.deallocate(this, ptr); }

    vtable :: (obj: *PxAllocatorCallback) -> *PxAllocatorCallback_VTable { return obj.vtable; }


    /*
    * \brief  Built-in assert function
    */
    PxAssert :: (exp: *u8, file: *u8, line: s32, ignore: *bool) -> void #foreign physxfoundation_static "?PxAssert@physx@@YAXPEBD0HAEA_N@Z";

    /*
    \brief Error codes
    
    These error codes are passed to #PxErrorCallback
    
    \see PxErrorCallback
    */
    PxErrorCode :: struct {
        Enum :: enum s32 {
            NO_ERROR          :: 0;

            DEBUG_INFO        :: 1;

            DEBUG_WARNING     :: 2;

            INVALID_PARAMETER :: 4;

            INVALID_OPERATION :: 8;

            OUT_OF_MEMORY     :: 16;

            INTERNAL_ERROR    :: 32;

            ABORT             :: 64;

            PERF_WARNING      :: 128;

            MASK_ALL          :: -1;

            eNO_ERROR          :: NO_ERROR;

            eDEBUG_INFO        :: DEBUG_INFO;

            eDEBUG_WARNING     :: DEBUG_WARNING;

            eINVALID_PARAMETER :: INVALID_PARAMETER;

            eINVALID_OPERATION :: INVALID_OPERATION;

            eOUT_OF_MEMORY     :: OUT_OF_MEMORY;

            eINTERNAL_ERROR    :: INTERNAL_ERROR;

            eABORT             :: ABORT;

            ePERF_WARNING      :: PERF_WARNING;

            eMASK_ALL          :: MASK_ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Foundation SDK singleton class.
    
    You need to have an instance of this class to instance the higher level SDKs.
    */
    PxFoundation :: struct {
        vtable: *PxFoundation_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxFoundation, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxfoundation_static "??1PxFoundation@physx@@MEAA@XZ";
    }
    PxFoundation_VTable :: struct #type_info_none {
        release: (this: *PxFoundation) -> void #cpp_method;

        getErrorCallback: (this: *PxFoundation) -> *PxErrorCallback #cpp_method;

        setErrorLevel: (this: *PxFoundation, mask: PxErrorCode.Enum = .MASK_ALL) -> void #cpp_method;

        getErrorLevel: (this: *PxFoundation) -> PxErrorCode.Enum #cpp_method;

        getAllocatorCallback: (this: *PxFoundation) -> *PxAllocatorCallback #cpp_method;

        getReportAllocationNames: (this: *PxFoundation) -> bool #cpp_method;

        setReportAllocationNames: (this: *PxFoundation, value: bool) -> void #cpp_method;

        registerAllocationListener: (this: *PxFoundation, listener: *PxAllocationListener) -> void #cpp_method;

        deregisterAllocationListener: (this: *PxFoundation, listener: *PxAllocationListener) -> void #cpp_method;

        registerErrorCallback: (this: *PxFoundation, callback: *PxErrorCallback) -> void #cpp_method;

        deregisterErrorCallback: (this: *PxFoundation, callback: *PxErrorCallback) -> void #cpp_method;

        error: *void;

        error_1: (this: *PxFoundation, c: PxErrorCode.Enum, file: /*const*/ *u8, line: s32, messageFmt: /*const*/ *u8, __args: ..Any) -> bool #cpp_method;

        Destructor: (this: *PxFoundation, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxFoundation_release :: inline (this: *PxFoundation) { this.vtable.release(this); }

    PxFoundation_getErrorCallback :: inline (this: *PxFoundation) -> *PxErrorCallback { return this.vtable.getErrorCallback(this); }

    PxFoundation_setErrorLevel :: inline (this: *PxFoundation, mask: PxErrorCode.Enum = .MASK_ALL) { this.vtable.setErrorLevel(this, mask); }

    PxFoundation_getErrorLevel :: inline (this: *PxFoundation) -> PxErrorCode.Enum { return this.vtable.getErrorLevel(this); }

    PxFoundation_getAllocatorCallback :: inline (this: *PxFoundation) -> *PxAllocatorCallback { return this.vtable.getAllocatorCallback(this); }

    PxFoundation_getReportAllocationNames :: inline (this: *PxFoundation) -> bool { return this.vtable.getReportAllocationNames(this); }

    PxFoundation_setReportAllocationNames :: inline (this: *PxFoundation, value: bool) { this.vtable.setReportAllocationNames(this, value); }

    PxFoundation_registerAllocationListener :: inline (this: *PxFoundation, listener: *PxAllocationListener) { this.vtable.registerAllocationListener(this, listener); }

    PxFoundation_deregisterAllocationListener :: inline (this: *PxFoundation, listener: *PxAllocationListener) { this.vtable.deregisterAllocationListener(this, listener); }

    PxFoundation_registerErrorCallback :: inline (this: *PxFoundation, callback: *PxErrorCallback) { this.vtable.registerErrorCallback(this, callback); }

    PxFoundation_deregisterErrorCallback :: inline (this: *PxFoundation, callback: *PxErrorCallback) { this.vtable.deregisterErrorCallback(this, callback); }

    PxFoundation_Destructor :: inline (this: *PxFoundation, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxFoundation) -> *PxFoundation_VTable { return obj.vtable; }


    /*
    \brief Allocator used to access the global PxAllocatorCallback instance without providing additional information.
    */
    PxAllocator :: struct {
        Constructor :: (this: *PxAllocator, unknown0: *u8 = null) -> void #cpp_method #foreign physxfoundation_static "??0PxAllocator@physx@@QEAA@PEBD@Z";

        allocate :: (size: u64, file: *u8, line: s32, cookie: *u32 = null) -> *void #foreign physxfoundation_static "?allocate@PxAllocator@physx@@SAPEAX_KPEBDHPEAI@Z";

        deallocate :: (ptr: *void, cookie: *u32 = null) -> void #foreign physxfoundation_static "?deallocate@PxAllocator@physx@@SAXPEAXPEAI@Z";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    * \brief Bootstrap allocator using malloc/free.
    * Don't use unless your objects get allocated before foundation is initialized.
    */
    PxRawAllocator :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief	Virtual allocator callback used to provide run-time defined allocators to foundation types like Array or Bitmap.
    This is used by VirtualAllocator
    */
    PxVirtualAllocatorCallback :: struct {
        vtable: *PxVirtualAllocatorCallback_VTable;
        Constructor :: (this: *PxVirtualAllocatorCallback) -> void #cpp_method #foreign physx_static "??0PxVirtualAllocatorCallback@physx@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxVirtualAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxVirtualAllocatorCallback@physx@@UEAA@XZ";
    }
    PxVirtualAllocatorCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxVirtualAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        allocate: (this: *PxVirtualAllocatorCallback, size: u64, group: s32, file: *u8, line: s32) -> *void #cpp_method;
        deallocate: (this: *PxVirtualAllocatorCallback, ptr: *void) -> void #cpp_method;
    }

    PxVirtualAllocatorCallback_Destructor :: inline (this: *PxVirtualAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxVirtualAllocatorCallback_allocate :: inline (this: *PxVirtualAllocatorCallback, size: u64, group: s32, file: *u8, line: s32) -> *void { return this.vtable.allocate(this, size, group, file, line); }
    PxVirtualAllocatorCallback_deallocate :: inline (this: *PxVirtualAllocatorCallback, ptr: *void) { this.vtable.deallocate(this, ptr); }

    vtable :: (obj: *PxVirtualAllocatorCallback) -> *PxVirtualAllocatorCallback_VTable { return obj.vtable; }


    /*
    \brief Virtual allocator to be used by foundation types to provide run-time defined allocators.
    Due to the fact that Array extends its allocator, rather than contains a reference/pointer to it, the VirtualAllocator must
    be a concrete type containing a pointer to a virtual callback. The callback may not be available at instantiation time,
    therefore methods are provided to set the callback later.
    */
    PxVirtualAllocator :: struct {
        Constructor :: (this: *PxVirtualAllocator, callback: *PxVirtualAllocatorCallback = null, group: s32 = 0) -> void #cpp_method #foreign physx_static "??0PxVirtualAllocator@physx@@QEAA@PEAVPxVirtualAllocatorCallback@1@H@Z";

        allocate :: (this: *PxVirtualAllocator, size: u64, file: *u8, line: s32, cookie: *u32 = null) -> *void #cpp_method #foreign physx_static "?allocate@PxVirtualAllocator@physx@@QEAAPEAX_KPEBDHPEAI@Z";

        deallocate :: (this: *PxVirtualAllocator, ptr: *void, cookie: *u32 = null) -> void #cpp_method #foreign physx_static "?deallocate@PxVirtualAllocator@physx@@QEAAXPEAXPEAI@Z";

        mCallback: *PxVirtualAllocatorCallback;
        mGroup:    s32;
    }

    /*
    \brief Allocator used to access the global PxAllocatorCallback instance using a static name derived from T.
    */
    PxReflectionAllocator :: struct(T: Type) {}

    PxAllocatorTraits :: struct(T: Type) {
        Type :: PxReflectionAllocator(T);
    }

    /*
    Provides new and delete using a UserAllocator.
    Guarantees that 'delete x;' uses the UserAllocator too.
    */
    PxUserAllocated :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }
    // PX_SERIALIZATION
    operatornew :: (this: *physx.PxUserAllocated, unknown0: u64, address: *void) -> *void #cpp_method #foreign physxfoundation_static "??2PxUserAllocated@physx@@SAPEAX_KPEAX@Z";
    operatornew :: (this: physx.PxUserAllocated, unknown0: u64, address: *void) -> *void #no_context {
        return operatornew(*this, unknown0, address);
    }

    operatordelete :: (this: *physx.PxUserAllocated, ptr: *void) -> void #cpp_method #foreign physxfoundation_static "??3PxUserAllocated@physx@@SAXPEAX@Z";
    operatordelete :: (this: physx.PxUserAllocated, ptr: *void) #no_context {
        operatordelete(*this, ptr);
    }

    operatordelete[] :: (this: *physx.PxUserAllocated, ptr: *void) -> void #cpp_method #foreign physxcommon_static "??_VPxUserAllocated@physx@@SAXPEAX@Z";
    operatordelete[] :: (this: physx.PxUserAllocated, ptr: *void) #no_context {
        operatordelete[](*this, ptr);
    }

    // SCS: AlignedMalloc with 3 params not found, seems not used on PC either
    // disabled for now to avoid GCC error
    PxAlignedAllocator :: struct(N: u32, BaseAllocator: Type) {
        #as baseallocator: BaseAllocator; // jai: no "using" to avoid name-clashes
    }

    PxTempAllocator :: struct {
        Constructor :: (this: *PxTempAllocator, unknown0: *u8 = null) -> void #cpp_method #foreign physxcommon_static "??0PxTempAllocator@physx@@QEAA@PEBD@Z";

        allocate :: (this: *PxTempAllocator, size: u64, file: *u8, line: PxI32) -> *void #cpp_method #foreign physxfoundation_static "?allocate@PxTempAllocator@physx@@QEAAPEAX_KPEBDH@Z";
        deallocate :: (this: *PxTempAllocator, ptr: *void) -> void #cpp_method #foreign physxfoundation_static "?deallocate@PxTempAllocator@physx@@QEAAXPEAX@Z";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxScopedPointer :: struct(T: Type, Alloc: Type) {
        #as alloc: Alloc; // jai: no "using" to avoid name-clashes

        mPointer: *T;
        mOwned:   bool;
    }

    intrinsics :: struct {
        //! \brief platform-specific absolute value
        abs :: (a: float) -> float #foreign physxfoundation_static "?abs@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific select float
        fsel :: (a: float, b: float, c: float) -> float #foreign physxcommon_static "?fsel@intrinsics@physx@@YAMMMM@Z";

        //! \brief platform-specific sign
        sign :: (a: float) -> float #foreign physxfoundation_static "?sign@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific reciprocal
        recip :: (a: float) -> float #foreign physxcommon_static "?recip@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific square root
        sqrt :: (a: float) -> float #foreign physxfoundation_static "?sqrt@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific reciprocal square root
        recipSqrt :: (a: float) -> float #foreign physxfoundation_static "?recipSqrt@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific sine
        sin :: (a: float) -> float #foreign physxfoundation_static "?sin@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific cosine
        cos :: (a: float) -> float #foreign physxfoundation_static "?cos@intrinsics@physx@@YAMM@Z";

        //! \brief platform-specific minimum
        selectMin :: (a: float, b: float) -> float #foreign physxcharacterkinematic_static "?selectMin@intrinsics@physx@@YAMMM@Z";

        //! \brief platform-specific maximum
        selectMax :: (a: float, b: float) -> float #foreign physxcharacterkinematic_static "?selectMax@intrinsics@physx@@YAMMM@Z";

        //! \brief platform-specific finiteness check (not INF or NAN)
        isFinite :: (a: float) -> bool #foreign physxcommon_static "?isFinite@intrinsics@physx@@YA_NM@Z";

        /*!
        Sets \c count bytes starting at \c dst to zero.
        */
        memZero :: (dest: *void, count: u32) -> *void #foreign physxcharacterkinematic_static "?memZero@intrinsics@physx@@YAPEAXPEAXI@Z";

        /*!
        Sets \c count bytes starting at \c dst to \c c.
        */
        memSet :: (dest: *void, c: s32, count: u32) -> *void #foreign physxfoundation_static "?memSet@intrinsics@physx@@YAPEAXPEAXHI@Z";

        /*!
        Copies \c count bytes from \c src to \c dst. User memMove if regions overlap.
        */
        memCopy :: (dest: *void, src: *void, count: u32) -> *void #foreign physxfoundation_static "?memCopy@intrinsics@physx@@YAPEAXPEAXPEBXI@Z";

        /*!
        Copies \c count bytes from \c src to \c dst. Supports overlapping regions.
        */
        memMove :: (dest: *void, src: *void, count: u32) -> *void #foreign physxfoundation_static "?memMove@intrinsics@physx@@YAPEAXPEAXPEBXI@Z";
    }

    PxEqual :: struct(A: Type) {}

    PxLess :: struct(A: Type) {}

    PxGreater :: struct(A: Type) {}

    PxPair :: struct(F: Type, S: Type) {
        first:  F;
        second: S;
    }

    PxLogTwo :: struct(A: u32) {}

    PxUnConst :: struct(T: Type) {
        Type :: T;
    }

    /*
    \brief Sets the bytes of the provided buffer to zero.
    
    \param	dest	[out]	Pointer to block of memory to set zero.
    \param	count	[in]	Number of bytes to set to zero.
    
    \return Pointer to memory block (same as input)
    */
    PxMemZero :: (dest: *void, count: PxU32) -> *void #foreign physxcharacterkinematic_static "?PxMemZero@physx@@YAPEAXPEAXI@Z";

    /*
    \brief Sets the bytes of the provided buffer to the specified value.
    
    \param	dest	[out]	Pointer to block of memory to set to the specified value.
    \param	c		[in]	Value to set the bytes of the block of memory to.
    \param	count	[in]	Number of bytes to set to the specified value.
    
    \return Pointer to memory block (same as input)
    */
    PxMemSet :: (dest: *void, c: PxI32, count: PxU32) -> *void #foreign physxcharacterkinematic_static "?PxMemSet@physx@@YAPEAXPEAXHI@Z";

    /*
    \brief Copies the bytes of one memory block to another. The memory blocks must not overlap.
    
    \note Use #PxMemMove if memory blocks overlap.
    
    \param dest		[out]	Pointer to block of memory to copy to.
    \param src		[in]	Pointer to block of memory to copy from.
    \param count	[in]	Number of bytes to copy.
    
    \return Pointer to destination memory block
    */
    PxMemCopy :: (dest: *void, src: *void, count: PxU32) -> *void #foreign physxcharacterkinematic_static "?PxMemCopy@physx@@YAPEAXPEAXPEBXI@Z";

    /*
    \brief Copies the bytes of one memory block to another. The memory blocks can overlap.
    
    \note Use #PxMemCopy if memory blocks do not overlap.
    
    \param dest		[out]	Pointer to block of memory to copy to.
    \param src		[in]	Pointer to block of memory to copy from.
    \param count	[in]	Number of bytes to copy.
    
    \return Pointer to destination memory block
    */
    PxMemMove :: (dest: *void, src: *void, count: PxU32) -> *void #foreign physx_static "?PxMemMove@physx@@YAPEAXPEAXPEBXI@Z";

    /*
    Mark a specified amount of memory with 0xcd pattern. This is used to check that the meta data
    definition for serialized classes is complete in checked builds.
    
    \param ptr		[out]	Pointer to block of memory to initialize.
    \param byteSize	[in]	Number of bytes to initialize.
    */
    PxMarkSerializedMemory :: (ptr: *void, byteSize: PxU32) -> void #foreign physxfoundation_static "?PxMarkSerializedMemory@physx@@YAXPEAXI@Z";

    /*!
    An array is a sequential container.
    
    Implementation note
    * entries between 0 and size are valid objects
    * we use inheritance to build this because the array is included inline in a lot
    of objects and we want the allocator to take no space if it's not stateful, which
    aggregation doesn't allow. Also, we want the metadata at the front for the inline
    case where the allocator contains some inline storage space
    */
    PxArray :: struct(T: Type, Alloc: Type = PxAllocatorTraits(T)) {
        #as alloc: Alloc; // jai: no "using" to avoid name-clashes

        Iterator :: *T;
        ConstIterator :: *T;

        mData:         *T;
        mSize:         u32;
        mCapacity:     u32;
    }

    /* set *dest equal to val. Return the old value of *dest */
    PxAtomicExchange :: (dest: *PxI32, val: PxI32) -> PxI32 #foreign physxfoundation_static "?PxAtomicExchange@physx@@YAHPECHH@Z";
    PxAtomicExchange :: (dest: *PxI64, val: PxI64) -> PxI64 #foreign physxfoundation_static "?PxAtomicExchange@physx@@YA_JPEC_J_J@Z";

    /* if *dest == comp, replace with exch. Return original value of *dest */
    PxAtomicCompareExchange :: (dest: *PxI32, exch: PxI32, comp: PxI32) -> PxI32 #foreign physxfoundation_static "?PxAtomicCompareExchange@physx@@YAHPECHHH@Z";
    PxAtomicCompareExchange :: (dest: *PxI64, exch: PxI64, comp: PxI64) -> PxI64 #foreign physxfoundation_static "?PxAtomicCompareExchange@physx@@YA_JPEC_J_J1@Z";

    /* if *dest == comp, replace with exch. Return original value of *dest */
    PxAtomicCompareExchangePointer :: (dest: **void, exch: *void, comp: *void) -> *void #foreign physxfoundation_static "?PxAtomicCompareExchangePointer@physx@@YAPEAXPEAPECXPEAX1@Z";

    /* increment the specified location. Return the incremented value */
    PxAtomicIncrement :: (val: *PxI32) -> PxI32 #foreign physxfoundation_static "?PxAtomicIncrement@physx@@YAHPECH@Z";
    PxAtomicIncrement :: (val: *PxI64) -> PxI64 #foreign physxfoundation_static "?PxAtomicIncrement@physx@@YA_JPEC_J@Z";

    /* decrement the specified location. Return the decremented value */
    PxAtomicDecrement :: (val: *PxI32) -> PxI32 #foreign physxfoundation_static "?PxAtomicDecrement@physx@@YAHPECH@Z";
    PxAtomicDecrement :: (val: *PxI64) -> PxI64 #foreign physxfoundation_static "?PxAtomicDecrement@physx@@YA_JPEC_J@Z";

    /* add delta to *val. Return the new value */
    PxAtomicAdd :: (val: *PxI32, delta: PxI32) -> PxI32 #foreign physxfoundation_static "?PxAtomicAdd@physx@@YAHPECHH@Z";
    PxAtomicAdd :: (val: *PxI64, delta: PxI64) -> PxI64 #foreign physxfoundation_static "?PxAtomicAdd@physx@@YA_JPEC_J_J@Z";

    /* compute the maximum of dest and val. Return the new value */
    PxAtomicMax :: (val: *PxI32, val2: PxI32) -> PxI32 #foreign physxfoundation_static "?PxAtomicMax@physx@@YAHPECHH@Z";
    PxAtomicMax :: (val: *PxI64, val2: PxI64) -> PxI64 #foreign physxfoundation_static "?PxAtomicMax@physx@@YA_JPEC_J_J@Z";

    PxBitAndDataT :: struct(storageType: Type, bitMask: storageType) {
        mData: storageType;
    }

    PxBitAndByte :: PxBitAndDataT(PxU8, UnknownTemplateArgumentPlaceholder);
    PxBitAndWord :: PxBitAndDataT(PxU16, UnknownTemplateArgumentPlaceholder);
    PxBitAndDword :: PxBitAndDataT(PxU32, UnknownTemplateArgumentPlaceholder);

    // constants
    PxPi: float;
    PxHalfPi: float;
    PxTwoPi: float;
    PxInvPi: float;
    PxInvTwoPi: float;
    PxPiDivTwo: float;
    PxPiDivFour: float;
    PxSqrt2: float;
    PxInvSqrt2: float;

    //! overload for float to use fsel on xbox
    PxMax :: (a: float, b: float) -> float #foreign physxcharacterkinematic_static "??$PxMax@M@physx@@YAMMM@Z";

    //! overload for float to use fsel on xbox
    PxMin :: (a: float, b: float) -> float #foreign physxcommon_static "??$PxMin@M@physx@@YAMMM@Z";

    /*
    \brief abs returns the absolute value of its argument.
    */
    PxAbs :: (a: float) -> float #foreign physxfoundation_static "?PxAbs@physx@@YAMM@Z";

    /*
    \brief abs returns the absolute value of its argument.
    */
    PxAbs :: (a: s32) -> s32 #foreign physxcommon_static "?PxAbs@physx@@YAHH@Z";

    //!	\brief Square root.
    PxSqrt :: (a: float) -> float #foreign physxfoundation_static "?PxSqrt@physx@@YAMM@Z";

    //!	\brief reciprocal square root.
    PxRecipSqrt :: (a: float) -> float #foreign physxfoundation_static "?PxRecipSqrt@physx@@YAMM@Z";

    //!	\brief Sine of an angle ( <b>Unit:</b> Radians )
    PxSin :: (a: float) -> float #foreign physxfoundation_static "?PxSin@physx@@YAMM@Z";

    //!	\brief Cosine of an angle (<b>Unit:</b> Radians)
    PxCos :: (a: float) -> float #foreign physxfoundation_static "?PxCos@physx@@YAMM@Z";

    //! \brief compute sine and cosine at the same time
    PxSinCos :: (a: PxF32, sin: *PxF32, cos: *PxF32) -> void #foreign physxcommon_static "?PxSinCos@physx@@YAXMAEAM0@Z";

    /*
    \brief Tangent of an angle.
    <b>Unit:</b> Radians
    */
    PxTan :: (a: float) -> float #foreign physxcommon_static "?PxTan@physx@@YAMM@Z";

    /*
    \brief Arccosine.
    Returns angle between 0 and PI in radians
    <b>Unit:</b> Radians
    */
    PxAcos :: (f: float) -> float #foreign physxcommon_static "?PxAcos@physx@@YAMM@Z";

    /*
    \brief Arctangent of (x/y) with correct sign.
    Returns angle between -PI and PI in radians
    <b>Unit:</b> Radians
    */
    PxAtan2 :: (x: float, y: float) -> float #foreign physxcommon_static "?PxAtan2@physx@@YAMMM@Z";

    /*
    \brief Converts degrees to radians.
    */
    PxDegToRad :: (a: PxF32) -> PxF32 #foreign physxcommon_static "?PxDegToRad@physx@@YAMM@Z";

    //!	\brief returns true if the passed number is a finite floating point number as opposed to INF, NAN, etc.
    PxIsFinite :: (f: float) -> bool #foreign physxcommon_static "?PxIsFinite@physx@@YA_NM@Z";

    PxFloor :: (a: float) -> float #foreign physxcommon_static "?PxFloor@physx@@YAMM@Z";

    PxCeil :: (a: float) -> float #foreign physxcommon_static "?PxCeil@physx@@YAMM@Z";

    PxSign :: (a: float) -> float #foreign physxfoundation_static "?PxSign@physx@@YAMM@Z";

    PxPow :: (x: float, y: float) -> float #foreign physxcommon_static "?PxPow@physx@@YAMMM@Z";

    /*
    * Implements a memory barrier
    */
    PxMemoryBarrier :: () -> void #foreign physxcommon_static "?PxMemoryBarrier@physx@@YAXXZ";

    /*!
    Returns the index of the highest set bit. Not valid for zero arg.
    */
    PxHighestSetBitUnsafe :: (v: u64) -> u32 #foreign physxfoundation_static "?PxHighestSetBitUnsafe@physx@@YAI_K@Z";

    /*!
    Returns the index of the highest set bit. Not valid for zero arg.
    */
    PxHighestSetBitUnsafe :: (v: u32) -> u32 #foreign physx_static "?PxHighestSetBitUnsafe@physx@@YAII@Z";

    /*!
    Returns the index of the lowest set bit. Undefined for zero arg.
    */
    PxLowestSetBitUnsafe :: (v: u64) -> u32 #foreign physx_static "?PxLowestSetBitUnsafe@physx@@YAI_K@Z";

    /*!
    Returns the index of the lowest set bit. Undefined for zero arg.
    */
    PxLowestSetBitUnsafe :: (v: u32) -> u32 #foreign physxcommon_static "?PxLowestSetBitUnsafe@physx@@YAII@Z";

    PxPrefetchLine :: (ptr: *void, offset: u32 = 0) -> void #foreign physxcommon_static "?PxPrefetchLine@physx@@YAXPEBXI@Z";

    PxPrefetch :: (ptr: *void, count: u32 = 1) -> void #foreign physxcommon_static "?PxPrefetch@physx@@YAXPEBXI@Z";

    PxBitCount :: (v: u32) -> u32 #foreign physx_static "?PxBitCount@physx@@YAII@Z";

    PxIsPowerOfTwo :: (x: u32) -> bool #foreign physxcharacterkinematic_static "?PxIsPowerOfTwo@physx@@YA_NI@Z";

    // "Next Largest Power of 2
    // Given a binary integer value x, the next largest power of 2 can be computed by a SWAR algorithm
    // that recursively "folds" the upper bits into the lower bits. This process yields a bit vector with
    // the same most significant 1 as x, but all 1's below it. Adding 1 to that value yields the next
    // largest power of 2. For a 32-bit value:"
    PxNextPowerOfTwo :: (x: u32) -> u32 #foreign physxcharacterkinematic_static "?PxNextPowerOfTwo@physx@@YAII@Z";

    /*!
    Return the index of the highest set bit. Not valid for zero arg.
    */
    PxLowestSetBit :: (x: u32) -> u32 #foreign physxcommon_static "?PxLowestSetBit@physx@@YAII@Z";

    /*!
    Return the index of the highest set bit. Not valid for zero arg.
    */
    PxLowestSetBit :: (x: u64) -> u32 #foreign physx_static "?PxLowestSetBit@physx@@YAI_K@Z";

    /*!
    Return the index of the highest set bit. Not valid for zero arg.
    */
    PxHighestSetBit :: (x: u32) -> u32 #foreign physx_static "?PxHighestSetBit@physx@@YAII@Z";

    /*!
    Return the index of the highest set bit. Not valid for zero arg.
    */
    PxHighestSetBit :: (x: u64) -> u32 #foreign physxfoundation_static "?PxHighestSetBit@physx@@YAI_K@Z";

    // Helper function to approximate log2 of an integer value
    // assumes that the input is actually power of two.
    PxILog2 :: (num: u32) -> u32 #foreign physxcommon_static "?PxILog2@physx@@YAII@Z";

    /*!
    Hold a bitmap with operations to set,reset or test given bit.
    
    We inhibit copy to prevent unintentional copies. If a copy is desired copy() should be used or
    alternatively a copy constructor implemented.
    */
    PxBitMapBase :: struct(PxAllocator: Type) {
        #as pxuserallocated: PxUserAllocated; // jai: no "using" to avoid name-clashes

        // the obvious combiners and some used in the SDK
        OR :: struct {}
        AND :: struct {}
        XOR :: struct {}

        /*!
        Iterate over indices in a bitmap
        
        This iterator is good because it finds the set bit without looping over the cached bits upto 31 times.
        However it does require a variable shift.
        */
        Iterator :: struct {
            DONE:    PxU32 : 4294967295;

            mBlock:  PxU32;
            mIndex:  PxU32;
            mBitMap: *PxBitMapBase;
        }

        // DS: faster but less general: hasBits() must be true or getNext() is illegal so it is the calling code's responsibility to ensure that getNext() is not called illegally.
        PxLoopIterator :: struct {
            mMap:       *PxU32;
            mBlock:     PxU32; // the word we're currently scanning
            mIndex:     PxI32; // the index of the word we're currently looking at
            mWordCount: PxI32;
        }

        //Class to iterate over the bitmap from a particular start location rather than the beginning of the list
        PxCircularIterator :: struct {
            DONE:        PxU32 : 4294967295;

            mBlock:      PxU32;
            mIndex:      PxU32;
            mStartIndex: PxU32;
            mBitMap:     *PxBitMapBase;
        }

        mMap:       *PxU32; //one bit per index
        mWordCount: PxU32;
        mAllocator: PxAllocator;
        mPadding:   [3] PxU8; // PT: "mAllocator" is empty but consumes 1 byte
    }

    PxBitMap :: PxBitMapBase(PxAllocator);
    PxBitMapPinned :: PxBitMapBase(PxVirtualAllocator);

    /*
    \brief 3 Element vector class.
    
    This is a 3-dimensional vector class with public data members.
    */
    PxVec3T :: struct(_Type: Type) {
        x: Type;
        y: Type;
        z: Type;
    }

    PxVec3d :: PxVec3T(float64);

    //! A padded version of PxVec3, to safely load its data using SIMD
    PxVec3Padded :: struct {
        #as using pxvec3: PxVec3;

        Constructor :: (this: *PxVec3Padded) -> void #cpp_method #foreign physxcommon_static "??0PxVec3Padded@physx@@QEAA@XZ";
        Destructor :: (this: *PxVec3Padded) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxVec3Padded@physx@@QEAA@XZ";
        Constructor :: (this: *PxVec3Padded, p: *PxVec3) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxVec3Padded@physx@@QEAA@AEBV?$PxVec3T@M@1@@Z";
        Constructor :: (this: *PxVec3Padded, p: PxVec3) #no_context {
            Constructor(this, *p);
        }
        Constructor :: (this: *PxVec3Padded, f: float) -> void #cpp_method #foreign physxcommon_static "??0PxVec3Padded@physx@@QEAA@M@Z";

        padding: PxU32;
    }

    /*
    \brief Assignment operator.
    To fix this:
    error: definition of implicit copy assignment operator for 'PxVec3Padded' is deprecated because it has a user-declared destructor [-Werror,-Wdeprecated]
    */
    operator_assign :: (this: *physx.PxVec3Padded, p: *physx.PxVec3Padded) -> *physx.PxVec3Padded #cpp_method #foreign physxcommon_static "??4PxVec3Padded@physx@@QEAAAEAV01@AEBV01@@Z";
    operator_assign :: (this: *physx.PxVec3Padded, p: physx.PxVec3Padded) -> *physx.PxVec3Padded #no_context {
        return operator_assign(this, *p);
    }

    PxVec3p :: PxVec3Padded;

    /*
    \brief This is a quaternion class. For more information on quaternion mathematics
    consult a mathematics source on complex numbers.
    */
    PxQuatT :: struct(_Type: Type) {
        /* the quaternion elements */
        x: Type;
        /* the quaternion elements */
        y: Type;
        /* the quaternion elements */
        z: Type;
        /* the quaternion elements */
        w: Type;
    }

    PxQuatd :: PxQuatT(float64);

    /*!
    \brief class representing a rigid euclidean transform as a quaternion and a vector
    */
    PxTransformT :: struct(_Type: Type) {
        q: PxQuatT(_Type);
        p: PxVec3T(_Type);
    }

    PxTransformd :: PxTransformT(float64);

    /*!
    \brief	A generic padded & aligned transform class.
    
    This can be used for safe faster loads & stores, and faster address computations
    (the default PxTransformT often generating imuls for this otherwise). Padding bytes
    can be reused to store useful data if needed.
    */
    PxTransformPadded :: struct {
        #as using pxtransform: PxTransform;

        Constructor :: (this: *PxTransformPadded) -> void #cpp_method #foreign physx_static "??0PxTransformPadded@physx@@QEAA@XZ";

        Constructor :: (this: *PxTransformPadded, other: *PxTransform) -> void #cpp_method #foreign physxcommon_static "??0PxTransformPadded@physx@@QEAA@AEBV?$PxTransformT@M@1@@Z";
        Constructor :: (this: *PxTransformPadded, other: PxTransform) #no_context {
            Constructor(this, *other);
        }

        Constructor :: (this: *PxTransformPadded, position: *PxVec3) -> void #cpp_method #foreign physxcommon_static "??0PxTransformPadded@physx@@QEAA@AEBV?$PxVec3T@M@1@@Z";
        Constructor :: (this: *PxTransformPadded, position: PxVec3) #no_context {
            Constructor(this, *position);
        }

        Constructor :: (this: *PxTransformPadded, p0: *PxVec3, q0: *PxQuat) -> void #cpp_method #foreign physxcommon_static "??0PxTransformPadded@physx@@QEAA@AEBV?$PxVec3T@M@1@AEBV?$PxQuatT@M@1@@Z";
        Constructor :: (this: *PxTransformPadded, p0: PxVec3, q0: PxQuat) #no_context {
            Constructor(this, *p0, *q0);
        }

        padding: PxU32;
    }

    operator_assign :: (this: *physx.PxTransformPadded, other: *physx.PxTransformPadded) -> void #cpp_method #foreign physx_static "??4PxTransformPadded@physx@@QEAAXAEBU01@@Z";
    operator_assign :: (this: *physx.PxTransformPadded, other: physx.PxTransformPadded) #no_context {
        operator_assign(this, *other);
    }

    operator_assign :: (this: *physx.PxTransformPadded, other: *physx.PxTransform) -> void #cpp_method #foreign physx_static "??4PxTransformPadded@physx@@QEAAXAEBV?$PxTransformT@M@1@@Z";
    operator_assign :: (this: *physx.PxTransformPadded, other: physx.PxTransform) #no_context {
        operator_assign(this, *other);
    }

    PxTransform32 :: PxTransformPadded;

    /*!
    \brief 3x3 matrix class
    
    Some clarifications, as there have been much confusion about matrix formats etc in the past.
    
    Short:
    - Matrix have base vectors in columns (vectors are column matrices, 3x1 matrices).
    - Matrix is physically stored in column major format
    - Matrices are concaternated from left
    
    Long:
    Given three base vectors a, b and c the matrix is stored as
    
    |a.x b.x c.x|
    |a.y b.y c.y|
    |a.z b.z c.z|
    
    Vectors are treated as columns, so the vector v is
    
    |x|
    |y|
    |z|
    
    And matrices are applied _before_ the vector (pre-multiplication)
    v' = M*v
    
    |x'|   |a.x b.x c.x|   |x|   |a.x*x + b.x*y + c.x*z|
    |y'| = |a.y b.y c.y| * |y| = |a.y*x + b.y*y + c.y*z|
    |z'|   |a.z b.z c.z|   |z|   |a.z*x + b.z*y + c.z*z|
    
    
    Physical storage and indexing:
    To be compatible with popular 3d rendering APIs (read D3d and OpenGL)
    the physical indexing is
    
    |0 3 6|
    |1 4 7|
    |2 5 8|
    
    index = column*3 + row
    
    which in C++ translates to M[column][row]
    
    The mathematical indexing is M_row,column and this is what is used for _-notation
    so _12 is 1st row, second column and operator(row, column)!
    */
    PxMat33T :: struct(_Type: Type) {
        column0: PxVec3T(_Type); // the three base vectors
        column1: PxVec3T(_Type); // the three base vectors
        column2: PxVec3T(_Type); // the three base vectors
    }

    PxMat33d :: PxMat33T(float64);

    /*
    \brief Class representing 3D range or axis aligned bounding box.
    
    Stored as minimum and maximum extent corners. Alternate representation
    would be center and dimensions.
    May be empty or nonempty. For nonempty bounds, minimum <= maximum has to hold for all axes.
    Empty bounds have to be represented as minimum = PX_MAX_BOUNDS_EXTENTS and maximum = -PX_MAX_BOUNDS_EXTENTS for all
    axes.
    All other representations are invalid and the behavior is undefined.
    */
    PxBounds3 :: struct {
        /*
        \brief Default constructor, not performing any initialization for performance reason.
        \remark Use empty() function below to construct empty bounds.
        */
        Constructor :: (this: *PxBounds3) -> void #cpp_method #foreign physxcommon_static "??0PxBounds3@physx@@QEAA@XZ";

        /*
        \brief Construct from two bounding points
        */
        Constructor :: (this: *PxBounds3, minimum: *PxVec3, maximum: *PxVec3) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxBounds3@physx@@QEAA@AEBV?$PxVec3T@M@1@0@Z";
        Constructor :: (this: *PxBounds3, minimum: PxVec3, maximum: PxVec3) #no_context {
            Constructor(this, *minimum, *maximum);
        }

        CopyConstructor :: (this: *PxBounds3, other: *PxBounds3) -> void #cpp_method #foreign physxcommon_static "??0PxBounds3@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxBounds3, other: PxBounds3) #no_context {
            CopyConstructor(this, *other);
        }

        /*
        \brief Return empty bounds.
        */
        empty :: () -> PxBounds3 #cpp_return_type_is_non_pod #foreign physxcommon_static "?empty@PxBounds3@physx@@SA?AV12@XZ";

        /*
        \brief returns the AABB from center and extents vectors.
        \param center Center vector
        \param extent Extents vector
        */
        centerExtents :: (center: *PxVec3, extent: *PxVec3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physxcharacterkinematic_static "?centerExtents@PxBounds3@physx@@SA?AV12@AEBV?$PxVec3T@M@2@0@Z";
        centerExtents :: (center: PxVec3, extent: PxVec3) -> PxBounds3 #no_context {
            return centerExtents(*center, *extent);
        }

        /*
        \brief Construct from center, extent, and (not necessarily orthogonal) basis
        */
        basisExtent :: (center: *PxVec3, basis: *PxMat33, extent: *PxVec3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physxcommon_static "?basisExtent@PxBounds3@physx@@SA?AV12@AEBV?$PxVec3T@M@2@AEBV?$PxMat33T@M@2@0@Z";
        basisExtent :: (center: PxVec3, basis: PxMat33, extent: PxVec3) -> PxBounds3 #no_context {
            return basisExtent(*center, *basis, *extent);
        }

        /*
        \brief Construct from pose and extent
        */
        poseExtent :: (pose: *PxTransform, extent: *PxVec3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physxcommon_static "?poseExtent@PxBounds3@physx@@SA?AV12@AEBV?$PxTransformT@M@2@AEBV?$PxVec3T@M@2@@Z";
        poseExtent :: (pose: PxTransform, extent: PxVec3) -> PxBounds3 #no_context {
            return poseExtent(*pose, *extent);
        }

        /*
        \brief gets the transformed bounds of the passed AABB (resulting in a bigger AABB).
        
        This version is safe to call for empty bounds.
        
        \param[in] transform Transform to apply, can contain scaling as well
        \param[in] bounds The bounds to transform.
        */
        transformSafe :: (transform: *PxTransform, bounds: *PxBounds3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physx_static "?transformSafe@PxBounds3@physx@@SA?AV12@AEBV?$PxTransformT@M@2@AEBV12@@Z";
        transformSafe :: (transform: PxTransform, bounds: PxBounds3) -> PxBounds3 #no_context {
            return transformSafe(*transform, *bounds);
        }

        /*
        \brief gets the transformed bounds of the passed AABB (resulting in a bigger AABB).
        
        Calling this method for empty bounds leads to undefined behavior. Use #transformSafe() instead.
        
        \param[in] transform Transform to apply, can contain scaling as well
        \param[in] bounds The bounds to transform.
        */
        transformFast :: (transform: *PxTransform, bounds: *PxBounds3) -> PxBounds3 #cpp_return_type_is_non_pod #foreign physxcommon_static "?transformFast@PxBounds3@physx@@SA?AV12@AEBV?$PxTransformT@M@2@AEBV12@@Z";
        transformFast :: (transform: PxTransform, bounds: PxBounds3) -> PxBounds3 #no_context {
            return transformFast(*transform, *bounds);
        }

        /*
        \brief Sets empty to true
        */
        setEmpty :: (this: *PxBounds3) -> void #cpp_method #foreign physxcommon_static "?setEmpty@PxBounds3@physx@@QEAAXXZ";

        /*
        \brief expands the volume to include v
        \param v Point to expand to.
        */
        include :: (this: *PxBounds3, v: *PxVec3) -> void #cpp_method #foreign physxcommon_static "?include@PxBounds3@physx@@QEAAXAEBV?$PxVec3T@M@2@@Z";
        include :: (this: *PxBounds3, v: PxVec3) #no_context {
            include(this, *v);
        }

        /*
        \brief expands the volume to include b.
        \param b Bounds to perform union with.
        */
        include :: (this: *PxBounds3, b: *PxBounds3) -> void #cpp_method #foreign physxcommon_static "?include@PxBounds3@physx@@QEAAXAEBV12@@Z";
        include :: (this: *PxBounds3, b: PxBounds3) #no_context {
            include(this, *b);
        }

        isEmpty :: (this: *PxBounds3) -> bool #cpp_method #foreign physxcommon_static "?isEmpty@PxBounds3@physx@@QEBA_NXZ";

        /*
        \brief indicates whether the intersection of this and b is empty or not.
        \param b Bounds to test for intersection.
        */
        intersects :: (this: *PxBounds3, b: *PxBounds3) -> bool #cpp_method #foreign physxcharacterkinematic_static "?intersects@PxBounds3@physx@@QEBA_NAEBV12@@Z";
        intersects :: (this: *PxBounds3, b: PxBounds3) -> bool #no_context {
            return intersects(this, *b);
        }

        /*
        \brief indicates if these bounds contain v.
        \param v Point to test against bounds.
        */
        contains :: (this: *PxBounds3, v: *PxVec3) -> bool #cpp_method #foreign physxcommon_static "?contains@PxBounds3@physx@@QEBA_NAEBV?$PxVec3T@M@2@@Z";
        contains :: (this: *PxBounds3, v: PxVec3) -> bool #no_context {
            return contains(this, *v);
        }

        /*
        \brief	checks a box is inside another box.
        \param	box		the other AABB
        */
        isInside :: (this: *PxBounds3, box: *PxBounds3) -> bool #cpp_method #foreign physxcommon_static "?isInside@PxBounds3@physx@@QEBA_NAEBV12@@Z";
        isInside :: (this: *PxBounds3, box: PxBounds3) -> bool #no_context {
            return isInside(this, *box);
        }

        /*
        \brief returns the center of this axis aligned box.
        */
        getCenter :: (this: *PxBounds3) -> PxVec3 #cpp_method #foreign physxcharacterkinematic_static "?getCenter@PxBounds3@physx@@QEBA?AV?$PxVec3T@M@2@XZ";

        /*
        \brief get component of the box's center along a given axis
        */
        getCenter :: (this: *PxBounds3, axis: u32) -> float #cpp_method #foreign physxcommon_static "?getCenter@PxBounds3@physx@@QEBAMI@Z";

        /*
        \brief returns the dimensions (width/height/depth) of this axis aligned box.
        */
        getDimensions :: (this: *PxBounds3) -> PxVec3 #cpp_method #foreign physxcharacterkinematic_static "?getDimensions@PxBounds3@physx@@QEBA?AV?$PxVec3T@M@2@XZ";

        /*
        \brief returns the extents, which are half of the width/height/depth.
        */
        getExtents :: (this: *PxBounds3) -> PxVec3 #cpp_method #foreign physxcharacterkinematic_static "?getExtents@PxBounds3@physx@@QEBA?AV?$PxVec3T@M@2@XZ";

        /*
        fattens the AABB in all 3 dimensions by the given distance.
        
        This version is safe to call for empty bounds.
        */
        fattenSafe :: (this: *PxBounds3, distance: float) -> void #cpp_method #foreign physx_static "?fattenSafe@PxBounds3@physx@@QEAAXM@Z";

        /*
        fattens the AABB in all 3 dimensions by the given distance.
        
        Calling this method for empty bounds leads to undefined behavior. Use #fattenSafe() instead.
        */
        fattenFast :: (this: *PxBounds3, distance: float) -> void #cpp_method #foreign physxcommon_static "?fattenFast@PxBounds3@physx@@QEAAXM@Z";

        /*
        checks that the AABB values are not NaN
        */
        isFinite :: (this: *PxBounds3) -> bool #cpp_method #foreign physxcommon_static "?isFinite@PxBounds3@physx@@QEBA_NXZ";

        /*
        checks that the AABB values describe a valid configuration.
        */
        isValid :: (this: *PxBounds3) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxBounds3@physx@@QEBA_NXZ";

        minimum: PxVec3;
        maximum: PxVec3;
    }

    operator_assign :: (this: *physx.PxBounds3, other: *physx.PxBounds3) -> void #cpp_method #foreign physxcharacterkinematic_static "??4PxBounds3@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxBounds3, other: physx.PxBounds3) #no_context {
        operator_assign(this, *other);
    }

    // this is used by the array class to allocate some space for a small number
    // of objects along with the metadata
    PxInlineAllocator :: struct(N: PxU32, BaseAllocator: Type) {
        #as baseallocator: BaseAllocator; // jai: no "using" to avoid name-clashes

        mBuffer:     [PxU8] PxU8;
        mBufferUsed: bool;
    }

    // array that pre-allocates for N elements
    PxInlineArray :: struct(T: Type, N: u32, Alloc: Type) {
        #as pxarray: PxArray(T, PxInlineAllocator(UnknownTemplateArgumentPlaceholder, Alloc)); // jai: no "using" to avoid name-clashes

        Allocator :: PxInlineAllocator(UnknownTemplateArgumentPlaceholder, Alloc);
    }

    /*
    \brief User defined interface class.  Used by the library to emit debug information.
    
    \note The SDK state should not be modified from within any error reporting functions.
    
    <b>Threading:</b> The SDK sequences its calls to the output stream using a mutex, so the class need not
    be implemented in a thread-safe manner if the SDK is the only client.
    */
    PxErrorCallback :: struct {
        vtable: *PxErrorCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxErrorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxfoundation_static "??1PxErrorCallback@physx@@UEAA@XZ";
    }
    PxErrorCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxErrorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        reportError: (this: *PxErrorCallback, code: PxErrorCode.Enum, message: *u8, file: *u8, line: s32) -> void #cpp_method;
    }

    PxErrorCallback_Destructor :: inline (this: *PxErrorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxErrorCallback_reportError :: inline (this: *PxErrorCallback, code: PxErrorCode.Enum, message: *u8, file: *u8, line: s32) { this.vtable.reportError(this, code, message, file, line); }

    vtable :: (obj: *PxErrorCallback) -> *PxErrorCallback_VTable { return obj.vtable; }


    /*
    \brief Abstract listener class that listens to allocation and deallocation events from the
    foundation memory system.
    
    <b>Threading:</b> All methods of this class should be thread safe as it can be called from the user thread
    or the physics processing thread(s).
    */
    PxAllocationListener :: struct {
        vtable: *PxAllocationListener_VTable;
    }
    PxAllocationListener_VTable :: struct #type_info_none {
        onAllocation: (this: *PxAllocationListener, size: u64, typeName: *u8, filename: *u8, line: s32, allocatedMemory: *void) -> void #cpp_method;

        onDeallocation: (this: *PxAllocationListener, allocatedMemory: *void) -> void #cpp_method;

        Destructor: (this: *PxAllocationListener, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxAllocationListener_onAllocation :: inline (this: *PxAllocationListener, size: u64, typeName: *u8, filename: *u8, line: s32, allocatedMemory: *void) { this.vtable.onAllocation(this, size, typeName, filename, line, allocatedMemory); }

    PxAllocationListener_onDeallocation :: inline (this: *PxAllocationListener, allocatedMemory: *void) { this.vtable.onDeallocation(this, allocatedMemory); }

    PxAllocationListener_Destructor :: inline (this: *PxAllocationListener, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxAllocationListener) -> *PxAllocationListener_VTable { return obj.vtable; }


    /*
    \brief Broadcast class implementation, registering listeners.
    
    <b>Threading:</b> All methods of this class should be thread safe as it can be called from the user thread
    or the physics processing thread(s). There is not internal locking
    */
    PxBroadcast :: struct(Listener: Type, Base: Type) {
        #as base: Base; // jai: no "using" to avoid name-clashes

        MAX_NB_LISTENERS: u32 : 16;
    }

    /*
    \brief Abstract base class for an application defined memory allocator that allows an external listener
    to audit the memory allocations.
    */
    PxBroadcastingAllocator :: struct {
        #as using pxbroadcast: PxBroadcast(PxAllocationListener, PxAllocatorCallback);
        vtable: *PxBroadcastingAllocator_VTable;

        /*
        \brief The default constructor.
        */
        Constructor :: (this: *PxBroadcastingAllocator, allocator: *PxAllocatorCallback, error: *PxErrorCallback) -> void #cpp_method #foreign physxfoundation_static "??0PxBroadcastingAllocator@physx@@QEAA@AEAVPxAllocatorCallback@1@AEAVPxErrorCallback@1@@Z";

        mAllocator: *PxAllocatorCallback;
        mError:     *PxErrorCallback;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief The default constructor.
        */
        virtual_Destructor :: (this: *PxBroadcastingAllocator, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxfoundation_static "??1PxBroadcastingAllocator@physx@@UEAA@XZ";

        /*
        \brief Allocates size bytes of memory, which must be 16-byte aligned.
        
        This method should never return NULL.  If you run out of memory, then
        you should terminate the app or take some other appropriate action.
        
        <b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread
        and physics processing thread(s).
        
        \param size			Number of bytes to allocate.
        \param typeName		Name of the datatype that is being allocated
        \param filename		The source file which allocated the memory
        \param line			The source line which allocated the memory
        \return				The allocated block of memory.
        */
        virtual_allocate :: (this: *PxBroadcastingAllocator, size: u64, typeName: *u8, filename: *u8, line: s32) -> *void #cpp_method #foreign physxfoundation_static "?allocate@PxBroadcastingAllocator@physx@@UEAAPEAX_KPEBD1H@Z";

        /*
        \brief Frees memory previously allocated by allocate().
        
        <b>Threading:</b> This function should be thread safe as it can be called in the context of the user thread
        and physics processing thread(s).
        
        \param ptr Memory to free.
        */
        virtual_deallocate :: (this: *PxBroadcastingAllocator, ptr: *void) -> void #cpp_method #foreign physxfoundation_static "?deallocate@PxBroadcastingAllocator@physx@@UEAAXPEAX@Z";
    }
    PxBroadcastingAllocator_VTable :: struct #type_info_none {
        Destructor: (this: *PxBroadcastingAllocator, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        allocate: (this: *PxBroadcastingAllocator, size: u64, typeName: *u8, filename: *u8, line: s32) -> *void #cpp_method;

        deallocate: (this: *PxBroadcastingAllocator, ptr: *void) -> void #cpp_method;
    }

    PxBroadcastingAllocator_Destructor :: inline (this: *PxBroadcastingAllocator, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBroadcastingAllocator_allocate :: inline (this: *PxBroadcastingAllocator, size: u64, typeName: *u8, filename: *u8, line: s32) -> *void { return this.vtable.allocate(this, size, typeName, filename, line); }

    PxBroadcastingAllocator_deallocate :: inline (this: *PxBroadcastingAllocator, ptr: *void) { this.vtable.deallocate(this, ptr); }

    vtable :: (obj: *PxBroadcastingAllocator) -> *PxBroadcastingAllocator_VTable { return obj.vtable; }


    /*
    \brief Abstract base class for an application defined error callback that allows an external listener
    to report errors.
    */
    PxBroadcastingErrorCallback :: struct {
        #as using pxbroadcast: PxBroadcast(PxErrorCallback, PxErrorCallback);
        vtable: *PxBroadcastingErrorCallback_VTable;

        /*
        \brief The default constructor.
        */
        Constructor :: (this: *PxBroadcastingErrorCallback, errorCallback: *PxErrorCallback) -> void #cpp_method #foreign physxfoundation_static "??0PxBroadcastingErrorCallback@physx@@QEAA@AEAVPxErrorCallback@1@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief The default destructor.
        */
        virtual_Destructor :: (this: *PxBroadcastingErrorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxfoundation_static "??1PxBroadcastingErrorCallback@physx@@UEAA@XZ";

        /*
        \brief Reports an error code.
        \param code Error code, see #PxErrorCode
        \param message Message to display.
        \param file File error occured in.
        \param line Line number error occured on.
        */
        virtual_reportError :: (this: *PxBroadcastingErrorCallback, code: PxErrorCode.Enum, message: *u8, file: *u8, line: s32) -> void #cpp_method #foreign physxfoundation_static "?reportError@PxBroadcastingErrorCallback@physx@@UEAAXW4Enum@PxErrorCode@2@PEBD1H@Z";
    }
    PxBroadcastingErrorCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxBroadcastingErrorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        reportError: (this: *PxBroadcastingErrorCallback, code: PxErrorCode.Enum, message: *u8, file: *u8, line: s32) -> void #cpp_method;
    }

    PxBroadcastingErrorCallback_Destructor :: inline (this: *PxBroadcastingErrorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBroadcastingErrorCallback_reportError :: inline (this: *PxBroadcastingErrorCallback, code: PxErrorCode.Enum, message: *u8, file: *u8, line: s32) { this.vtable.reportError(this, code, message, file, line); }

    vtable :: (obj: *PxBroadcastingErrorCallback) -> *PxBroadcastingErrorCallback_VTable { return obj.vtable; }


    /*
    \brief Container for bitfield flag variables associated with a specific enum type.
    
    This allows for type safe manipulation for bitfields.
    
    <h3>Example</h3>
    // enum that defines each bit...
    struct MyEnum
    {
    enum Enum
    {
    eMAN  = 1,
    eBEAR = 2,
    ePIG  = 4,
    };
    };
    
    // implements some convenient global operators.
    PX_FLAGS_OPERATORS(MyEnum::Enum, uint8_t);
    
    PxFlags<MyEnum::Enum, uint8_t> myFlags;
    myFlags |= MyEnum::eMAN;
    myFlags |= MyEnum::eBEAR | MyEnum::ePIG;
    if(myFlags & MyEnum::eBEAR)
    {
    doSomething();
    }
    */
    PxFlags :: struct(enumtype: Type, storagetype: Type) {
        InternalType :: storagetype;

        mBits:        storagetype;
    }

    // sets the default SDK state for scalar and SIMD units
    PxFPUGuard :: struct {
        Constructor :: (this: *PxFPUGuard) -> void #cpp_method #foreign physxfoundation_static "??0PxFPUGuard@physx@@QEAA@XZ";
        Destructor :: (this: *PxFPUGuard) -> void #cpp_method #foreign physxfoundation_static "??1PxFPUGuard@physx@@QEAA@XZ";

        mControlWords: [8] PxU32;
    }

    // sets default SDK state for simd unit only, lighter weight than FPUGuard
    PxSIMDGuard :: struct {
        Constructor :: (this: *PxSIMDGuard, enable := true) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxSIMDGuard@physx@@QEAA@_N@Z";

        Destructor :: (this: *PxSIMDGuard) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxSIMDGuard@physx@@QEAA@XZ";

        mControlWord: PxU32;
        mEnabled:     bool;
    }

    /*
    \brief Enables floating point exceptions for the scalar and SIMD unit
    */
    PxEnableFPExceptions :: () -> void #foreign physxfoundation_static "?PxEnableFPExceptions@physx@@YAXXZ";

    /*
    \brief Disables floating point exceptions for the scalar and SIMD unit
    */
    PxDisableFPExceptions :: () -> void #foreign physxfoundation_static "?PxDisableFPExceptions@physx@@YAXXZ";

    // the following functions have C99 semantics. Note that C99 requires for snprintf and vsnprintf:
    // * the resulting string is always NULL-terminated regardless of truncation.
    // * in the case of truncation the return value is the number of characters that would have been created.
    Pxsscanf_CFormat :: (buffer: *u8, format: *u8, __args: ..Any) -> s32 #foreign physxfoundation_static "?Pxsscanf@physx@@YAHPEBD0ZZ";
    Pxsscanf :: (buffer: *u8, format: string, __args: ..Any) -> s32 {
        push_allocator(temp);
        formatted_text_builder: String_Builder;
        print_to_builder(*formatted_text_builder, format, ..__args);
        append(*formatted_text_builder, "\0");
        formatted_text := builder_to_string(*formatted_text_builder);
        return Pxsscanf_CFormat(buffer, "%s", formatted_text.data);
    } @PrintLike
    Pxstrcmp :: (str1: *u8, str2: *u8) -> s32 #foreign physxfoundation_static "?Pxstrcmp@physx@@YAHPEBD0@Z";
    Pxstrncmp :: (str1: *u8, str2: *u8, count: u64) -> s32 #foreign physxfoundation_static "?Pxstrncmp@physx@@YAHPEBD0_K@Z";
    Pxsnprintf_CFormat :: (dst: *u8, dstSize: u64, format: *u8, __args: ..Any) -> s32 #foreign physxfoundation_static "?Pxsnprintf@physx@@YAHPEAD_KPEBDZZ";
    Pxsnprintf :: (dst: *u8, dstSize: u64, format: string, __args: ..Any) -> s32 {
        push_allocator(temp);
        formatted_text_builder: String_Builder;
        print_to_builder(*formatted_text_builder, format, ..__args);
        append(*formatted_text_builder, "\0");
        formatted_text := builder_to_string(*formatted_text_builder);
        return Pxsnprintf_CFormat(dst, dstSize, "%s", formatted_text.data);
    } @PrintLike

    // strlcat and strlcpy have BSD semantics:
    // * dstSize is always the size of the destination buffer
    // * the resulting string is always NULL-terminated regardless of truncation
    // * in the case of truncation the return value is the length of the string that would have been created
    Pxstrlcat :: (dst: *u8, dstSize: u64, src: *u8) -> u64 #foreign physxfoundation_static "?Pxstrlcat@physx@@YA_KPEAD_KPEBD@Z";
    Pxstrlcpy :: (dst: *u8, dstSize: u64, src: *u8) -> u64 #foreign physxfoundation_static "?Pxstrlcpy@physx@@YA_KPEAD_KPEBD@Z";

    // case-insensitive string comparison
    Pxstricmp :: (str1: *u8, str2: *u8) -> s32 #foreign physxfoundation_static "?Pxstricmp@physx@@YAHPEBD0@Z";
    Pxstrnicmp :: (str1: *u8, str2: *u8, count: u64) -> s32 #foreign physxfoundation_static "?Pxstrnicmp@physx@@YAHPEBD0_K@Z";

    // in-place string case conversion
    Pxstrlwr :: (str: *u8) -> void #foreign physxfoundation_static "?Pxstrlwr@physx@@YAXPEAD@Z";
    Pxstrupr :: (str: *u8) -> void #foreign physxfoundation_static "?Pxstrupr@physx@@YAXPEAD@Z";

    /*
    \brief Prints the string literally (does not consume % specifier), trying to make sure it's visible to the app
    programmer
    */
    PxPrintString :: (unknown0: *u8) -> void #foreign physxfoundation_static "?PxPrintString@physx@@YAXPEBD@Z";

    // Thomas Wang's 32 bit mix
    // http://www.cris.com/~Ttwang/tech/inthash.htm
    PxComputeHash :: (key: u32) -> u32 #foreign physxcommon_static "?PxComputeHash@physx@@YAII@Z";

    // Thomas Wang's 64 bit mix
    // http://www.cris.com/~Ttwang/tech/inthash.htm
    PxComputeHash :: (key: u64) -> u32 #foreign physxcharacterkinematic_static "?PxComputeHash@physx@@YAI_K@Z";

    // Hash function for pointers
    PxComputeHash :: (ptr: *void) -> u32 #foreign physxcharacterkinematic_static "?PxComputeHash@physx@@YAIPEBX@Z";

    // hash object for hash map template parameter
    PxHash :: struct(Key: Type) {}

    PxHashBase :: struct(Entry: Type, Key: Type, HashFn: Type, GetKey: Type, PxAllocator: Type, compacting: bool) {
        #as pxallocator: PxAllocator; // jai: no "using" to avoid name-clashes

        EntryType :: Entry;

        EOL:              u32 : 4294967295;

        mBuffer:          *u8;
        mEntries:         *Entry;
        mEntriesNext:     *u32; // same size as mEntries
        mHash:            *u32;
        mEntriesCapacity: u32;
        mHashSize:        u32;
        mLoadFactor:      float;
        mFreeList:        u32;
        mTimestamp:       u32;
        mEntriesCount:    u32; // number of entries

        Iter :: struct {
            mBucket:    u32;
            mEntry:     u32;
            mTimestamp: u32;
            mBase:      *PxHashBase;
        }

        /*!
        Iterate over entries in a hash base and allow entry erase while iterating
        */
        PxEraseIterator :: struct {
            mCurrentEntryIndexPtr: *u32;
            mCurrentHashIndex:     u32;
            mBase:                 *PxHashBase;
        }
    }

    PxHashSetBase :: struct(Key: Type, HashFn: Type, PxAllocator: Type, Coalesced := false) {
        GetKey :: struct {}

        BaseMap :: PxHashBase(Key, Key, HashFn, GetKey, PxAllocator, UnknownTemplateArgumentPlaceholder);
        Iterator :: UnknownTypePlaceholder /* typename BaseMap::Iter */;

        mBase:    BaseMap;
    }

    PxHashMapBase :: struct(Key: Type, Value: Type, HashFn: Type, PxAllocator: Type) {
        Entry :: PxPair(UnknownTemplateArgumentPlaceholder /* const Key */, Value);

        GetKey :: struct {}

        BaseMap :: PxHashBase(Entry, Key, HashFn, GetKey, PxAllocator, UnknownTemplateArgumentPlaceholder);
        Iterator :: UnknownTypePlaceholder /* typename BaseMap::Iter */;
        EraseIterator :: UnknownTypePlaceholder /* typename BaseMap::PxEraseIterator */;

        mBase:         BaseMap;
    }

    PxHashMap :: struct(Key: Type, Value: Type, HashFn: Type, Allocator: Type) {
        #as pxhashmapbase: PxHashMapBase(Key, Value, HashFn, Allocator); // jai: no "using" to avoid name-clashes

        HashMapBase :: PxHashMapBase(Key, Value, HashFn, Allocator);
        Iterator :: UnknownTypePlaceholder /* typename HashMapBase::Iterator */;
    }

    PxCoalescedHashMap :: struct(Key: Type, Value: Type, HashFn: Type, Allocator: Type) {
        #as pxhashmapbase: PxHashMapBase(Key, Value, HashFn, Allocator); // jai: no "using" to avoid name-clashes

        HashMapBase :: PxHashMapBase(Key, Value, HashFn, Allocator);
    }

    PxHashSet :: struct(Key: Type, HashFn: Type, Allocator: Type) {
        #as pxhashsetbase: PxHashSetBase(Key, HashFn, Allocator, UnknownTemplateArgumentPlaceholder); // jai: no "using" to avoid name-clashes

        HashSetBase :: PxHashSetBase(Key, HashFn, Allocator, UnknownTemplateArgumentPlaceholder);
        Iterator :: UnknownTypePlaceholder /* typename HashSetBase::Iterator */;
    }

    PxCoalescedHashSet :: struct(Key: Type, HashFn: Type, Allocator: Type) {
        #as pxhashsetbase: PxHashSetBase(Key, HashFn, Allocator, UnknownTemplateArgumentPlaceholder); // jai: no "using" to avoid name-clashes

        HashSetBase :: PxHashSetBase(Key, HashFn, Allocator, UnknownTemplateArgumentPlaceholder);
    }

    /*
    \brief Input stream class for I/O.
    
    The user needs to supply a PxInputStream implementation to a number of methods to allow the SDK to read data.
    */
    PxInputStream :: struct {
        vtable: *PxInputStream_VTable;
    }
    PxInputStream_VTable :: struct #type_info_none {
        read: (this: *PxInputStream, dest: *void, count: u32) -> u32 #cpp_method;

        Destructor: (this: *PxInputStream, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxInputStream_read :: inline (this: *PxInputStream, dest: *void, count: u32) -> u32 { return this.vtable.read(this, dest, count); }

    PxInputStream_Destructor :: inline (this: *PxInputStream, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxInputStream) -> *PxInputStream_VTable { return obj.vtable; }


    /*
    \brief Input data class for I/O which provides random read access.
    
    The user needs to supply a PxInputData implementation to a number of methods to allow the SDK to read data.
    */
    PxInputData :: struct {
        #as using pxinputstream: PxInputStream;
        #place pxinputstream; pxinputdata_vtable: *PxInputData_VTable;
    }
    PxInputData_VTable :: struct #type_info_none {
        using pxinputstream: PxInputStream_VTable;
        getLength: (this: *PxInputData) -> u32 #cpp_method;

        seek: (this: *PxInputData, offset: u32) -> void #cpp_method;

        tell: (this: *PxInputData) -> u32 #cpp_method;
    }

    PxInputData_getLength :: inline (this: *PxInputData) -> u32 { return this.pxinputdata_vtable.getLength(this); }

    PxInputData_seek :: inline (this: *PxInputData, offset: u32) { this.pxinputdata_vtable.seek(this, offset); }

    PxInputData_tell :: inline (this: *PxInputData) -> u32 { return this.pxinputdata_vtable.tell(this); }

    vtable :: (obj: *PxInputData) -> *PxInputData_VTable { return obj.pxinputdata_vtable; }


    /*
    \brief Output stream class for I/O.
    
    The user needs to supply a PxOutputStream implementation to a number of methods to allow the SDK to write data.
    */
    PxOutputStream :: struct {
        vtable: *PxOutputStream_VTable;
    }
    PxOutputStream_VTable :: struct #type_info_none {
        write: (this: *PxOutputStream, src: *void, count: u32) -> u32 #cpp_method;

        Destructor: (this: *PxOutputStream, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxOutputStream_write :: inline (this: *PxOutputStream, src: *void, count: u32) -> u32 { return this.vtable.write(this, src, count); }

    PxOutputStream_Destructor :: inline (this: *PxOutputStream, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxOutputStream) -> *PxOutputStream_VTable { return obj.vtable; }


    PxVec4T :: struct(_Type: Type) {
        x: Type;
        y: Type;
        z: Type;
        w: Type;
    }

    PxVec4d :: PxVec4T(float64);

    /*!
    \brief 4x4 matrix class
    
    This class is layout-compatible with D3D and OpenGL matrices. More notes on layout are given in the PxMat33
    
    \see PxMat33 PxTransform
    */
    PxMat44T :: struct(_Type: Type) {
        column0: PxVec4T(_Type); // the four base vectors
        column1: PxVec4T(_Type); // the four base vectors
        column2: PxVec4T(_Type); // the four base vectors
        column3: PxVec4T(_Type); // the four base vectors
    }

    PxMat44d :: PxMat44T(float64);

    /*
    \brief Representation of a plane.
    
    Plane equation used: n.dot(v) + d = 0
    */
    PxPlane :: struct {
        /*
        \brief Constructor
        */
        Constructor :: (this: *PxPlane) -> void #cpp_method #foreign physxcommon_static "??0PxPlane@physx@@QEAA@XZ";

        /*
        \brief Constructor from a normal and a distance
        */
        Constructor :: (this: *PxPlane, nx: float, ny: float, nz: float, distance: float) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxPlane@physx@@QEAA@MMMM@Z";

        /*
        \brief Constructor from a normal and a distance
        */
        Constructor :: (this: *PxPlane, normal: *PxVec3, distance: float) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxPlane@physx@@QEAA@AEBV?$PxVec3T@M@1@M@Z";
        Constructor :: (this: *PxPlane, normal: PxVec3, distance: float) #no_context {
            Constructor(this, *normal, distance);
        }

        /*
        \brief Constructor from a point on the plane and a normal
        */
        Constructor :: (this: *PxPlane, point: *PxVec3, normal: *PxVec3) -> void #cpp_method #foreign physxcommon_static "??0PxPlane@physx@@QEAA@AEBV?$PxVec3T@M@1@0@Z";
        Constructor :: (this: *PxPlane, point: PxVec3, normal: PxVec3) #no_context {
            Constructor(this, *point, *normal);
        }

        /*
        \brief Constructor from three points
        */
        Constructor :: (this: *PxPlane, p0: *PxVec3, p1: *PxVec3, p2: *PxVec3) -> void #cpp_method #foreign physxcommon_static "??0PxPlane@physx@@QEAA@AEBV?$PxVec3T@M@1@00@Z";
        Constructor :: (this: *PxPlane, p0: PxVec3, p1: PxVec3, p2: PxVec3) #no_context {
            Constructor(this, *p0, *p1, *p2);
        }

        distance :: (this: *PxPlane, p: *PxVec3) -> float #cpp_method #foreign physxcharacterkinematic_static "?distance@PxPlane@physx@@QEBAMAEBV?$PxVec3T@M@2@@Z";
        distance :: (this: *PxPlane, p: PxVec3) -> float #no_context {
            return distance(this, *p);
        }

        /*
        \brief projects p into the plane
        */
        project :: (this: *PxPlane, p: *PxVec3) -> PxVec3 #cpp_method #foreign physxcharacterkinematic_static "?project@PxPlane@physx@@QEBA?AV?$PxVec3T@M@2@AEBV32@@Z";
        project :: (this: *PxPlane, p: PxVec3) -> PxVec3 #no_context {
            return project(this, *p);
        }

        /*
        \brief equivalent plane with unit normal
        */
        normalize :: (this: *PxPlane) -> void #cpp_method #foreign physxfoundation_static "?normalize@PxPlane@physx@@QEAAXXZ";

        /*
        \brief transform plane
        */
        transform :: (this: *PxPlane, pose: *PxTransform) -> PxPlane #cpp_method #cpp_return_type_is_non_pod #foreign physxcharacterkinematic_static "?transform@PxPlane@physx@@QEBA?AV12@AEBV?$PxTransformT@M@2@@Z";
        transform :: (this: *PxPlane, pose: PxTransform) -> PxPlane #no_context {
            return transform(this, *pose);
        }

        n: PxVec3; //!< The normal to the plane
        d: float; //!< The distance from the origin
    }

    /*
    \brief returns true if the two planes are exactly equal
    */
    operator== :: (this: *physx.PxPlane, p: *physx.PxPlane) -> bool #cpp_method #foreign physxcommon_static "??8PxPlane@physx@@QEBA_NAEBV01@@Z";
    operator== :: (this: physx.PxPlane, p: physx.PxPlane) -> bool #no_context {
        return operator==(*this, *p);
    }

    /*
    \brief finds the shortest rotation between two vectors.
    
    \param[in] from the vector to start from
    \param[in] target the vector to rotate to
    \return a rotation about an axis normal to the two vectors which takes one to the other via the shortest path
    */
    PxShortestRotation :: (from: *PxVec3, target: *PxVec3) -> PxQuat #foreign physxfoundation_static "?PxShortestRotation@physx@@YA?AV?$PxQuatT@M@1@AEBV?$PxVec3T@M@1@0@Z";
    PxShortestRotation :: (from: PxVec3, target: PxVec3) -> PxQuat #no_context {
        return PxShortestRotation(*from, *target);
    }

    /* \brief diagonalizes a 3x3 symmetric matrix y
    
    The returned matrix satisfies M = R * D * R', where R is the rotation matrix for the output quaternion, R' its
    transpose, and D the diagonal matrix
    
    If the matrix is not symmetric, the result is undefined.
    
    \param[in] m the matrix to diagonalize
    \param[out] axes a quaternion rotation which diagonalizes the matrix
    \return the vector diagonal of the diagonalized matrix.
    */
    PxDiagonalize :: (m: *PxMat33, axes: *PxQuat) -> PxVec3 #foreign physxfoundation_static "?PxDiagonalize@physx@@YA?AV?$PxVec3T@M@1@AEBV?$PxMat33T@M@1@AEAV?$PxQuatT@M@1@@Z";
    PxDiagonalize :: (m: PxMat33, axes: *PxQuat) -> PxVec3 #no_context {
        return PxDiagonalize(*m, axes);
    }

    /* \brief creates a transform from the endpoints of a segment, suitable for an actor transform for a PxCapsuleGeometry
    
    \param[in] p0 one end of major axis of the capsule
    \param[in] p1 the other end of the axis of the capsule
    \param[out] halfHeight the halfHeight of the capsule. This parameter is optional.
    \return A PxTransform which will transform the vector (1,0,0) to the capsule axis shrunk by the halfHeight
    */
    PxTransformFromSegment :: (p0: *PxVec3, p1: *PxVec3, halfHeight: *PxReal = null) -> PxTransform #foreign physxfoundation_static "?PxTransformFromSegment@physx@@YA?AV?$PxTransformT@M@1@AEBV?$PxVec3T@M@1@0PEAM@Z";
    PxTransformFromSegment :: (p0: PxVec3, p1: PxVec3, halfHeight: *PxReal = null) -> PxTransform #no_context {
        return PxTransformFromSegment(*p0, *p1, halfHeight);
    }

    /* \brief creates a transform from a plane equation, suitable for an actor transform for a PxPlaneGeometry
    
    \param[in] plane the desired plane equation
    \return a PxTransform which will transform the plane PxPlane(1,0,0,0) to the specified plane
    */
    PxTransformFromPlaneEquation :: (plane: *PxPlane) -> PxTransform #foreign physxfoundation_static "?PxTransformFromPlaneEquation@physx@@YA?AV?$PxTransformT@M@1@AEBVPxPlane@1@@Z";
    PxTransformFromPlaneEquation :: (plane: PxPlane) -> PxTransform #no_context {
        return PxTransformFromPlaneEquation(*plane);
    }

    /* \brief creates a plane equation from a transform, such as the actor transform for a PxPlaneGeometry
    
    \param[in] pose		the transform
    \return the plane
    */
    PxPlaneEquationFromTransform :: (pose: *PxTransform) -> PxPlane #cpp_return_type_is_non_pod #foreign physxcharacterkinematic_static "?PxPlaneEquationFromTransform@physx@@YA?AVPxPlane@1@AEBV?$PxTransformT@M@1@@Z";
    PxPlaneEquationFromTransform :: (pose: PxTransform) -> PxPlane #no_context {
        return PxPlaneEquationFromTransform(*pose);
    }

    /*
    \brief Spherical linear interpolation of two quaternions.
    \param[in] t is the interpolation parameter in range (0, 1)
    \param[in] left is the start of the interpolation
    \param[in] right is the end of the interpolation
    \return Returns left when t=0, right when t=1 and a linear interpolation of left and right when 0 < t < 1.
    Returns angle between -PI and PI in radians
    */
    PxSlerp :: (t: PxReal, left: *PxQuat, right: *PxQuat) -> PxQuat #foreign physx_static "?PxSlerp@physx@@YA?AV?$PxQuatT@M@1@MAEBV21@0@Z";
    PxSlerp :: (t: PxReal, left: PxQuat, right: PxQuat) -> PxQuat #no_context {
        return PxSlerp(t, *left, *right);
    }

    /*
    \brief integrate transform.
    \param[in] curTrans The current transform
    \param[in] linvel Linear velocity
    \param[in] angvel Angular velocity
    \param[in] timeStep The time-step for integration
    \param[out] result The integrated transform
    */
    PxIntegrateTransform :: (curTrans: *PxTransform, linvel: *PxVec3, angvel: *PxVec3, timeStep: PxReal, result: *PxTransform) -> void #foreign physxfoundation_static "?PxIntegrateTransform@physx@@YAXAEBV?$PxTransformT@M@1@AEBV?$PxVec3T@M@1@1MAEAV21@@Z";
    PxIntegrateTransform :: (curTrans: PxTransform, linvel: PxVec3, angvel: PxVec3, timeStep: PxReal, result: *PxTransform) #no_context {
        PxIntegrateTransform(*curTrans, *linvel, *angvel, timeStep, result);
    }

    //!	\brief Compute the exponent of a PxVec3
    PxExp :: (v: *PxVec3) -> PxQuat #foreign physx_static "?PxExp@physx@@YA?AV?$PxQuatT@M@1@AEBV?$PxVec3T@M@1@@Z";
    PxExp :: (v: PxVec3) -> PxQuat #no_context {
        return PxExp(*v);
    }

    /*
    \brief computes a oriented bounding box around the scaled basis.
    \param basis Input = skewed basis, Output = (normalized) orthogonal basis.
    \return Bounding box extent.
    */
    PxOptimizeBoundingBox :: (basis: *PxMat33) -> PxVec3 #foreign physxfoundation_static "?PxOptimizeBoundingBox@physx@@YA?AV?$PxVec3T@M@1@AEAV?$PxMat33T@M@1@@Z";

    /*
    \brief return Returns 0 if v.x is largest element of v, 1 if v.y is largest element, 2 if v.z is largest element.
    */
    PxLargestAxis :: (v: *PxVec3) -> PxU32 #foreign physxcommon_static "?PxLargestAxis@physx@@YAIAEBV?$PxVec3T@M@1@@Z";
    PxLargestAxis :: (v: PxVec3) -> PxU32 #no_context {
        return PxLargestAxis(*v);
    }

    /*
    \brief Compute the angle between two non-unit vectors
    \param[in] v0 is one of the non-unit vectors
    \param[in] v1 is the other of the two non-unit vectors
    \return Returns the angle (in radians) between the two vector v0 and v1.
    */
    PxComputeAngle :: (v0: *PxVec3, v1: *PxVec3) -> PxF32 #foreign physxcommon_static "?PxComputeAngle@physx@@YAMAEBV?$PxVec3T@M@1@0@Z";
    PxComputeAngle :: (v0: PxVec3, v1: PxVec3) -> PxF32 #no_context {
        return PxComputeAngle(*v0, *v1);
    }

    /*
    \brief Compute two normalized vectors (right and up) that are perpendicular to an input normalized vector (dir).
    \param[in] dir is a normalized vector that is used to compute the perpendicular vectors.
    \param[out] right is the first of the two vectors perpendicular to dir
    \param[out] up is the second of the two vectors perpendicular to dir
    */
    PxComputeBasisVectors :: (dir: *PxVec3, right: *PxVec3, up: *PxVec3) -> void #foreign physxcharacterkinematic_static "?PxComputeBasisVectors@physx@@YAXAEBV?$PxVec3T@M@1@AEAV21@1@Z";
    PxComputeBasisVectors :: (dir: PxVec3, right: *PxVec3, up: *PxVec3) #no_context {
        PxComputeBasisVectors(*dir, right, up);
    }

    /*
    \brief Compute three normalized vectors (dir, right and up) that are parallel to (dir) and perpendicular to (right, up) the
    normalized direction vector (p1 - p0)/||p1 - p0||.
    \param[in] p0 is used to compute the normalized vector dir = (p1 - p0)/||p1 - p0||.
    \param[in] p1 is used to compute the normalized vector dir = (p1 - p0)/||p1 - p0||.
    \param[out] dir is the normalized vector (p1 - p0)/||p1 - p0||.
    \param[out] right is the first of the two normalized vectors perpendicular to dir
    \param[out] up is the second of the two normalized vectors perpendicular to dir
    */
    PxComputeBasisVectors :: (p0: *PxVec3, p1: *PxVec3, dir: *PxVec3, right: *PxVec3, up: *PxVec3) -> void #foreign physxcommon_static "?PxComputeBasisVectors@physx@@YAXAEBV?$PxVec3T@M@1@0AEAV21@11@Z";
    PxComputeBasisVectors :: (p0: PxVec3, p1: PxVec3, dir: *PxVec3, right: *PxVec3, up: *PxVec3) #no_context {
        PxComputeBasisVectors(*p0, *p1, dir, right, up);
    }

    /*
    \brief Compute (i+1)%3
    */
    PxGetNextIndex3 :: (i: PxU32) -> PxU32 #foreign physxfoundation_static "?PxGetNextIndex3@physx@@YAII@Z";

    computeBarycentric :: (a: *PxVec3, b: *PxVec3, c: *PxVec3, d: *PxVec3, p: *PxVec3, bary: *PxVec4) -> void #foreign physxcommon_static "?computeBarycentric@physx@@YAXAEBV?$PxVec3T@M@1@0000AEAV?$PxVec4T@M@1@@Z";
    computeBarycentric :: (a: PxVec3, b: PxVec3, c: PxVec3, d: PxVec3, p: PxVec3, bary: *PxVec4) #no_context {
        computeBarycentric(*a, *b, *c, *d, *p, bary);
    }

    // lerp
    Interpolation :: struct {
        PxLerp :: (a: float, b: float, t: float) -> float #foreign physxcommon_static "?PxLerp@Interpolation@physx@@SAMMMM@Z";

        PxBiLerp :: (f00: PxReal, f10: PxReal, f01: PxReal, f11: PxReal, tx: PxReal, ty: PxReal) -> PxReal #foreign physxcommon_static "?PxBiLerp@Interpolation@physx@@SAMMMMMMM@Z";

        PxTriLerp :: (f000: PxReal, f100: PxReal, f010: PxReal, f110: PxReal, f001: PxReal, f101: PxReal, f011: PxReal, f111: PxReal, tx: PxReal, ty: PxReal, tz: PxReal) -> PxReal #foreign physxcommon_static "?PxTriLerp@Interpolation@physx@@SAMMMMMMMMMMMM@Z";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxMutexImpl :: struct {
        /*
        The constructor for Mutex creates a mutex. It is initially unlocked.
        */
        Constructor :: (this: *PxMutexImpl) -> void #cpp_method #foreign physxfoundation_static "??0PxMutexImpl@physx@@QEAA@XZ";

        /*
        The destructor for Mutex deletes the mutex.
        */
        Destructor :: (this: *PxMutexImpl) -> void #cpp_method #foreign physxfoundation_static "??1PxMutexImpl@physx@@QEAA@XZ";

        /*
        Acquire (lock) the mutex. If the mutex is already locked
        by another thread, this method blocks until the mutex is
        unlocked.
        */
        lock :: (this: *PxMutexImpl) -> void #cpp_method #foreign physxfoundation_static "?lock@PxMutexImpl@physx@@QEAAXXZ";

        /*
        Acquire (lock) the mutex. If the mutex is already locked
        by another thread, this method returns false without blocking.
        */
        trylock :: (this: *PxMutexImpl) -> bool #cpp_method #foreign physxfoundation_static "?trylock@PxMutexImpl@physx@@QEAA_NXZ";

        /*
        Release (unlock) the mutex.
        */
        unlock :: (this: *PxMutexImpl) -> void #cpp_method #foreign physxfoundation_static "?unlock@PxMutexImpl@physx@@QEAAXXZ";

        /*
        Size of this class.
        */
        getSize :: () -> u32 #foreign physxfoundation_static "?getSize@PxMutexImpl@physx@@SAIXZ";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxMutexT :: struct(Alloc: Type) {
        #as alloc: Alloc; // jai: no "using" to avoid name-clashes

        ScopedLock :: struct {
            mMutex: *PxMutexT(Alloc);
        }

        mImpl: *PxMutexImpl;
    }

    PxReadWriteLock :: struct {
        Constructor :: (this: *PxReadWriteLock) -> void #cpp_method #foreign physxfoundation_static "??0PxReadWriteLock@physx@@QEAA@XZ";
        Destructor :: (this: *PxReadWriteLock) -> void #cpp_method #foreign physxfoundation_static "??1PxReadWriteLock@physx@@QEAA@XZ";

        // "takeLock" can only be false if the thread already holds the mutex, e.g. if it already acquired the write lock
        lockReader :: (this: *PxReadWriteLock, takeLock: bool) -> void #cpp_method #foreign physxfoundation_static "?lockReader@PxReadWriteLock@physx@@QEAAX_N@Z";
        lockWriter :: (this: *PxReadWriteLock) -> void #cpp_method #foreign physxfoundation_static "?lockWriter@PxReadWriteLock@physx@@QEAAXXZ";

        unlockReader :: (this: *PxReadWriteLock) -> void #cpp_method #foreign physxfoundation_static "?unlockReader@PxReadWriteLock@physx@@QEAAXXZ";
        unlockWriter :: (this: *PxReadWriteLock) -> void #cpp_method #foreign physxfoundation_static "?unlockWriter@PxReadWriteLock@physx@@QEAAXXZ";

        ReadWriteLockImpl :: struct {}
        mImpl: *ReadWriteLockImpl;
    }

    PxMutex :: PxMutexT;

    PxStack :: struct(PxAllocator: Type) {
        mAllocator: PxAllocator;
        mSize:      u32;
        mCapacity:  u32;
        mMemory:    *s32;
        mRealloc:   bool;
    }

    /*!
    Simple allocation pool
    */
    PxPoolBase :: struct(T: Type, Alloc: Type) {
        #as pxuserallocated: PxUserAllocated; // jai: no "using" to avoid name-clashes
        #as alloc: Alloc; // jai: no "using" to avoid name-clashes

        FreeList :: struct {
            mNext: *FreeList;
        }

        // All the allocated slabs, sorted by pointer
        mSlabs:           PxArray(*void, Alloc);

        mElementsPerSlab: u32;
        mUsed:            u32;
        mSlabSize:        u32;

        mFreeElement:     *FreeList; // Head of free-list
    }

    // original pool implementation
    PxPool :: struct(T: Type, Alloc: Type) {
        #as pxpoolbase: PxPoolBase(T, Alloc); // jai: no "using" to avoid name-clashes
    }

    // allows specification of the slab size instead of the occupancy
    PxPool2 :: struct(T: Type, slabSize: u32, Alloc: Type) {
        #as pxpoolbase: PxPoolBase(T, Alloc); // jai: no "using" to avoid name-clashes
    }

    /*
    \brief The pure virtual callback interface for general purpose instrumentation and profiling of GameWorks modules as
    well as applications
    */
    PxProfilerCallback :: struct {
        vtable: *PxProfilerCallback_VTable;
    }
    PxProfilerCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxProfilerCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        zoneStart: (this: *PxProfilerCallback, eventName: *u8, detached: bool, contextId: u64) -> *void #cpp_method;

        zoneEnd: (this: *PxProfilerCallback, profilerData: *void, eventName: *u8, detached: bool, contextId: u64) -> void #cpp_method;
    }

    PxProfilerCallback_Destructor :: inline (this: *PxProfilerCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxProfilerCallback_zoneStart :: inline (this: *PxProfilerCallback, eventName: *u8, detached: bool, contextId: u64) -> *void { return this.vtable.zoneStart(this, eventName, detached, contextId); }

    PxProfilerCallback_zoneEnd :: inline (this: *PxProfilerCallback, profilerData: *void, eventName: *u8, detached: bool, contextId: u64) { this.vtable.zoneEnd(this, profilerData, eventName, detached, contextId); }

    vtable :: (obj: *PxProfilerCallback) -> *PxProfilerCallback_VTable { return obj.vtable; }


    PxProfileScoped :: struct {
        mCallback:     *PxProfilerCallback;
        mEventName:    *u8;
        mProfilerData: *void;
        mContextId:    u64;
        mDetached:     bool;
    }

    PxSListEntry :: struct {
        Constructor :: (this: *PxSListEntry) -> void #cpp_method #foreign physx_static "??0PxSListEntry@physx@@QEAA@XZ";

        // Only use on elements returned by SList::flush()
        // because the operation is not atomic.
        next :: (this: *PxSListEntry) -> *PxSListEntry #cpp_method #foreign physx_static "?next@PxSListEntry@physx@@QEAAPEAV12@XZ";

        mNext: *PxSListEntry;
    }

    // template-less implementation
    PxSListImpl :: struct {
        Constructor :: (this: *PxSListImpl) -> void #cpp_method #foreign physxfoundation_static "??0PxSListImpl@physx@@QEAA@XZ";
        Destructor :: (this: *PxSListImpl) -> void #cpp_method #foreign physxfoundation_static "??1PxSListImpl@physx@@QEAA@XZ";
        push :: (this: *PxSListImpl, entry: *PxSListEntry) -> void #cpp_method #foreign physxfoundation_static "?push@PxSListImpl@physx@@QEAAXPEAVPxSListEntry@2@@Z";
        pop :: (this: *PxSListImpl) -> *PxSListEntry #cpp_method #foreign physxfoundation_static "?pop@PxSListImpl@physx@@QEAAPEAVPxSListEntry@2@XZ";
        flush :: (this: *PxSListImpl) -> *PxSListEntry #cpp_method #foreign physxfoundation_static "?flush@PxSListImpl@physx@@QEAAPEAVPxSListEntry@2@XZ";
        getSize :: () -> u32 #foreign physxfoundation_static "?getSize@PxSListImpl@physx@@SAIXZ";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxSListT :: struct(Alloc: Type) {
        #as alloc: Alloc; // jai: no "using" to avoid name-clashes

        mImpl: *PxSListImpl;
    }

    PxSList :: PxSListT;

    /*
    Socket abstraction API
    */
    PxSocket :: struct {
        #as using pxuserallocated: PxUserAllocated;
        vtable: *PxSocket_VTable;

        Constructor :: (this: *PxSocket, inEnableBuffering := true, blocking := true) -> void #cpp_method #foreign physxfoundation_static "??0PxSocket@physx@@QEAA@_N0@Z";

        /*!
        Opens a network socket for input and/or output
        
        \param host
        Name of the host to connect to. This can be an IP, URL, etc
        
        \param port
        The port to connect to on the remote host
        
        \param timeout
        Timeout in ms until the connection must be established.
        
        \return
        True if the connection was successful, false otherwise
        */
        connect :: (this: *PxSocket, host: *u8, port: u16, timeout: u32 = 1000) -> bool #cpp_method #foreign physxfoundation_static "?connect@PxSocket@physx@@QEAA_NPEBDGI@Z";

        /*!
        Opens a network socket for input and/or output as a server.  Put the connection in listening mode
        
        \param port
        The port on which the socket listens
        */
        listen :: (this: *PxSocket, port: u16) -> bool #cpp_method #foreign physxfoundation_static "?listen@PxSocket@physx@@QEAA_NG@Z";

        /*!
        Accept a connection on a socket that is in listening mode
        
        \note
        This method only supports a single connection client.  Additional clients
        that connect to the listening port will overwrite the existing socket handle.
        
        \param block
        whether or not the call should block
        
        \return whether a connection was established
        */
        accept :: (this: *PxSocket, block: bool) -> bool #cpp_method #foreign physxfoundation_static "?accept@PxSocket@physx@@QEAA_N_N@Z";

        /*!
        Disconnects an open socket
        */
        disconnect :: (this: *PxSocket) -> void #cpp_method #foreign physxfoundation_static "?disconnect@PxSocket@physx@@QEAAXXZ";

        /*!
        Returns whether the socket is currently open (connected) or not.
        
        \return
        True if the socket is connected, false otherwise
        */
        isConnected :: (this: *PxSocket) -> bool #cpp_method #foreign physxfoundation_static "?isConnected@PxSocket@physx@@QEBA_NXZ";

        /*!
        Returns the name of the connected host. This is the same as the string
        that was supplied to the connect call.
        
        \return
        The name of the connected host
        */
        getHost :: (this: *PxSocket) -> *u8 #cpp_method #foreign physxfoundation_static "?getHost@PxSocket@physx@@QEBAPEBDXZ";

        /*!
        Returns the port of the connected host. This is the same as the port
        that was supplied to the connect call.
        
        \return
        The port of the connected host
        */
        getPort :: (this: *PxSocket) -> u16 #cpp_method #foreign physxfoundation_static "?getPort@PxSocket@physx@@QEBAGXZ";

        /*!
        Flushes the output stream. Until the stream is flushed, there is no
        guarantee that the written data has actually reached the destination
        storage. Flush forces all buffered data to be sent to the output.
        
        \note flush always blocks. If the socket is in non-blocking mode, this will result
        the thread spinning.
        
        \return
        True if the flush was successful, false otherwise
        */
        flush :: (this: *PxSocket) -> bool #cpp_method #foreign physxfoundation_static "?flush@PxSocket@physx@@QEAA_NXZ";

        /*!
        Writes data to the output stream.
        
        \param data
        Pointer to a  block of data to write to the stream
        
        \param length
        Amount of data to write, in bytes
        
        \return
        Number of bytes actually written. This could be lower than length if the socket is non-blocking.
        */
        write :: (this: *PxSocket, data: *u8, length: u32) -> u32 #cpp_method #foreign physxfoundation_static "?write@PxSocket@physx@@QEAAIPEBEI@Z";

        /*!
        Reads data from the output stream.
        
        \param data
        Pointer to a buffer where the read data will be stored.
        
        \param length
        Amount of data to read, in bytes.
        
        \return
        Number of bytes actually read. This could be lower than length if the stream end is
        encountered or the socket is non-blocking.
        */
        read :: (this: *PxSocket, data: *u8, length: u32) -> u32 #cpp_method #foreign physxfoundation_static "?read@PxSocket@physx@@QEAAIPEAEI@Z";

        /*!
        Sets blocking mode of the socket.
        Socket must be connected, otherwise calling this method won't take any effect.
        */
        setBlocking :: (this: *PxSocket, blocking: bool) -> void #cpp_method #foreign physxfoundation_static "?setBlocking@PxSocket@physx@@QEAAX_N@Z";

        /*!
        Returns whether read/write/flush calls to the socket are blocking.
        
        \return
        True if the socket is blocking.
        */
        isBlocking :: (this: *PxSocket) -> bool #cpp_method #foreign physxfoundation_static "?isBlocking@PxSocket@physx@@QEBA_NXZ";

        SocketImpl :: struct {}
        mImpl: *SocketImpl;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxSocket, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxfoundation_static "??1PxSocket@physx@@UEAA@XZ";
    }
    PxSocket_VTable :: struct #type_info_none {
        Destructor: (this: *PxSocket, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }
    PxSocket_Destructor :: inline (this: *PxSocket, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSocket) -> *PxSocket_VTable { return obj.vtable; }


    /*
    \brief Iterator class for iterating over arrays of data that may be interleaved with other data.
    
    This class is used for iterating over arrays of elements that may have a larger element to element
    offset, called the stride, than the size of the element itself (non-contiguous).
    
    The template parameter T denotes the type of the element accessed. The stride itself
    is stored as a member field so multiple instances of a PxStrideIterator class can have
    different strides. This is useful for cases were the stride depends on runtime configuration.
    
    The stride iterator can be used for index based access, e.g.:
    \code
    PxStrideIterator<PxVec3> strideArray(...);
    for (unsigned i = 0; i < 10; ++i)
    {
    PxVec3& vec = strideArray[i];
    ...
    }
    \endcode
    or iteration by increment, e.g.:
    \code
    PxStrideIterator<PxVec3> strideBegin(...);
    PxStrideIterator<PxVec3> strideEnd(strideBegin + 10);
    for (PxStrideIterator<PxVec3> it = strideBegin; it < strideEnd; ++it)
    {
    PxVec3& vec = *it;
    ...
    }
    \endcode
    
    Two special cases:
    - A stride of sizeof(T) represents a regular c array of type T.
    - A stride of 0 can be used to describe re-occurrence of the same element multiple times.
    
    */
    PxStrideIterator :: struct(T: Type) {
        StripConst :: struct(X: Type) {
            Type :: X;
        }

        mPtr:    *T;
        mStride: PxU32;
    }

    /*!
    Implementation notes:
    * - Calling set() on an already signaled Sync does not change its state.
    * - Calling reset() on an already reset Sync does not change its state.
    * - Calling set() on a reset Sync wakes all waiting threads (potential for thread contention).
    * - Calling wait() on an already signaled Sync will return true immediately.
    * - NOTE: be careful when pulsing an event with set() followed by reset(), because a
    *   thread that is not waiting on the event will miss the signal.
    */
    PxSyncImpl :: struct {
        waitForever: u32 : 4294967295;

        Constructor :: (this: *PxSyncImpl) -> void #cpp_method #foreign physxfoundation_static "??0PxSyncImpl@physx@@QEAA@XZ";

        Destructor :: (this: *PxSyncImpl) -> void #cpp_method #foreign physxfoundation_static "??1PxSyncImpl@physx@@QEAA@XZ";

        /* Wait on the object for at most the given number of ms. Returns
        *  true if the object is signaled. Sync::waitForever will block forever
        *  or until the object is signaled.
        */
        wait :: (this: *PxSyncImpl, milliseconds: u32 = waitForever) -> bool #cpp_method #foreign physxfoundation_static "?wait@PxSyncImpl@physx@@QEAA_NI@Z";

        /* Signal the synchronization object, waking all threads waiting on it */
        set :: (this: *PxSyncImpl) -> void #cpp_method #foreign physxfoundation_static "?set@PxSyncImpl@physx@@QEAAXXZ";

        /* Reset the synchronization object */
        reset :: (this: *PxSyncImpl) -> void #cpp_method #foreign physxfoundation_static "?reset@PxSyncImpl@physx@@QEAAXXZ";

        /*
        Size of this class.
        */
        getSize :: () -> u32 #foreign physxfoundation_static "?getSize@PxSyncImpl@physx@@SAIXZ";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*!
    Implementation notes:
    * - Calling set() on an already signaled Sync does not change its state.
    * - Calling reset() on an already reset Sync does not change its state.
    * - Calling set() on a reset Sync wakes all waiting threads (potential for thread contention).
    * - Calling wait() on an already signaled Sync will return true immediately.
    * - NOTE: be careful when pulsing an event with set() followed by reset(), because a
    *   thread that is not waiting on the event will miss the signal.
    */
    PxSyncT :: struct(Alloc: Type) {
        #as alloc: Alloc; // jai: no "using" to avoid name-clashes

        waitForever: u32 : PxSyncImpl.waitForever;

        mImpl:       *PxSyncImpl;
    }

    PxSync :: PxSyncT;

    PxThreadPriority :: struct {
        Enum :: enum s32 {
            HIGH         :: 0;
            ABOVE_NORMAL :: 1;
            NORMAL       :: 2;
            BELOW_NORMAL :: 3;
            LOW          :: 4;
            FORCE_DWORD  :: -1;

            eHIGH         :: HIGH;
            eABOVE_NORMAL :: ABOVE_NORMAL;
            eNORMAL       :: NORMAL;
            eBELOW_NORMAL :: BELOW_NORMAL;
            eLOW          :: LOW;
            eFORCE_DWORD  :: FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxRunnable :: struct {
        vtable: *PxRunnable_VTable;
        Constructor :: (this: *PxRunnable) -> void #cpp_method #foreign physxcommon_static "??0PxRunnable@physx@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxRunnable, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxRunnable@physx@@UEAA@XZ";
        virtual_execute :: (this: *PxRunnable) -> void #cpp_method #foreign physxcommon_static "?execute@PxRunnable@physx@@UEAAXXZ";
    }
    PxRunnable_VTable :: struct #type_info_none {
        Destructor: (this: *PxRunnable, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        execute: (this: *PxRunnable) -> void #cpp_method;
    }

    PxRunnable_Destructor :: inline (this: *PxRunnable, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    PxRunnable_execute :: inline (this: *PxRunnable) { this.vtable.execute(this); }

    vtable :: (obj: *PxRunnable) -> *PxRunnable_VTable { return obj.vtable; }


    PxThreadImpl :: struct {
        Id :: u64;
        ExecuteFn :: #type (unknown0: *void) -> *void #c_call;

        getDefaultStackSize :: () -> PxU32 #foreign physxfoundation_static "?getDefaultStackSize@PxThreadImpl@physx@@SAIXZ";
        getId :: () -> Id #foreign physxfoundation_static "?getId@PxThreadImpl@physx@@SA_KXZ";

        /*
        Construct (but do not start) the thread object. The OS thread object will not be created
        until start() is called. Executes in the context
        of the spawning thread.
        */
        Constructor :: (this: *PxThreadImpl) -> void #cpp_method #foreign physxfoundation_static "??0PxThreadImpl@physx@@QEAA@XZ";

        /*
        Construct and start the the thread, passing the given arg to the given fn. (pthread style)
        */
        Constructor :: (this: *PxThreadImpl, fn: ExecuteFn, arg: *void, name: *u8) -> void #cpp_method #foreign physxfoundation_static "??0PxThreadImpl@physx@@QEAA@P6APEAXPEAX@Z0PEBD@Z";

        /*
        Deallocate all resources associated with the thread. Should be called in the
        context of the spawning thread.
        */
        Destructor :: (this: *PxThreadImpl) -> void #cpp_method #foreign physxfoundation_static "??1PxThreadImpl@physx@@QEAA@XZ";

        /*
        Create the OS thread and start it running. Called in the context of the spawning thread.
        If an affinity mask has previously been set then it will be applied after the
        thread has been created.
        */
        start :: (this: *PxThreadImpl, stackSize: PxU32, r: *PxRunnable) -> void #cpp_method #foreign physxfoundation_static "?start@PxThreadImpl@physx@@QEAAXIPEAVPxRunnable@2@@Z";

        /*
        Violently kill the current thread. Blunt instrument, not recommended since
        it can leave all kinds of things unreleased (stack, memory, mutexes...) Should
        be called in the context of the spawning thread.
        */
        kill :: (this: *PxThreadImpl) -> void #cpp_method #foreign physxfoundation_static "?kill@PxThreadImpl@physx@@QEAAXXZ";

        /*
        Stop the thread. Signals the spawned thread that it should stop, so the
        thread should check regularly
        */
        signalQuit :: (this: *PxThreadImpl) -> void #cpp_method #foreign physxfoundation_static "?signalQuit@PxThreadImpl@physx@@QEAAXXZ";

        /*
        Wait for a thread to stop. Should be called in the context of the spawning
        thread. Returns false if the thread has not been started.
        */
        waitForQuit :: (this: *PxThreadImpl) -> bool #cpp_method #foreign physxfoundation_static "?waitForQuit@PxThreadImpl@physx@@QEAA_NXZ";

        /*
        check whether the thread is signalled to quit. Called in the context of the
        spawned thread.
        */
        quitIsSignalled :: (this: *PxThreadImpl) -> bool #cpp_method #foreign physxfoundation_static "?quitIsSignalled@PxThreadImpl@physx@@QEAA_NXZ";

        /*
        Cleanly shut down this thread. Called in the context of the spawned thread.
        */
        quit :: (this: *PxThreadImpl) -> void #cpp_method #foreign physxfoundation_static "?quit@PxThreadImpl@physx@@QEAAXXZ";

        /*
        Change the affinity mask for this thread. The mask is a platform
        specific value.
        
        On Windows, Linux, and Switch platforms, each set mask bit represents
        the index of a logical processor that the OS may schedule thread execution on.
        Bits outside the range of valid logical processors may be ignored or cause
        the function to return an error.
        
        On Apple platforms, this function has no effect.
        
        If the thread has not yet been started then the mask is stored
        and applied when the thread is started.
        
        If the thread has already been started then this method	returns the
        previous affinity mask on success, otherwise it returns zero.
        */
        setAffinityMask :: (this: *PxThreadImpl, mask: PxU32) -> PxU32 #cpp_method #foreign physxfoundation_static "?setAffinityMask@PxThreadImpl@physx@@QEAAII@Z";

        getPriority :: (threadId: Id) -> PxThreadPriority.Enum #foreign physxfoundation_static "?getPriority@PxThreadImpl@physx@@SA?AW4Enum@PxThreadPriority@2@_K@Z";

        /* Set thread priority. */
        setPriority :: (this: *PxThreadImpl, prio: PxThreadPriority.Enum) -> void #cpp_method #foreign physxfoundation_static "?setPriority@PxThreadImpl@physx@@QEAAXW4Enum@PxThreadPriority@2@@Z";

        /* set the thread's name */
        setName :: (this: *PxThreadImpl, name: *u8) -> void #cpp_method #foreign physxfoundation_static "?setName@PxThreadImpl@physx@@QEAAXPEBD@Z";

        /* Put the current thread to sleep for the given number of milliseconds */
        sleep :: (ms: PxU32) -> void #foreign physxfoundation_static "?sleep@PxThreadImpl@physx@@SAXI@Z";

        /* Yield the current thread's slot on the CPU */
        yield :: () -> void #foreign physxfoundation_static "?yield@PxThreadImpl@physx@@SAXXZ";

        /* Inform the processor that we're in a busy wait to give it a chance to do something clever.
        yield() yields the thread, while yieldProcessor() aims to yield the processor */
        yieldProcessor :: () -> void #foreign physxfoundation_static "?yieldProcessor@PxThreadImpl@physx@@SAXXZ";

        /* Return the number of physical cores (does not include hyper-threaded cores), returns 0 on failure */
        getNbPhysicalCores :: () -> PxU32 #foreign physxfoundation_static "?getNbPhysicalCores@PxThreadImpl@physx@@SAIXZ";

        /*
        Size of this class.
        */
        getSize :: () -> PxU32 #foreign physxfoundation_static "?getSize@PxThreadImpl@physx@@SAIXZ";
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    Thread abstraction API
    */
    PxThreadT :: struct(Alloc: Type) {
        #as alloc: Alloc; // jai: no "using" to avoid name-clashes
        #as pxuserallocated: PxUserAllocated; // jai: no "using" to avoid name-clashes
        #as pxrunnable: PxRunnable; // jai: no "using" to avoid name-clashes

        Id :: PxThreadImpl.Id;

        mImpl: *PxThreadImpl;
    }

    PxThread :: PxThreadT;

    PxTlsAlloc :: () -> PxU32 #foreign physxfoundation_static "?PxTlsAlloc@physx@@YAIXZ";
    PxTlsFree :: (index: PxU32) -> void #foreign physxfoundation_static "?PxTlsFree@physx@@YAXI@Z";
    PxTlsGet :: (index: PxU32) -> *void #foreign physxfoundation_static "?PxTlsGet@physx@@YAPEAXI@Z";
    PxTlsGetValue :: (index: PxU32) -> u64 #foreign physxfoundation_static "?PxTlsGetValue@physx@@YA_KI@Z";
    PxTlsSet :: (index: PxU32, value: *void) -> PxU32 #foreign physxfoundation_static "?PxTlsSet@physx@@YAIIPEAX@Z";
    PxTlsSetValue :: (index: PxU32, value: u64) -> PxU32 #foreign physxfoundation_static "?PxTlsSetValue@physx@@YAII_K@Z";

    PxCounterFrequencyToTensOfNanos :: struct {
        mNumerator:   PxU64;
        mDenominator: PxU64;
        Constructor :: (this: *PxCounterFrequencyToTensOfNanos, inNum: PxU64, inDenom: PxU64) -> void #cpp_method #foreign physxfoundation_static "??0PxCounterFrequencyToTensOfNanos@physx@@QEAA@_K0@Z";
    }

    PxTime :: struct {
        Second :: PxF64;
        sNumTensOfNanoSecondsInASecond: PxU64 : 100000000;

        // This is supposedly guaranteed to not change after system boot
        // regardless of processors, speedstep, etc.
        getBootCounterFrequency :: () -> *PxCounterFrequencyToTensOfNanos #foreign physxfoundation_static "?getBootCounterFrequency@PxTime@physx@@SAAEBUPxCounterFrequencyToTensOfNanos@2@XZ";

        getCounterFrequency :: () -> PxCounterFrequencyToTensOfNanos #cpp_return_type_is_non_pod #foreign physxfoundation_static "?getCounterFrequency@PxTime@physx@@SA?AUPxCounterFrequencyToTensOfNanos@2@XZ";

        getCurrentCounterValue :: () -> PxU64 #foreign physxfoundation_static "?getCurrentCounterValue@PxTime@physx@@SA_KXZ";

        Constructor :: (this: *PxTime) -> void #cpp_method #foreign physxfoundation_static "??0PxTime@physx@@QEAA@XZ";
        getElapsedSeconds :: (this: *PxTime) -> Second #cpp_method #foreign physxfoundation_static "?getElapsedSeconds@PxTime@physx@@QEAANXZ";
        peekElapsedSeconds :: (this: *PxTime) -> Second #cpp_method #foreign physxfoundation_static "?peekElapsedSeconds@PxTime@physx@@QEAANXZ";
        getLastTime :: (this: *PxTime) -> Second #cpp_method #foreign physxfoundation_static "?getLastTime@PxTime@physx@@QEBANXZ";

        mTickCount:                     PxI64;
    }

    PxLittleEndian :: () -> u8 #foreign physxcommon_static "?PxLittleEndian@physx@@YADXZ";

    // PT: checked casts
    PxTo32 :: (value: PxU64) -> PxU32 #foreign physx_static "?PxTo32@physx@@YAI_K@Z";

    PxTo16 :: (value: PxU32) -> PxU16 #foreign physxcharacterkinematic_static "?PxTo16@physx@@YAGI@Z";

    PxTo8 :: (value: PxU16) -> PxU8 #foreign physxcommon_static "?PxTo8@physx@@YAEG@Z";

    PxTo8 :: (value: PxU32) -> PxU8 #foreign physxcommon_static "?PxTo8@physx@@YAEI@Z";

    PxTo8 :: (value: PxI32) -> PxU8 #foreign physxcommon_static "?PxTo8@physx@@YAEH@Z";

    PxToI8 :: (value: PxU32) -> PxI8 #foreign physxcommon_static "?PxToI8@physx@@YACI@Z";

    /*
    \brief 2 Element vector class.
    
    This is a 2-dimensional vector class with public data members.
    */
    PxVec2T :: struct(_Type: Type) {
        x: Type;
        y: Type;
    }

    PxVec2d :: PxVec2T(float64);

    aos :: struct {
        FloatV :: __m128;
        Vec3V :: __m128;
        Vec4V :: __m128;
        BoolV :: __m128;
        VecU32V :: __m128;
        VecI32V :: __m128;
        VecU16V :: __m128;
        VecI16V :: __m128;
        QuatV :: __m128;

        // Optimization for situations in which you cross product multiple vectors with the same vector.
        // Avoids 2X shuffles per product
        VecCrossV :: struct {
            mL1: Vec3V;
            mR1: Vec3V;
        }

        VecShiftV :: struct {
            shift: VecI32V;
        }

        Mat33V :: struct {
            Constructor :: (this: *Mat33V) -> void #cpp_method #foreign physxcommon_static "??0Mat33V@aos@physx@@QEAA@XZ";

            Constructor :: (this: *Mat33V, c0: *Vec3V, c1: *Vec3V, c2: *Vec3V) -> void #cpp_method #foreign physxcommon_static "??0Mat33V@aos@physx@@QEAA@AEBT__m128@@00@Z";
            Constructor :: (this: *Mat33V, c0: Vec3V, c1: Vec3V, c2: Vec3V) #no_context {
                Constructor(this, *c0, *c1, *c2);
            }

            col0: Vec3V;
            col1: Vec3V;
            col2: Vec3V;
        }

        Mat34V :: struct {
            col0: Vec3V;
            col1: Vec3V;
            col2: Vec3V;
            col3: Vec3V;
        }

        Mat43V :: struct {
            col0: Vec4V;
            col1: Vec4V;
            col2: Vec4V;
        }

        Mat44V :: struct {
            col0: Vec4V;
            col1: Vec4V;
            col2: Vec4V;
            col3: Vec4V;
        }

        // FloatV
        //(f,f,f,f)
        FLoad :: (f: PxF32) -> FloatV #foreign physxfoundation_static "?FLoad@aos@physx@@YA?AT__m128@@M@Z";

        // Vec3V
        //(f,f,f,0)
        V3Load :: (f: PxF32) -> Vec3V #foreign physxfoundation_static "?V3Load@aos@physx@@YA?AT__m128@@M@Z";

        //(f.x,f.y,f.z,0)
        V3LoadU :: (f: *PxVec3) -> Vec3V #foreign physxcommon_static "?V3LoadU@aos@physx@@YA?AT__m128@@AEBV?$PxVec3T@M@2@@Z";
        V3LoadU :: (f: PxVec3) -> Vec3V #no_context {
            return V3LoadU(*f);
        }

        //(f.x,f.y,f.z,0), f must be 16-byte aligned
        V3LoadA :: (f: *PxVec3) -> Vec3V #foreign physxcommon_static "?V3LoadA@aos@physx@@YA?AT__m128@@AEBV?$PxVec3T@M@2@@Z";
        V3LoadA :: (f: PxVec3) -> Vec3V #no_context {
            return V3LoadA(*f);
        }

        //(f.x,f.y,f.z,0)
        V3LoadU :: (f: *PxF32) -> Vec3V #foreign physxcommon_static "?V3LoadU@aos@physx@@YA?AT__m128@@PEBM@Z";

        //(f.x,f.y,f.z,0), f must be 16-byte aligned
        V3LoadA :: (f: *PxF32) -> Vec3V #foreign physxcommon_static "?V3LoadA@aos@physx@@YA?AT__m128@@PEBM@Z";

        // Vec4V
        //(f,f,f,f)
        V4Load :: (f: PxF32) -> Vec4V #foreign physxfoundation_static "?V4Load@aos@physx@@YA?AT__m128@@M@Z";

        //(f[0],f[1],f[2],f[3])
        V4LoadU :: (f: *PxF32) -> Vec4V #foreign physxcharacterkinematic_static "?V4LoadU@aos@physx@@YA?AT__m128@@QEBM@Z";

        //(f[0],f[1],f[2],f[3]), f must be 16-byte aligned
        V4LoadA :: (f: *PxF32) -> Vec4V #foreign physxcommon_static "?V4LoadA@aos@physx@@YA?AT__m128@@QEBM@Z";

        //(x,y,z,w)
        V4LoadXYZW :: (x: *PxF32, y: *PxF32, z: *PxF32, w: *PxF32) -> Vec4V #foreign physxcommon_static "?V4LoadXYZW@aos@physx@@YA?AT__m128@@AEBM000@Z";
        V4LoadXYZW :: (x: PxF32, y: PxF32, z: PxF32, w: PxF32) -> Vec4V #no_context {
            return V4LoadXYZW(*x, *y, *z, *w);
        }

        // BoolV
        //(f,f,f,f)
        BLoad :: (f: bool) -> BoolV #foreign physxcommon_static "?BLoad@aos@physx@@YA?AT__m128@@_N@Z";

        //(f[0],f[1],f[2],f[3])
        BLoad :: (f: *bool) -> BoolV #foreign physx_static "?BLoad@aos@physx@@YA?AT__m128@@QEB_N@Z";

        // VecU32V
        //(f,f,f,f)
        U4Load :: (f: PxU32) -> VecU32V #foreign physxcommon_static "?U4Load@aos@physx@@YA?AT__m128@@I@Z";

        //(f[0],f[1],f[2],f[3]), f must be 16-byte aligned
        U4LoadA :: (f: *PxU32) -> VecU32V #foreign physx_static "?U4LoadA@aos@physx@@YA?AT__m128@@PEBI@Z";

        //((U32)x, (U32)y, (U32)z, (U32)w)
        U4LoadXYZW :: (x: PxU32, y: PxU32, z: PxU32, w: PxU32) -> VecU32V #foreign physxcommon_static "?U4LoadXYZW@aos@physx@@YA?AT__m128@@IIII@Z";

        // VecI32V
        //(i,i,i,i)
        I4Load :: (i: PxI32) -> VecI32V #foreign physxcommon_static "?I4Load@aos@physx@@YA?AT__m128@@H@Z";

        //(i,i,i,i)
        I4LoadU :: (i: *PxI32) -> VecI32V #foreign physx_static "?I4LoadU@aos@physx@@YA?AT__m128@@PEBH@Z";

        //(i,i,i,i)
        I4LoadA :: (i: *PxI32) -> VecI32V #foreign physx_static "?I4LoadA@aos@physx@@YA?AT__m128@@PEBH@Z";

        // QuatV
        //(x = v[0], y=v[1], z=v[2], w=v3[3]) and array don't need to aligned
        QuatVLoadU :: (v: *PxF32) -> QuatV #foreign physxcommon_static "?QuatVLoadU@aos@physx@@YA?AT__m128@@PEBM@Z";

        //(x = v[0], y=v[1], z=v[2], w=v3[3]) and array need to aligned, fast load
        QuatVLoadA :: (v: *PxF32) -> QuatV #foreign physxcommon_static "?QuatVLoadA@aos@physx@@YA?AT__m128@@PEBM@Z";

        // not added to public api
        Vec4V_From_PxVec3_WUndefined :: (v: *PxVec3) -> Vec4V #foreign physxcommon_static "?Vec4V_From_PxVec3_WUndefined@aos@physx@@YA?AT__m128@@AEBV?$PxVec3T@M@2@@Z";
        Vec4V_From_PxVec3_WUndefined :: (v: PxVec3) -> Vec4V #no_context {
            return Vec4V_From_PxVec3_WUndefined(*v);
        }

        // Vec3V
        //(v.x,v.y,v.z,0)
        Vec3V_From_Vec4V :: (v: Vec4V) -> Vec3V #foreign physxcharacterkinematic_static "?Vec3V_From_Vec4V@aos@physx@@YA?AT__m128@@T3@@Z";

        //(v.x,v.y,v.z,undefined) - be very careful with w!=0 because many functions require w==0 for correct operation eg V3Dot, V3Length, V3Cross etc etc.
        Vec3V_From_Vec4V_WUndefined :: (v: Vec4V) -> Vec3V #foreign physx_static "?Vec3V_From_Vec4V_WUndefined@aos@physx@@YA?AT__m128@@T3@@Z";

        // Vec4V
        //(f.x,f.y,f.z,f.w)
        Vec4V_From_Vec3V :: (f: Vec3V) -> Vec4V #foreign physxcommon_static "?Vec4V_From_Vec3V@aos@physx@@YA?AT__m128@@T3@@Z";

        //((PxF32)f.x, (PxF32)f.y, (PxF32)f.z, (PxF32)f.w)
        Vec4V_From_VecI32V :: (a: VecI32V) -> Vec4V #foreign physxcommon_static "?Vec4V_From_VecI32V@aos@physx@@YA?AT__m128@@T3@@Z";

        //(*(reinterpret_cast<PxF32*>(&f.x), (reinterpret_cast<PxF32*>(&f.y), (reinterpret_cast<PxF32*>(&f.z),
        //(reinterpret_cast<PxF32*>(&f.w))
        Vec4V_ReinterpretFrom_VecU32V :: (a: VecU32V) -> Vec4V #foreign physxcommon_static "?Vec4V_ReinterpretFrom_VecU32V@aos@physx@@YA?AT__m128@@T3@@Z";

        //(*(reinterpret_cast<PxF32*>(&f.x), (reinterpret_cast<PxF32*>(&f.y), (reinterpret_cast<PxF32*>(&f.z),
        //(reinterpret_cast<PxF32*>(&f.w))
        Vec4V_ReinterpretFrom_VecI32V :: (a: VecI32V) -> Vec4V #foreign physxcommon_static "?Vec4V_ReinterpretFrom_VecI32V@aos@physx@@YA?AT__m128@@T3@@Z";

        // VecU32V
        //(*(reinterpret_cast<PxU32*>(&f.x), (reinterpret_cast<PxU32*>(&f.y), (reinterpret_cast<PxU32*>(&f.z),
        //(reinterpret_cast<PxU32*>(&f.w))
        VecU32V_ReinterpretFrom_Vec4V :: (a: Vec4V) -> VecU32V #foreign physxcommon_static "?VecU32V_ReinterpretFrom_Vec4V@aos@physx@@YA?AT__m128@@T3@@Z";

        //(b[0], b[1], b[2], b[3])
        VecU32V_From_BoolV :: (b: *BoolV) -> VecU32V #foreign physxcommon_static "?VecU32V_From_BoolV@aos@physx@@YA?AT__m128@@AEBT3@@Z";
        VecU32V_From_BoolV :: (b: BoolV) -> VecU32V #no_context {
            return VecU32V_From_BoolV(*b);
        }

        // VecI32V
        //(*(reinterpret_cast<PxI32*>(&f.x), (reinterpret_cast<PxI32*>(&f.y), (reinterpret_cast<PxI32*>(&f.z),
        //(reinterpret_cast<PxI32*>(&f.w))
        VecI32V_ReinterpretFrom_Vec4V :: (a: Vec4V) -> VecI32V #foreign physxcommon_static "?VecI32V_ReinterpretFrom_Vec4V@aos@physx@@YA?AT__m128@@T3@@Z";

        //((I32)b.x, (I32)b.y, (I32)b.z, (I32)b.w)
        VecI32V_From_BoolV :: (b: *BoolV) -> VecI32V #foreign physxcommon_static "?VecI32V_From_BoolV@aos@physx@@YA?AT__m128@@AEBT3@@Z";
        VecI32V_From_BoolV :: (b: BoolV) -> VecI32V #no_context {
            return VecI32V_From_BoolV(*b);
        }

        // FloatV
        // a.x
        FStore :: (a: FloatV, f: *PxF32) -> void #foreign physxcommon_static "?FStore@aos@physx@@YAXT__m128@@PEIAM@Z";

        // Vec3V
        //(a.x,a.y,a.z)
        V3StoreA :: (a: Vec3V, f: *PxVec3) -> void #foreign physxcommon_static "?V3StoreA@aos@physx@@YAXT__m128@@AEAV?$PxVec3T@M@2@@Z";

        //(a.x,a.y,a.z)
        V3StoreU :: (a: Vec3V, f: *PxVec3) -> void #foreign physxcommon_static "?V3StoreU@aos@physx@@YAXT__m128@@AEAV?$PxVec3T@M@2@@Z";

        // Vec4V
        V4StoreA :: (a: Vec4V, f: *PxF32) -> void #foreign physxcommon_static "?V4StoreA@aos@physx@@YAXT__m128@@PEAM@Z";

        V4StoreU :: (a: Vec4V, f: *PxF32) -> void #foreign physxcharacterkinematic_static "?V4StoreU@aos@physx@@YAXT__m128@@PEAM@Z";

        // BoolV
        BStoreA :: (b: BoolV, f: *PxU32) -> void #foreign physx_static "?BStoreA@aos@physx@@YAXT__m128@@PEAI@Z";

        // VecU32V
        U4StoreA :: (uv: VecU32V, u: *PxU32) -> void #foreign physxcommon_static "?U4StoreA@aos@physx@@YAXT__m128@@PEAI@Z";

        //////////////////////////////////////////////////////////////////
        // Tests that all elements of two 16-byte types are completely equivalent.
        // Use these tests for unit testing and asserts only.
        //////////////////////////////////////////////////////////////////
        vecMathTests :: struct {
            minFError: FloatV;
            maxFError: FloatV;
            minV3Error: Vec3V;
            maxV3Error: Vec3V;
            minV4Error: Vec4V;
            maxV4Error: Vec4V;
        }

        //(0,0,0,0)
        FZero :: () -> FloatV #foreign physxcommon_static "?FZero@aos@physx@@YA?AT__m128@@XZ";

        //(1,1,1,1)
        FOne :: () -> FloatV #foreign physxcommon_static "?FOne@aos@physx@@YA?AT__m128@@XZ";

        //(0.5,0.5,0.5,0.5)
        FHalf :: () -> FloatV #foreign physxcommon_static "?FHalf@aos@physx@@YA?AT__m128@@XZ";

        //(PX_EPS_REAL,PX_EPS_REAL,PX_EPS_REAL,PX_EPS_REAL)
        FEps :: () -> FloatV #foreign physxcommon_static "?FEps@aos@physx@@YA?AT__m128@@XZ";

        //! \cond
        //(PX_MAX_REAL, PX_MAX_REAL, PX_MAX_REAL PX_MAX_REAL)
        FMax :: () -> FloatV #foreign physxcommon_static "?FMax@aos@physx@@YA?AT__m128@@XZ";

        //! \endcond
        //(-PX_MAX_REAL, -PX_MAX_REAL, -PX_MAX_REAL -PX_MAX_REAL)
        FNegMax :: () -> FloatV #foreign physxcommon_static "?FNegMax@aos@physx@@YA?AT__m128@@XZ";

        //-f (per component)
        FNeg :: (f: FloatV) -> FloatV #foreign physxcommon_static "?FNeg@aos@physx@@YA?AT__m128@@T3@@Z";

        // a+b (per component)
        FAdd :: (a: FloatV, b: FloatV) -> FloatV #foreign physxcommon_static "?FAdd@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a-b (per component)
        FSub :: (a: FloatV, b: FloatV) -> FloatV #foreign physxcommon_static "?FSub@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a*b (per component)
        FMul :: (a: FloatV, b: FloatV) -> FloatV #foreign physxcommon_static "?FMul@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a/b (per component)
        FDiv :: (a: FloatV, b: FloatV) -> FloatV #foreign physxcommon_static "?FDiv@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a/b (per component)
        FDivFast :: (a: FloatV, b: FloatV) -> FloatV #foreign physx_static "?FDivFast@aos@physx@@YA?AT__m128@@T3@0@Z";

        // 1.0f/a
        FRecip :: (a: FloatV) -> FloatV #foreign physxcommon_static "?FRecip@aos@physx@@YA?AT__m128@@T3@@Z";

        // 1.0f/sqrt(a)
        FRsqrt :: (a: FloatV) -> FloatV #foreign physxcommon_static "?FRsqrt@aos@physx@@YA?AT__m128@@T3@@Z";

        // 1.0f/sqrt(a)
        FRsqrtFast :: (a: FloatV) -> FloatV #foreign physxcommon_static "?FRsqrtFast@aos@physx@@YA?AT__m128@@T3@@Z";

        // sqrt(a)
        FSqrt :: (a: FloatV) -> FloatV #foreign physxcommon_static "?FSqrt@aos@physx@@YA?AT__m128@@T3@@Z";

        // a*b+c
        FScaleAdd :: (a: FloatV, b: FloatV, c: FloatV) -> FloatV #foreign physxcommon_static "?FScaleAdd@aos@physx@@YA?AT__m128@@T3@00@Z";

        // c-a*b
        FNegScaleSub :: (a: FloatV, b: FloatV, c: FloatV) -> FloatV #foreign physxcommon_static "?FNegScaleSub@aos@physx@@YA?AT__m128@@T3@00@Z";

        // fabs(a)
        FAbs :: (a: FloatV) -> FloatV #foreign physxcommon_static "?FAbs@aos@physx@@YA?AT__m128@@T3@@Z";

        // c ? a : b (per component)
        FSel :: (c: BoolV, a: FloatV, b: FloatV) -> FloatV #foreign physxcommon_static "?FSel@aos@physx@@YA?AT__m128@@T3@00@Z";

        // a>b (per component)
        FIsGrtr :: (a: FloatV, b: FloatV) -> BoolV #foreign physxcommon_static "?FIsGrtr@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a>=b (per component)
        FIsGrtrOrEq :: (a: FloatV, b: FloatV) -> BoolV #foreign physxcommon_static "?FIsGrtrOrEq@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a==b (per component)
        FIsEq :: (a: FloatV, b: FloatV) -> BoolV #foreign physxcommon_static "?FIsEq@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Max(a,b) (per component)
        FMax :: (a: FloatV, b: FloatV) -> FloatV #foreign physxcommon_static "?FMax@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Min(a,b) (per component)
        FMin :: (a: FloatV, b: FloatV) -> FloatV #foreign physxcommon_static "?FMin@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Clamp(a,b) (per component)
        FClamp :: (a: FloatV, minV: FloatV, maxV: FloatV) -> FloatV #foreign physxcommon_static "?FClamp@aos@physx@@YA?AT__m128@@T3@00@Z";

        // a.x>b.x
        FAllGrtr :: (a: FloatV, b: FloatV) -> PxU32 #foreign physxcommon_static "?FAllGrtr@aos@physx@@YAIT__m128@@0@Z";

        // a.x>=b.x
        FAllGrtrOrEq :: (a: FloatV, b: FloatV) -> PxU32 #foreign physxcommon_static "?FAllGrtrOrEq@aos@physx@@YAIT__m128@@0@Z";

        // a.x==b.x
        FAllEq :: (a: FloatV, b: FloatV) -> PxU32 #foreign physxcommon_static "?FAllEq@aos@physx@@YAIT__m128@@0@Z";

        //(f,f,f,f)
        V3Splat :: (f: FloatV) -> Vec3V #foreign physxcommon_static "?V3Splat@aos@physx@@YA?AT__m128@@T3@@Z";

        //(x,y,z)
        V3Merge :: (x: *FloatV, y: *FloatV, z: *FloatV) -> Vec3V #foreign physxcommon_static "?V3Merge@aos@physx@@YA?AT__m128@@AEBT3@00@Z";
        V3Merge :: (x: FloatV, y: FloatV, z: FloatV) -> Vec3V #no_context {
            return V3Merge(*x, *y, *z);
        }

        //(1,0,0,0)
        V3UnitX :: () -> Vec3V #foreign physxcommon_static "?V3UnitX@aos@physx@@YA?AT__m128@@XZ";

        //(0,1,0,0)
        V3UnitY :: () -> Vec3V #foreign physxcommon_static "?V3UnitY@aos@physx@@YA?AT__m128@@XZ";

        //(0,0,1,0)
        V3UnitZ :: () -> Vec3V #foreign physxcommon_static "?V3UnitZ@aos@physx@@YA?AT__m128@@XZ";

        //(f.x,f.x,f.x,f.x)
        V3GetX :: (f: Vec3V) -> FloatV #foreign physxcommon_static "?V3GetX@aos@physx@@YA?AT__m128@@T3@@Z";

        //(f.y,f.y,f.y,f.y)
        V3GetY :: (f: Vec3V) -> FloatV #foreign physxcommon_static "?V3GetY@aos@physx@@YA?AT__m128@@T3@@Z";

        //(f.z,f.z,f.z,f.z)
        V3GetZ :: (f: Vec3V) -> FloatV #foreign physxcommon_static "?V3GetZ@aos@physx@@YA?AT__m128@@T3@@Z";

        //(f,v.y,v.z,v.w)
        V3SetX :: (v: Vec3V, f: FloatV) -> Vec3V #foreign physxcommon_static "?V3SetX@aos@physx@@YA?AT__m128@@T3@0@Z";

        //(v.x,f,v.z,v.w)
        V3SetY :: (v: Vec3V, f: FloatV) -> Vec3V #foreign physxcommon_static "?V3SetY@aos@physx@@YA?AT__m128@@T3@0@Z";

        //(v.x,v.y,f,v.w)
        V3SetZ :: (v: Vec3V, f: FloatV) -> Vec3V #foreign physxcommon_static "?V3SetZ@aos@physx@@YA?AT__m128@@T3@0@Z";

        // return (v.x,v.y,v.z)
        V3ReadXYZ :: (v: *Vec3V) -> *PxVec3 #foreign physxcommon_static "?V3ReadXYZ@aos@physx@@YAAEBV?$PxVec3T@M@2@AEBT__m128@@@Z";
        V3ReadXYZ :: (v: Vec3V) -> *PxVec3 #no_context {
            return V3ReadXYZ(*v);
        }

        //(0,0,0,0)
        V3Zero :: () -> Vec3V #foreign physxcommon_static "?V3Zero@aos@physx@@YA?AT__m128@@XZ";

        //(1,1,1,1)
        V3One :: () -> Vec3V #foreign physxcommon_static "?V3One@aos@physx@@YA?AT__m128@@XZ";

        //(PX_EPS_REAL,PX_EPS_REAL,PX_EPS_REAL,PX_EPS_REAL)
        V3Eps :: () -> Vec3V #foreign physxcommon_static "?V3Eps@aos@physx@@YA?AT__m128@@XZ";

        //-c (per component)
        V3Neg :: (c: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Neg@aos@physx@@YA?AT__m128@@T3@@Z";

        // a+b (per component)
        V3Add :: (a: Vec3V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Add@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a-b (per component)
        V3Sub :: (a: Vec3V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Sub@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a*b (per component)
        V3Scale :: (a: Vec3V, b: FloatV) -> Vec3V #foreign physxcommon_static "?V3Scale@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a*b (per component)
        V3Mul :: (a: Vec3V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Mul@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a/b (per component)
        V3ScaleInv :: (a: Vec3V, b: FloatV) -> Vec3V #foreign physxcommon_static "?V3ScaleInv@aos@physx@@YA?AT__m128@@T3@0@Z";

        // 1.0f/a
        V3Recip :: (a: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Recip@aos@physx@@YA?AT__m128@@T3@@Z";

        // 1.0f/a
        V3RecipFast :: (a: Vec3V) -> Vec3V #foreign physxcommon_static "?V3RecipFast@aos@physx@@YA?AT__m128@@T3@@Z";

        // a*b+c
        V3ScaleAdd :: (a: Vec3V, b: FloatV, c: Vec3V) -> Vec3V #foreign physxcommon_static "?V3ScaleAdd@aos@physx@@YA?AT__m128@@T3@00@Z";

        // c-a*b
        V3NegScaleSub :: (a: Vec3V, b: FloatV, c: Vec3V) -> Vec3V #foreign physxcommon_static "?V3NegScaleSub@aos@physx@@YA?AT__m128@@T3@00@Z";

        // a*b+c
        V3MulAdd :: (a: Vec3V, b: Vec3V, c: Vec3V) -> Vec3V #foreign physxcommon_static "?V3MulAdd@aos@physx@@YA?AT__m128@@T3@00@Z";

        // c-a*b
        V3NegMulSub :: (a: Vec3V, b: Vec3V, c: Vec3V) -> Vec3V #foreign physxcommon_static "?V3NegMulSub@aos@physx@@YA?AT__m128@@T3@00@Z";

        // fabs(a)
        V3Abs :: (a: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Abs@aos@physx@@YA?AT__m128@@T3@@Z";

        // a.b
        // Note: a.w and b.w must have value zero
        V3Dot :: (a: Vec3V, b: Vec3V) -> FloatV #foreign physxcommon_static "?V3Dot@aos@physx@@YA?AT__m128@@T3@0@Z";

        // aXb
        // Note: a.w and b.w must have value zero
        V3Cross :: (a: Vec3V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Cross@aos@physx@@YA?AT__m128@@T3@0@Z";

        // |a.a|^1/2
        // Note: a.w must have value zero
        V3Length :: (a: Vec3V) -> FloatV #foreign physxcommon_static "?V3Length@aos@physx@@YA?AT__m128@@T3@@Z";

        // a.a
        // Note: a.w must have value zero
        V3LengthSq :: (a: Vec3V) -> FloatV #foreign physxcommon_static "?V3LengthSq@aos@physx@@YA?AT__m128@@T3@@Z";

        // a*|a.a|^-1/2
        // Note: a.w must have value zero
        V3Normalize :: (a: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Normalize@aos@physx@@YA?AT__m128@@T3@@Z";

        // a.a>0 ? a*|a.a|^-1/2 : unsafeReturnValue
        // Note: a.w must have value zero
        V3NormalizeSafe :: (a: Vec3V, unsafeReturnValue: Vec3V) -> Vec3V #foreign physxcommon_static "?V3NormalizeSafe@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a.x + a.y + a.z
        // Note: a.w must have value zero
        V3SumElems :: (a: Vec3V) -> FloatV #foreign physx_static "?V3SumElems@aos@physx@@YA?AT__m128@@T3@@Z";

        // c ? a : b (per component)
        V3Sel :: (c: BoolV, a: Vec3V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Sel@aos@physx@@YA?AT__m128@@T3@00@Z";

        // a>b (per component)
        V3IsGrtr :: (a: Vec3V, b: Vec3V) -> BoolV #foreign physxcommon_static "?V3IsGrtr@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a>=b (per component)
        V3IsGrtrOrEq :: (a: Vec3V, b: Vec3V) -> BoolV #foreign physxcommon_static "?V3IsGrtrOrEq@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Max(a,b) (per component)
        V3Max :: (a: Vec3V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Max@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Min(a,b) (per component)
        V3Min :: (a: Vec3V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Min@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Extract the maximum value from a
        // Note: a.w must have value zero
        V3ExtractMax :: (a: Vec3V) -> FloatV #foreign physxcommon_static "?V3ExtractMax@aos@physx@@YA?AT__m128@@T3@@Z";

        // Extract the minimum value from a
        // Note: a.w must have value zero
        V3ExtractMin :: (a: Vec3V) -> FloatV #foreign physxcommon_static "?V3ExtractMin@aos@physx@@YA?AT__m128@@T3@@Z";

        // Clamp(a,b) (per component)
        V3Clamp :: (a: Vec3V, minV: Vec3V, maxV: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Clamp@aos@physx@@YA?AT__m128@@T3@00@Z";

        // Extract the sign for each component
        V3Sign :: (a: Vec3V) -> Vec3V #foreign physxcommon_static "?V3Sign@aos@physx@@YA?AT__m128@@T3@@Z";

        // Test all components.
        // (a.x>b.x && a.y>b.y && a.z>b.z)
        // Note: a.w and b.w must have value zero
        V3AllGrtr :: (a: Vec3V, b: Vec3V) -> PxU32 #foreign physxcommon_static "?V3AllGrtr@aos@physx@@YAIT__m128@@0@Z";

        // (a.x>=b.x && a.y>=b.y && a.z>=b.z)
        // Note: a.w and b.w must have value zero
        V3AllGrtrOrEq :: (a: Vec3V, b: Vec3V) -> PxU32 #foreign physxcommon_static "?V3AllGrtrOrEq@aos@physx@@YAIT__m128@@0@Z";

        // (a.x==b.x && a.y==b.y && a.z==b.z)
        // Note: a.w and b.w must have value zero
        V3AllEq :: (a: Vec3V, b: Vec3V) -> PxU32 #foreign physxcommon_static "?V3AllEq@aos@physx@@YAIT__m128@@0@Z";

        // a.x<min.x || a.y<min.y || a.z<min.z || a.x>max.x || a.y>max.y || a.z>max.z
        // Note: a.w and min.w and max.w must have value zero
        V3OutOfBounds :: (a: Vec3V, min: Vec3V, max: Vec3V) -> PxU32 #foreign physxcommon_static "?V3OutOfBounds@aos@physx@@YAIT__m128@@00@Z";

        // a.x<-bounds.x || a.y<=-bounds.y || a.z<bounds.z || a.x>bounds.x || a.y>bounds.y || a.z>bounds.z
        // Note: a.w and bounds.w must have value zero
        V3OutOfBounds :: (a: Vec3V, bounds: Vec3V) -> PxU32 #foreign physxcommon_static "?V3OutOfBounds@aos@physx@@YAIT__m128@@0@Z";

        //(a.y,a.z,a.x)
        V3PermYZX :: (a: Vec3V) -> Vec3V #foreign physxcommon_static "?V3PermYZX@aos@physx@@YA?AT__m128@@T3@@Z";

        //(a.z, a.x, a.y)
        V3PermZXY :: (a: Vec3V) -> Vec3V #foreign physxcommon_static "?V3PermZXY@aos@physx@@YA?AT__m128@@T3@@Z";

        // Transpose 3 Vec3Vs inplace. Sets the w component to zero
        // [ x0, y0, z0, w0] [ x1, y1, z1, w1]  [ x2, y2, z2, w2]  -> [x0 x1 x2 0] [y0 y1 y2 0] [z0 z1 z2 0]
        V3Transpose :: (col0: *Vec3V, col1: *Vec3V, col2: *Vec3V) -> void #foreign physxcommon_static "?V3Transpose@aos@physx@@YAXAEAT__m128@@00@Z";

        //(f,f,f,f)
        V4Splat :: (f: FloatV) -> Vec4V #foreign physxcommon_static "?V4Splat@aos@physx@@YA?AT__m128@@T3@@Z";

        //(x,y,z,w)
        V4Merge :: (x: *FloatV, y: *FloatV, z: *FloatV, w: *FloatV) -> Vec4V #foreign physxcommon_static "?V4Merge@aos@physx@@YA?AT__m128@@AEBT3@000@Z";
        V4Merge :: (x: FloatV, y: FloatV, z: FloatV, w: FloatV) -> Vec4V #no_context {
            return V4Merge(*x, *y, *z, *w);
        }

        //(a.x, b.x, a.y, b.y)
        V4UnpackXY :: (a: *Vec4V, b: *Vec4V) -> Vec4V #foreign physxcommon_static "?V4UnpackXY@aos@physx@@YA?AT__m128@@AEBT3@0@Z";
        V4UnpackXY :: (a: Vec4V, b: Vec4V) -> Vec4V #no_context {
            return V4UnpackXY(*a, *b);
        }

        //(a.z, b.z, a.w, b.w)
        V4UnpackZW :: (a: *Vec4V, b: *Vec4V) -> Vec4V #foreign physxcommon_static "?V4UnpackZW@aos@physx@@YA?AT__m128@@AEBT3@0@Z";
        V4UnpackZW :: (a: Vec4V, b: Vec4V) -> Vec4V #no_context {
            return V4UnpackZW(*a, *b);
        }

        //(f.x,f.x,f.x,f.x)
        V4GetX :: (f: Vec4V) -> FloatV #foreign physxcharacterkinematic_static "?V4GetX@aos@physx@@YA?AT__m128@@T3@@Z";

        //(f.y,f.y,f.y,f.y)
        V4GetY :: (f: Vec4V) -> FloatV #foreign physxcharacterkinematic_static "?V4GetY@aos@physx@@YA?AT__m128@@T3@@Z";

        //(f.z,f.z,f.z,f.z)
        V4GetZ :: (f: Vec4V) -> FloatV #foreign physxcharacterkinematic_static "?V4GetZ@aos@physx@@YA?AT__m128@@T3@@Z";

        //(f.w,f.w,f.w,f.w)
        V4GetW :: (f: Vec4V) -> FloatV #foreign physxcharacterkinematic_static "?V4GetW@aos@physx@@YA?AT__m128@@T3@@Z";

        //(f,v.y,v.z,v.w)
        V4SetX :: (v: Vec4V, f: FloatV) -> Vec4V #foreign physx_static "?V4SetX@aos@physx@@YA?AT__m128@@T3@0@Z";

        //(v.x,f,v.z,v.w)
        V4SetY :: (v: Vec4V, f: FloatV) -> Vec4V #foreign physxcommon_static "?V4SetY@aos@physx@@YA?AT__m128@@T3@0@Z";

        //(v.x,v.y,f,v.w)
        V4SetZ :: (v: Vec4V, f: FloatV) -> Vec4V #foreign physxcommon_static "?V4SetZ@aos@physx@@YA?AT__m128@@T3@0@Z";

        //(v.x,v.y,v.z,f)
        V4SetW :: (v: Vec4V, f: FloatV) -> Vec4V #foreign physxcommon_static "?V4SetW@aos@physx@@YA?AT__m128@@T3@0@Z";

        //(v.x,v.y,v.z,0)
        V4ClearW :: (v: Vec4V) -> Vec4V #foreign physxcharacterkinematic_static "?V4ClearW@aos@physx@@YA?AT__m128@@T3@@Z";

        //(0,0,0,0)
        V4Zero :: () -> Vec4V #foreign physxcommon_static "?V4Zero@aos@physx@@YA?AT__m128@@XZ";

        //(1,1,1,1)
        V4One :: () -> Vec4V #foreign physxcommon_static "?V4One@aos@physx@@YA?AT__m128@@XZ";

        //(PX_EPS_REAL,PX_EPS_REAL,PX_EPS_REAL,PX_EPS_REAL)
        V4Eps :: () -> Vec4V #foreign physxcommon_static "?V4Eps@aos@physx@@YA?AT__m128@@XZ";

        //-c (per component)
        V4Neg :: (c: Vec4V) -> Vec4V #foreign physxcharacterkinematic_static "?V4Neg@aos@physx@@YA?AT__m128@@T3@@Z";

        // a+b (per component)
        V4Add :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcharacterkinematic_static "?V4Add@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a-b (per component)
        V4Sub :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Sub@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a*b (per component)
        V4Scale :: (a: Vec4V, b: FloatV) -> Vec4V #foreign physxcommon_static "?V4Scale@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a*b (per component)
        V4Mul :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcharacterkinematic_static "?V4Mul@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a/b (per component)
        V4ScaleInv :: (a: Vec4V, b: FloatV) -> Vec4V #foreign physxcommon_static "?V4ScaleInv@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a/b (per component)
        V4Div :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Div@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a/b (per component)
        V4DivFast :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physx_static "?V4DivFast@aos@physx@@YA?AT__m128@@T3@0@Z";

        // 1.0f/a
        V4Recip :: (a: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Recip@aos@physx@@YA?AT__m128@@T3@@Z";

        // 1.0f/a
        V4RecipFast :: (a: Vec4V) -> Vec4V #foreign physxcommon_static "?V4RecipFast@aos@physx@@YA?AT__m128@@T3@@Z";

        // 1.0f/sqrt(a)
        V4Rsqrt :: (a: Vec4V) -> Vec4V #foreign physx_static "?V4Rsqrt@aos@physx@@YA?AT__m128@@T3@@Z";

        // a*b+c
        V4ScaleAdd :: (a: Vec4V, b: FloatV, c: Vec4V) -> Vec4V #foreign physxcommon_static "?V4ScaleAdd@aos@physx@@YA?AT__m128@@T3@00@Z";

        // c-a*b
        V4NegScaleSub :: (a: Vec4V, b: FloatV, c: Vec4V) -> Vec4V #foreign physx_static "?V4NegScaleSub@aos@physx@@YA?AT__m128@@T3@00@Z";

        // a*b+c
        V4MulAdd :: (a: Vec4V, b: Vec4V, c: Vec4V) -> Vec4V #foreign physxcharacterkinematic_static "?V4MulAdd@aos@physx@@YA?AT__m128@@T3@00@Z";

        // c-a*b
        V4NegMulSub :: (a: Vec4V, b: Vec4V, c: Vec4V) -> Vec4V #foreign physxcommon_static "?V4NegMulSub@aos@physx@@YA?AT__m128@@T3@00@Z";

        // fabs(a)
        V4Abs :: (a: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Abs@aos@physx@@YA?AT__m128@@T3@@Z";

        // bitwise a & ~b
        V4Andc :: (a: Vec4V, b: VecU32V) -> Vec4V #foreign physxcommon_static "?V4Andc@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a.b (W is taken into account)
        V4Dot :: (a: Vec4V, b: Vec4V) -> FloatV #foreign physxcommon_static "?V4Dot@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a.b (same computation as V3Dot. W is ignored in input)
        V4Dot3 :: (a: Vec4V, b: Vec4V) -> FloatV #foreign physxcommon_static "?V4Dot3@aos@physx@@YA?AT__m128@@T3@0@Z";

        // aXb (same computation as V3Cross. W is ignored in input and undefined in output)
        V4Cross :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Cross@aos@physx@@YA?AT__m128@@T3@0@Z";

        // c ? a : b (per component)
        V4Sel :: (c: BoolV, a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Sel@aos@physx@@YA?AT__m128@@T3@00@Z";

        // a>b (per component)
        V4IsGrtr :: (a: Vec4V, b: Vec4V) -> BoolV #foreign physxcommon_static "?V4IsGrtr@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a>=b (per component)
        V4IsGrtrOrEq :: (a: Vec4V, b: Vec4V) -> BoolV #foreign physxcommon_static "?V4IsGrtrOrEq@aos@physx@@YA?AT__m128@@T3@0@Z";

        // a==b (per component)
        V4IsEq :: (a: Vec4V, b: Vec4V) -> BoolV #foreign physxcommon_static "?V4IsEq@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Max(a,b) (per component)
        V4Max :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Max@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Min(a,b) (per component)
        V4Min :: (a: Vec4V, b: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Min@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Get the maximum component from a
        V4ExtractMax :: (a: Vec4V) -> FloatV #foreign physxcommon_static "?V4ExtractMax@aos@physx@@YA?AT__m128@@T3@@Z";

        // Clamp(a,b) (per component)
        V4Clamp :: (a: Vec4V, minV: Vec4V, maxV: Vec4V) -> Vec4V #foreign physxcommon_static "?V4Clamp@aos@physx@@YA?AT__m128@@T3@00@Z";

        // return 1 if XYZ components of a are greater than or equal to XYZ components of b. W is ignored.
        V4AllGrtrOrEq3 :: (a: Vec4V, b: Vec4V) -> PxU32 #foreign physxcommon_static "?V4AllGrtrOrEq3@aos@physx@@YAIT__m128@@0@Z";

        // return 1 if all components of a are equal to all components of b
        V4AllEq :: (a: Vec4V, b: Vec4V) -> PxU32 #foreign physxcommon_static "?V4AllEq@aos@physx@@YAIT__m128@@0@Z";

        // return 1 if any XYZ component of a is greater than the corresponding component of b. W is ignored.
        V4AnyGrtr3 :: (a: Vec4V, b: Vec4V) -> PxU32 #foreign physxcommon_static "?V4AnyGrtr3@aos@physx@@YAIT__m128@@0@Z";

        // Permute v into a new vec4v with YXWZ format
        V4PermYXWZ :: (v: Vec4V) -> Vec4V #foreign physxcommon_static "?V4PermYXWZ@aos@physx@@YA?AT__m128@@T3@@Z";

        // Permute v into a new vec4v with XZXZ format
        V4PermXZXZ :: (v: Vec4V) -> Vec4V #foreign physxcommon_static "?V4PermXZXZ@aos@physx@@YA?AT__m128@@T3@@Z";

        // Permute v into a new vec4v with YWYW format
        V4PermYWYW :: (v: Vec4V) -> Vec4V #foreign physxcommon_static "?V4PermYWYW@aos@physx@@YA?AT__m128@@T3@@Z";

        // Permute v into a new vec4v with YZXW format
        V4PermYZXW :: (v: Vec4V) -> Vec4V #foreign physxcommon_static "?V4PermYZXW@aos@physx@@YA?AT__m128@@T3@@Z";

        // a.b
        QuatDot :: (a: QuatV, b: QuatV) -> FloatV #foreign physxcommon_static "?QuatDot@aos@physx@@YA?AT__m128@@T3@0@Z";

        //(-q.x, -q.y, -q.z, q.w)
        QuatConjugate :: (q: QuatV) -> QuatV #foreign physxcommon_static "?QuatConjugate@aos@physx@@YA?AT__m128@@T3@@Z";

        // convert quaternion to matrix 33
        QuatGetMat33V :: (q: *QuatV, column0: *Vec3V, column1: *Vec3V, column2: *Vec3V) -> void #foreign physxcharacterkinematic_static "?QuatGetMat33V@aos@physx@@YAXAEBT__m128@@AEAT3@11@Z";
        QuatGetMat33V :: (q: QuatV, column0: *Vec3V, column1: *Vec3V, column2: *Vec3V) #no_context {
            QuatGetMat33V(*q, column0, column1, column2);
        }

        // brief computes rotation of x-axis
        QuatGetBasisVector0 :: (q: QuatV) -> Vec3V #foreign physxcommon_static "?QuatGetBasisVector0@aos@physx@@YA?AT__m128@@T3@@Z";

        // calculate the rotation vector from q and v
        QuatRotate :: (q: QuatV, v: Vec3V) -> Vec3V #foreign physxcommon_static "?QuatRotate@aos@physx@@YA?AT__m128@@T3@0@Z";

        // calculate the rotation vector from the conjugate quaternion and v
        QuatRotateInv :: (q: QuatV, v: Vec3V) -> Vec3V #foreign physxcommon_static "?QuatRotateInv@aos@physx@@YA?AT__m128@@T3@0@Z";

        // quaternion multiplication
        QuatMul :: (a: QuatV, b: QuatV) -> QuatV #foreign physxcommon_static "?QuatMul@aos@physx@@YA?AT__m128@@T3@0@Z";

        // (x = 0.f, y = 0.f, z = 0.f, w = 1.f)
        QuatIdentity :: () -> QuatV #foreign physxcommon_static "?QuatIdentity@aos@physx@@YA?AT__m128@@XZ";

        // Math operations on 16-byte aligned booleans.
        // x=false	y=false		z=false		w=false
        BFFFF :: () -> BoolV #foreign physxcommon_static "?BFFFF@aos@physx@@YA?AT__m128@@XZ";

        // x=false	y=false		z=true		w=false
        BFFTF :: () -> BoolV #foreign physxcommon_static "?BFFTF@aos@physx@@YA?AT__m128@@XZ";

        // x=false	y=true		z=false		w=false
        BFTFF :: () -> BoolV #foreign physxcommon_static "?BFTFF@aos@physx@@YA?AT__m128@@XZ";

        // x=false	y=true		z=true		w=false
        BFTTF :: () -> BoolV #foreign physxcommon_static "?BFTTF@aos@physx@@YA?AT__m128@@XZ";

        // x=false	y=true		z=true		w=true
        BFTTT :: () -> BoolV #foreign physxcommon_static "?BFTTT@aos@physx@@YA?AT__m128@@XZ";

        // x=true	y=false		z=false		w=false
        BTFFF :: () -> BoolV #foreign physxcommon_static "?BTFFF@aos@physx@@YA?AT__m128@@XZ";

        // x=true	y=false		z=true		w=false
        BTFTF :: () -> BoolV #foreign physxcommon_static "?BTFTF@aos@physx@@YA?AT__m128@@XZ";

        // x=true	y=false		z=true		w=true
        BTFTT :: () -> BoolV #foreign physxcommon_static "?BTFTT@aos@physx@@YA?AT__m128@@XZ";

        // x=true	y=true		z=false		w=false
        BTTFF :: () -> BoolV #foreign physxcommon_static "?BTTFF@aos@physx@@YA?AT__m128@@XZ";

        // x=true	y=true		z=false		w=true
        BTTFT :: () -> BoolV #foreign physxcommon_static "?BTTFT@aos@physx@@YA?AT__m128@@XZ";

        // x=true	y=true		z=true		w=false
        BTTTF :: () -> BoolV #foreign physxcommon_static "?BTTTF@aos@physx@@YA?AT__m128@@XZ";

        // x=true	y=true		z=true		w=true
        BTTTT :: () -> BoolV #foreign physxcommon_static "?BTTTT@aos@physx@@YA?AT__m128@@XZ";

        // get x component
        BGetX :: (f: BoolV) -> BoolV #foreign physxcommon_static "?BGetX@aos@physx@@YA?AT__m128@@T3@@Z";

        // get y component
        BGetY :: (f: BoolV) -> BoolV #foreign physxcommon_static "?BGetY@aos@physx@@YA?AT__m128@@T3@@Z";

        // get z component
        BGetZ :: (f: BoolV) -> BoolV #foreign physxcommon_static "?BGetZ@aos@physx@@YA?AT__m128@@T3@@Z";

        // get w component
        BGetW :: (f: BoolV) -> BoolV #foreign physxcommon_static "?BGetW@aos@physx@@YA?AT__m128@@T3@@Z";

        // component-wise && (AND)
        BAnd :: (a: BoolV, b: BoolV) -> BoolV #foreign physxcommon_static "?BAnd@aos@physx@@YA?AT__m128@@T3@0@Z";

        // component-wise || (OR)
        BOr :: (a: BoolV, b: BoolV) -> BoolV #foreign physxcommon_static "?BOr@aos@physx@@YA?AT__m128@@T3@0@Z";

        // if all three(0, 1, 2) components are true, return true, otherwise return false
        BAllTrue3 :: (a: BoolV) -> BoolV #foreign physxcommon_static "?BAllTrue3@aos@physx@@YA?AT__m128@@T3@@Z";

        // if any three (0, 1, 2) components is true, return true, otherwise return false
        BAnyTrue3 :: (a: BoolV) -> BoolV #foreign physxcommon_static "?BAnyTrue3@aos@physx@@YA?AT__m128@@T3@@Z";

        // Specialized/faster BAllEq function for b==TTTT
        BAllEqTTTT :: (a: BoolV) -> PxU32 #foreign physxcommon_static "?BAllEqTTTT@aos@physx@@YAIT__m128@@@Z";

        // Specialized/faster BAllEq function for b==FFFF
        BAllEqFFFF :: (a: BoolV) -> PxU32 #foreign physxcommon_static "?BAllEqFFFF@aos@physx@@YAIT__m128@@@Z";

        /// Get BoolV as bits set in an PxU32. A bit in the output is set if the element is 'true' in the input.
        /// There is a bit for each element in a, with element 0s value held in bit0, element 1 in bit 1s and so forth.
        /// If nothing is true in the input it will return 0, and if all are true if will return 0xf.
        /// NOTE! That performance of the function varies considerably by platform, thus it is recommended to use
        /// where your algorithm really needs a BoolV in an integer variable.
        BGetBitMask :: (a: BoolV) -> PxU32 #foreign physxcommon_static "?BGetBitMask@aos@physx@@YAIT__m128@@@Z";

        // VecI32V stuff
        VecI32V_Zero :: () -> VecI32V #foreign physxcommon_static "?VecI32V_Zero@aos@physx@@YA?AT__m128@@XZ";

        VecI32V_One :: () -> VecI32V #foreign physxcommon_static "?VecI32V_One@aos@physx@@YA?AT__m128@@XZ";

        VecI32V_Two :: () -> VecI32V #foreign physxcommon_static "?VecI32V_Two@aos@physx@@YA?AT__m128@@XZ";

        VecI32V_IsEq :: (a: *VecI32V, b: *VecI32V) -> BoolV #foreign physx_static "?VecI32V_IsEq@aos@physx@@YA?AT__m128@@AEBT3@0@Z";
        VecI32V_IsEq :: (a: VecI32V, b: VecI32V) -> BoolV #no_context {
            return VecI32V_IsEq(*a, *b);
        }

        V4IsEqU32 :: (a: VecU32V, b: VecU32V) -> BoolV #foreign physx_static "?V4IsEqU32@aos@physx@@YA?AT__m128@@T3@0@Z";

        V4U32or :: (a: VecU32V, b: VecU32V) -> VecU32V #foreign physxcommon_static "?V4U32or@aos@physx@@YA?AT__m128@@T3@0@Z";

        V4U32xor :: (a: VecU32V, b: VecU32V) -> VecU32V #foreign physxcommon_static "?V4U32xor@aos@physx@@YA?AT__m128@@T3@0@Z";

        V4U32and :: (a: VecU32V, b: VecU32V) -> VecU32V #foreign physxcommon_static "?V4U32and@aos@physx@@YA?AT__m128@@T3@0@Z";

        V4U32Andc :: (a: VecU32V, b: VecU32V) -> VecU32V #foreign physxcommon_static "?V4U32Andc@aos@physx@@YA?AT__m128@@T3@0@Z";

        // VecU32 - why does this not return a bool?
        V4IsGrtrV32u :: (a: Vec4V, b: Vec4V) -> VecU32V #foreign physxcommon_static "?V4IsGrtrV32u@aos@physx@@YA?AT__m128@@T3@0@Z";

        // Math operations on 16-byte aligned Mat33s (represents any 3x3 matrix)
        M33Load :: (m: *PxMat33) -> Mat33V #cpp_return_type_is_non_pod #foreign physx_static "?M33Load@aos@physx@@YA?AUMat33V@12@AEBV?$PxMat33T@M@2@@Z";
        M33Load :: (m: PxMat33) -> Mat33V #no_context {
            return M33Load(*m);
        }

        // a*b
        M33MulV3 :: (a: *Mat33V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?M33MulV3@aos@physx@@YA?AT__m128@@AEBUMat33V@12@T3@@Z";
        M33MulV3 :: (a: Mat33V, b: Vec3V) -> Vec3V #no_context {
            return M33MulV3(*a, b);
        }

        // transpose(a) * b
        M33TrnspsMulV3 :: (a: *Mat33V, b: Vec3V) -> Vec3V #foreign physxcommon_static "?M33TrnspsMulV3@aos@physx@@YA?AT__m128@@AEBUMat33V@12@T3@@Z";
        M33TrnspsMulV3 :: (a: Mat33V, b: Vec3V) -> Vec3V #no_context {
            return M33TrnspsMulV3(*a, b);
        }

        // a*b
        M33MulM33 :: (a: *Mat33V, b: *Mat33V) -> Mat33V #cpp_return_type_is_non_pod #foreign physxcommon_static "?M33MulM33@aos@physx@@YA?AUMat33V@12@AEBU312@0@Z";
        M33MulM33 :: (a: Mat33V, b: Mat33V) -> Mat33V #no_context {
            return M33MulM33(*a, *b);
        }

        // a+b
        M33Add :: (a: *Mat33V, b: *Mat33V) -> Mat33V #cpp_return_type_is_non_pod #foreign physx_static "?M33Add@aos@physx@@YA?AUMat33V@12@AEBU312@0@Z";
        M33Add :: (a: Mat33V, b: Mat33V) -> Mat33V #no_context {
            return M33Add(*a, *b);
        }

        //-a
        M33Neg :: (a: *Mat33V) -> Mat33V #cpp_return_type_is_non_pod #foreign physx_static "?M33Neg@aos@physx@@YA?AUMat33V@12@AEBU312@@Z";
        M33Neg :: (a: Mat33V) -> Mat33V #no_context {
            return M33Neg(*a);
        }

        // transpose(a)
        M33Trnsps :: (a: *Mat33V) -> Mat33V #cpp_return_type_is_non_pod #foreign physxcommon_static "?M33Trnsps@aos@physx@@YA?AUMat33V@12@AEBU312@@Z";
        M33Trnsps :: (a: Mat33V) -> Mat33V #no_context {
            return M33Trnsps(*a);
        }

        // create an identity matrix
        M33Identity :: () -> Mat33V #cpp_return_type_is_non_pod #foreign physxcommon_static "?M33Identity@aos@physx@@YA?AUMat33V@12@XZ";

        // create a vec3 to store the diagonal element of the M33
        M33Diagonal :: (unknown0: *Vec3V) -> Mat33V #cpp_return_type_is_non_pod #foreign physxcommon_static "?M33Diagonal@aos@physx@@YA?AUMat33V@12@AEBT__m128@@@Z";
        M33Diagonal :: (unknown0: Vec3V) -> Mat33V #no_context {
            return M33Diagonal(*unknown0);
        }

        // This function returns a Vec4V, where each element is the dot product of one pair of Vec3Vs. On PC, each element in
        // the result should be identical to the results if V3Dot was performed
        // for each pair of Vec3V.
        // However, on other platforms, the result might diverge by some small margin due to differences in FP rounding, e.g. if
        // _mm_dp_ps was used or some other approximate dot product or fused madd operations
        // were used.
        // Where there does not exist a hw-accelerated dot-product operation, this approach should be the fastest way to compute
        // the dot product of 4 vectors.
        V3Dot4 :: (a0: *Vec3V, b0: *Vec3V, a1: *Vec3V, b1: *Vec3V, a2: *Vec3V, b2: *Vec3V, a3: *Vec3V, b3: *Vec3V) -> Vec4V #foreign physxcommon_static "?V3Dot4@aos@physx@@YA?AT__m128@@AEBT3@0000000@Z";
        V3Dot4 :: (a0: Vec3V, b0: Vec3V, a1: Vec3V, b1: Vec3V, a2: Vec3V, b2: Vec3V, a3: Vec3V, b3: Vec3V) -> Vec4V #no_context {
            return V3Dot4(*a0, *b0, *a1, *b1, *a2, *b2, *a3, *b3);
        }

        //(f.x,f.y,f.z,0) - Alternative/faster V3LoadU implementation when it is safe to read "W", i.e. the 32bits after the PxVec3.
        V3LoadU_SafeReadW :: (f: *PxVec3) -> Vec3V #foreign physxcommon_static "?V3LoadU_SafeReadW@aos@physx@@YA?AT__m128@@AEBV?$PxVec3T@M@2@@Z";
        V3LoadU_SafeReadW :: (f: PxVec3) -> Vec3V #no_context {
            return V3LoadU_SafeReadW(*f);
        }

        PX_VECTORF32 :: struct {
            f: [4] float;
        }

        g_PXSinCoefficients0: PX_VECTORF32;

        g_PXSinCoefficients1: PX_VECTORF32;

        g_PXSinCoefficients2: PX_VECTORF32;
        g_PXCosCoefficients0: PX_VECTORF32;

        g_PXCosCoefficients1: PX_VECTORF32;

        g_PXCosCoefficients2: PX_VECTORF32;
        g_PXReciprocalTwoPi: PX_VECTORF32;
        g_PXTwoPi: PX_VECTORF32;

        PxF32 :: struct {
            minus1w: [4] PxF32;
        }

        //////////////////////////////////////////////////////////////////////
        // USED ONLY INTERNALLY
        //////////////////////////////////////////////////////////////////////
        internalWindowsSimd :: struct {
            m128_I2F :: (n: __m128i) -> __m128 #foreign physxcommon_static "?m128_I2F@internalWindowsSimd@aos@physx@@YA?AT__m128@@T__m128i@@@Z";

            m128_F2I :: (n: __m128) -> __m128i #foreign physxcommon_static "?m128_F2I@internalWindowsSimd@aos@physx@@YA?AT__m128i@@T__m128@@@Z";

            BAllTrue4_R :: (a: BoolV) -> PxU32 #foreign physxcommon_static "?BAllTrue4_R@internalWindowsSimd@aos@physx@@YAIT__m128@@@Z";

            BAllTrue3_R :: (a: BoolV) -> PxU32 #foreign physxcommon_static "?BAllTrue3_R@internalWindowsSimd@aos@physx@@YAIT__m128@@@Z";

            BAnyTrue3_R :: (a: BoolV) -> PxU32 #foreign physxcommon_static "?BAnyTrue3_R@internalWindowsSimd@aos@physx@@YAIT__m128@@@Z";

            gMaskXYZ: [4] PxU32;
        }

        Vec4V_From_FloatV :: (f: FloatV) -> Vec4V #foreign physxcommon_static "?Vec4V_From_FloatV@aos@physx@@YA?AT__m128@@T3@@Z";

        Vec3V_From_FloatV :: (f: FloatV) -> Vec3V #foreign physxcommon_static "?Vec3V_From_FloatV@aos@physx@@YA?AT__m128@@T3@@Z";

        Store_From_BoolV :: (b: BoolV, b2: *PxU32) -> void #foreign physx_static "?Store_From_BoolV@aos@physx@@YAXT__m128@@PEAI@Z";

        Mat33V_From_PxMat33 :: (m: *PxMat33) -> Mat33V #cpp_return_type_is_non_pod #foreign physxcommon_static "?Mat33V_From_PxMat33@aos@physx@@YA?AUMat33V@12@AEBV?$PxMat33T@M@2@@Z";
        Mat33V_From_PxMat33 :: (m: PxMat33) -> Mat33V #no_context {
            return Mat33V_From_PxMat33(*m);
        }

        V3PrepareCross :: (a: Vec3V) -> VecCrossV #foreign physxcommon_static "?V3PrepareCross@aos@physx@@YA?AUVecCrossV@12@T__m128@@@Z";

        V3Cross :: (a: *VecCrossV, b: Vec3V) -> Vec3V #foreign physx_static "?V3Cross@aos@physx@@YA?AT__m128@@AEBUVecCrossV@12@T3@@Z";
        V3Cross :: (a: VecCrossV, b: Vec3V) -> Vec3V #no_context {
            return V3Cross(*a, b);
        }

        V3Cross :: (a: Vec3V, b: *VecCrossV) -> Vec3V #foreign physx_static "?V3Cross@aos@physx@@YA?AT__m128@@T3@AEBUVecCrossV@12@@Z";
        V3Cross :: (a: Vec3V, b: VecCrossV) -> Vec3V #no_context {
            return V3Cross(a, *b);
        }

        V3Cross :: (a: *VecCrossV, b: *VecCrossV) -> Vec3V #foreign physxcommon_static "?V3Cross@aos@physx@@YA?AT__m128@@AEBUVecCrossV@12@0@Z";
        V3Cross :: (a: VecCrossV, b: VecCrossV) -> Vec3V #no_context {
            return V3Cross(*a, *b);
        }

        V4Sqrt :: (a: Vec4V) -> Vec4V #foreign physx_static "?V4Sqrt@aos@physx@@YA?AT__m128@@T3@@Z";

        V4Transpose :: (col0: *Vec4V, col1: *Vec4V, col2: *Vec4V, col3: *Vec4V) -> void #foreign physx_static "?V4Transpose@aos@physx@@YAXAEAT__m128@@000@Z";

        BSetX :: (v: BoolV, f: BoolV) -> BoolV #foreign physx_static "?BSetX@aos@physx@@YA?AT__m128@@T3@0@Z";

        BSetY :: (v: BoolV, f: BoolV) -> BoolV #foreign physx_static "?BSetY@aos@physx@@YA?AT__m128@@T3@0@Z";

        BSetZ :: (v: BoolV, f: BoolV) -> BoolV #foreign physx_static "?BSetZ@aos@physx@@YA?AT__m128@@T3@0@Z";

        BSetW :: (v: BoolV, f: BoolV) -> BoolV #foreign physx_static "?BSetW@aos@physx@@YA?AT__m128@@T3@0@Z";

        BAndNot :: (a: BoolV, b: BoolV) -> BoolV #foreign physxcommon_static "?BAndNot@aos@physx@@YA?AT__m128@@T3@0@Z";

        M33Scale :: (a: *Mat33V, b: *FloatV) -> Mat33V #cpp_return_type_is_non_pod #foreign physx_static "?M33Scale@aos@physx@@YA?AUMat33V@12@AEBU312@AEBT__m128@@@Z";
        M33Scale :: (a: Mat33V, b: FloatV) -> Mat33V #no_context {
            return M33Scale(*a, *b);
        }

        I4LoadXYZW :: (x: *PxI32, y: *PxI32, z: *PxI32, w: *PxI32) -> VecI32V #foreign physxcommon_static "?I4LoadXYZW@aos@physx@@YA?AT__m128@@AEBH000@Z";
        I4LoadXYZW :: (x: PxI32, y: PxI32, z: PxI32, w: PxI32) -> VecI32V #no_context {
            return I4LoadXYZW(*x, *y, *z, *w);
        }

        VecI32V_Sel :: (c: BoolV, a: *VecI32V, b: *VecI32V) -> VecI32V #foreign physxcommon_static "?VecI32V_Sel@aos@physx@@YA?AT__m128@@T3@AEBT3@1@Z";
        VecI32V_Sel :: (c: BoolV, a: VecI32V, b: VecI32V) -> VecI32V #no_context {
            return VecI32V_Sel(c, *a, *b);
        }

        VecI32V_LeftShift :: (a: *VecI32V, count: PxU32) -> VecI32V #foreign physxcommon_static "?VecI32V_LeftShift@aos@physx@@YA?AT__m128@@AEBT3@I@Z";
        VecI32V_LeftShift :: (a: VecI32V, count: PxU32) -> VecI32V #no_context {
            return VecI32V_LeftShift(*a, count);
        }

        VecI32V_RightShift :: (a: *VecI32V, count: PxU32) -> VecI32V #foreign physxcommon_static "?VecI32V_RightShift@aos@physx@@YA?AT__m128@@AEBT3@I@Z";
        VecI32V_RightShift :: (a: VecI32V, count: PxU32) -> VecI32V #no_context {
            return VecI32V_RightShift(*a, count);
        }

        VecI32V_And :: (a: *VecI32V, b: *VecI32V) -> VecI32V #foreign physxcommon_static "?VecI32V_And@aos@physx@@YA?AT__m128@@AEBT3@0@Z";
        VecI32V_And :: (a: VecI32V, b: VecI32V) -> VecI32V #no_context {
            return VecI32V_And(*a, *b);
        }

        PxI32_From_VecI32V :: (a: *VecI32V, i: *PxI32) -> void #foreign physxcommon_static "?PxI32_From_VecI32V@aos@physx@@YAXAEBT__m128@@PEAH@Z";
        PxI32_From_VecI32V :: (a: VecI32V, i: *PxI32) #no_context {
            PxI32_From_VecI32V(*a, i);
        }

        V4U32StoreAligned :: (val: VecU32V, address: *VecU32V) -> void #foreign physxcommon_static "?V4U32StoreAligned@aos@physx@@YAXT__m128@@PEAT3@@Z";

        QuatTransform :: (q: QuatV, p: Vec3V, v: Vec3V) -> Vec3V #foreign physxcommon_static "?QuatTransform@aos@physx@@YA?AT__m128@@T3@00@Z";

        PxTransformV :: struct {
            q: QuatV;
            p: Vec3V;

            Constructor :: (this: *PxTransformV, transform: *PxTransform) -> void #cpp_method #foreign physxcommon_static "??0PxTransformV@aos@physx@@QEAA@AEBV?$PxTransformT@M@2@@Z";
            Constructor :: (this: *PxTransformV, transform: PxTransform) #no_context {
                Constructor(this, *transform);
            }

            Constructor :: (this: *PxTransformV, p0: *Vec3V, q0: *QuatV) -> void #cpp_method #foreign physxcommon_static "??0PxTransformV@aos@physx@@QEAA@AEBT__m128@@0@Z";
            Constructor :: (this: *PxTransformV, p0: Vec3V, q0: QuatV) #no_context {
                Constructor(this, *p0, *q0);
            }

            invalidate :: (this: *PxTransformV) -> void #cpp_method #foreign physxcommon_static "?invalidate@PxTransformV@aos@physx@@QEAAXXZ";

            transform :: (this: *PxTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?transform@PxTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            transform :: (this: *PxTransformV, input: Vec3V) -> Vec3V #no_context {
                return transform(this, *input);
            }

            transformInv :: (this: *PxTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?transformInv@PxTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            transformInv :: (this: *PxTransformV, input: Vec3V) -> Vec3V #no_context {
                return transformInv(this, *input);
            }

            rotate :: (this: *PxTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?rotate@PxTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            rotate :: (this: *PxTransformV, input: Vec3V) -> Vec3V #no_context {
                return rotate(this, *input);
            }

            rotateInv :: (this: *PxTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?rotateInv@PxTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            rotateInv :: (this: *PxTransformV, input: Vec3V) -> Vec3V #no_context {
                return rotateInv(this, *input);
            }

            //! Transform transform from parent (returns compound transform: first src, then this->inverse)
            transformInv :: (this: *PxTransformV, src: *PxTransformV) -> PxTransformV #cpp_method #cpp_return_type_is_non_pod #foreign physxcommon_static "?transformInv@PxTransformV@aos@physx@@QEBA?AV123@AEBV123@@Z";
            transformInv :: (this: *PxTransformV, src: PxTransformV) -> PxTransformV #no_context {
                return transformInv(this, *src);
            }
        }

        loadTransformA :: (transform: *PxTransform) -> PxTransformV #cpp_return_type_is_non_pod #foreign physxcommon_static "?loadTransformA@aos@physx@@YA?AVPxTransformV@12@AEBV?$PxTransformT@M@2@@Z";
        loadTransformA :: (transform: PxTransform) -> PxTransformV #no_context {
            return loadTransformA(*transform);
        }

        loadTransformU :: (transform: *PxTransform) -> PxTransformV #cpp_return_type_is_non_pod #foreign physxcommon_static "?loadTransformU@aos@physx@@YA?AVPxTransformV@12@AEBV?$PxTransformT@M@2@@Z";
        loadTransformU :: (transform: PxTransform) -> PxTransformV #no_context {
            return loadTransformU(*transform);
        }

        PxMatTransformV :: struct {
            rot: Mat33V;
            p:   Vec3V;

            Constructor :: (this: *PxMatTransformV) -> void #cpp_method #foreign physxcommon_static "??0PxMatTransformV@aos@physx@@QEAA@XZ";

            Constructor :: (this: *PxMatTransformV, _p: *Vec3V, _rot: *Mat33V) -> void #cpp_method #foreign physxcommon_static "??0PxMatTransformV@aos@physx@@QEAA@AEBT__m128@@AEBUMat33V@12@@Z";
            Constructor :: (this: *PxMatTransformV, _p: Vec3V, _rot: Mat33V) #no_context {
                Constructor(this, *_p, *_rot);
            }

            Constructor :: (this: *PxMatTransformV, other: *PxTransformV) -> void #cpp_method #foreign physxcommon_static "??0PxMatTransformV@aos@physx@@QEAA@AEBVPxTransformV@12@@Z";
            Constructor :: (this: *PxMatTransformV, other: PxTransformV) #no_context {
                Constructor(this, *other);
            }

            getCol0 :: (this: *PxMatTransformV) -> Vec3V #cpp_method #foreign physxcommon_static "?getCol0@PxMatTransformV@aos@physx@@QEBA?AT__m128@@XZ";

            getCol1 :: (this: *PxMatTransformV) -> Vec3V #cpp_method #foreign physxcommon_static "?getCol1@PxMatTransformV@aos@physx@@QEBA?AT__m128@@XZ";

            getCol2 :: (this: *PxMatTransformV) -> Vec3V #cpp_method #foreign physxcommon_static "?getCol2@PxMatTransformV@aos@physx@@QEBA?AT__m128@@XZ";

            transform :: (this: *PxMatTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?transform@PxMatTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            transform :: (this: *PxMatTransformV, input: Vec3V) -> Vec3V #no_context {
                return transform(this, *input);
            }

            transformInv :: (this: *PxMatTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?transformInv@PxMatTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            transformInv :: (this: *PxMatTransformV, input: Vec3V) -> Vec3V #no_context {
                return transformInv(this, *input);
            }

            rotate :: (this: *PxMatTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?rotate@PxMatTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            rotate :: (this: *PxMatTransformV, input: Vec3V) -> Vec3V #no_context {
                return rotate(this, *input);
            }

            rotateInv :: (this: *PxMatTransformV, input: *Vec3V) -> Vec3V #cpp_method #foreign physxcommon_static "?rotateInv@PxMatTransformV@aos@physx@@QEBA?AT__m128@@AEBT4@@Z";
            rotateInv :: (this: *PxMatTransformV, input: Vec3V) -> Vec3V #no_context {
                return rotateInv(this, *input);
            }

            transformInv :: (this: *PxMatTransformV, src: *PxMatTransformV) -> PxMatTransformV #cpp_method #cpp_return_type_is_non_pod #foreign physxcommon_static "?transformInv@PxMatTransformV@aos@physx@@QEBA?AV123@AEBV123@@Z";
            transformInv :: (this: *PxMatTransformV, src: PxMatTransformV) -> PxMatTransformV #no_context {
                return transformInv(this, *src);
            }
        }
    }

    PxStridedData :: struct {
        /*
        \brief The offset in bytes between consecutive samples in the data.
        
        <b>Default:</b> 0
        */
        stride: PxU32;
        data:   *void;

        Constructor :: (this: *PxStridedData) -> void #cpp_method #foreign physxcommon_static "??0PxStridedData@physx@@QEAA@XZ";
    }

    PxTypedStridedData :: struct(TDataType: Type) {
        stride: PxU32;
        data:   *TDataType;
    }

    PxBoundedData :: struct {
        #as using pxstrideddata: PxStridedData;

        count: PxU32;
        Constructor :: (this: *PxBoundedData) -> void #cpp_method #foreign physxcommon_static "??0PxBoundedData@physx@@QEAA@XZ";
    }

    PxPadding :: struct(TNumBytes: PxU8) {
        mPadding: [PxU8] PxU8;
    }

    PxFixedSizeLookupTable :: struct(NB_ELEMENTS: PxU32) {
        mDataPairs:   [PxReal] PxReal;
        mNbDataPairs: PxU32;
        mPad:         [3] PxU32;
    }

    PxTriangleID :: PxU32;
    PxMaterialTableIndex :: PxU16;
    PxFEMMaterialTableIndex :: PxU16;

    /*
    \brief Default color values used for debug rendering.
    */
    PxDebugColor :: struct {
        Enum :: enum s32 {
            BLACK     :: -16777216;
            RED       :: -65536;
            GREEN     :: -16711936;
            BLUE      :: -16776961;
            YELLOW    :: -256;
            MAGENTA   :: -65281;
            CYAN      :: -16711681;
            WHITE     :: -1;
            GREY      :: -8355712;
            DARKRED   :: -7864320;
            DARKGREEN :: -16742400;
            DARKBLUE  :: -16777080;

            eARGB_BLACK     :: BLACK;
            eARGB_RED       :: RED;
            eARGB_GREEN     :: GREEN;
            eARGB_BLUE      :: BLUE;
            eARGB_YELLOW    :: YELLOW;
            eARGB_MAGENTA   :: MAGENTA;
            eARGB_CYAN      :: CYAN;
            eARGB_WHITE     :: WHITE;
            eARGB_GREY      :: GREY;
            eARGB_DARKRED   :: DARKRED;
            eARGB_DARKGREEN :: DARKGREEN;
            eARGB_DARKBLUE  :: DARKBLUE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Used to store a single point and colour for debug rendering.
    */
    PxDebugPoint :: struct {
        Constructor :: (this: *PxDebugPoint, p: *PxVec3, c: *PxU32) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxDebugPoint@physx@@QEAA@AEBV?$PxVec3T@M@1@AEBI@Z";
        Constructor :: (this: *PxDebugPoint, p: PxVec3, c: PxU32) #no_context {
            Constructor(this, *p, *c);
        }

        pos:   PxVec3;
        color: PxU32;
    }

    /*
    \brief Used to store a single line and colour for debug rendering.
    */
    PxDebugLine :: struct {
        Constructor :: (this: *PxDebugLine, p0: *PxVec3, p1: *PxVec3, c: *PxU32) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxDebugLine@physx@@QEAA@AEBV?$PxVec3T@M@1@0AEBI@Z";
        Constructor :: (this: *PxDebugLine, p0: PxVec3, p1: PxVec3, c: PxU32) #no_context {
            Constructor(this, *p0, *p1, *c);
        }

        pos0:   PxVec3;
        color0: PxU32;
        pos1:   PxVec3;
        color1: PxU32;
    }

    /*
    \brief Used to store a single triangle and colour for debug rendering.
    */
    PxDebugTriangle :: struct {
        Constructor :: (this: *PxDebugTriangle, p0: *PxVec3, p1: *PxVec3, p2: *PxVec3, c: *PxU32) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxDebugTriangle@physx@@QEAA@AEBV?$PxVec3T@M@1@00AEBI@Z";
        Constructor :: (this: *PxDebugTriangle, p0: PxVec3, p1: PxVec3, p2: PxVec3, c: PxU32) #no_context {
            Constructor(this, *p0, *p1, *p2, *c);
        }

        pos0:   PxVec3;
        color0: PxU32;
        pos1:   PxVec3;
        color1: PxU32;
        pos2:   PxVec3;
        color2: PxU32;
    }

    /*
    \brief Used to store a text for debug rendering. Doesn't own 'string' array.
    */
    PxDebugText :: struct {
        position: PxVec3;
        size:     PxReal;
        color:    PxU32;
        _string:  *u8;
    }

    /*
    \brief Interface for points, lines, triangles, and text buffer.
    */
    PxRenderBuffer :: struct {
        vtable: *PxRenderBuffer_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxRenderBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxRenderBuffer@physx@@UEAA@XZ";
    }
    PxRenderBuffer_VTable :: struct #type_info_none {
        Destructor: (this: *PxRenderBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        getNbPoints: (this: *PxRenderBuffer) -> PxU32 #cpp_method;
        getPoints: (this: *PxRenderBuffer) -> *PxDebugPoint #cpp_method;
        addPoint: (this: *PxRenderBuffer, point: *PxDebugPoint) -> void #cpp_method;

        getNbLines: (this: *PxRenderBuffer) -> PxU32 #cpp_method;
        getLines: (this: *PxRenderBuffer) -> *PxDebugLine #cpp_method;
        addLine: (this: *PxRenderBuffer, line: *PxDebugLine) -> void #cpp_method;
        reserveLines: (this: *PxRenderBuffer, nbLines: PxU32) -> *PxDebugLine #cpp_method;
        reservePoints: (this: *PxRenderBuffer, nbLines: PxU32) -> *PxDebugPoint #cpp_method;

        getNbTriangles: (this: *PxRenderBuffer) -> PxU32 #cpp_method;
        getTriangles: (this: *PxRenderBuffer) -> *PxDebugTriangle #cpp_method;
        addTriangle: (this: *PxRenderBuffer, triangle: *PxDebugTriangle) -> void #cpp_method;

        append: (this: *PxRenderBuffer, other: *PxRenderBuffer) -> void #cpp_method;
        clear: (this: *PxRenderBuffer) -> void #cpp_method;

        shift: (this: *PxRenderBuffer, delta: *PxVec3) -> void #cpp_method;

        empty: (this: *PxRenderBuffer) -> bool #cpp_method;
    }

    PxRenderBuffer_Destructor :: inline (this: *PxRenderBuffer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxRenderBuffer_getNbPoints :: inline (this: *PxRenderBuffer) -> PxU32 { return this.vtable.getNbPoints(this); }
    PxRenderBuffer_getPoints :: inline (this: *PxRenderBuffer) -> *PxDebugPoint { return this.vtable.getPoints(this); }
    PxRenderBuffer_addPoint :: inline (this: *PxRenderBuffer, point: *PxDebugPoint) { this.vtable.addPoint(this, point); }

    PxRenderBuffer_getNbLines :: inline (this: *PxRenderBuffer) -> PxU32 { return this.vtable.getNbLines(this); }
    PxRenderBuffer_getLines :: inline (this: *PxRenderBuffer) -> *PxDebugLine { return this.vtable.getLines(this); }
    PxRenderBuffer_addLine :: inline (this: *PxRenderBuffer, line: *PxDebugLine) { this.vtable.addLine(this, line); }
    PxRenderBuffer_reserveLines :: inline (this: *PxRenderBuffer, nbLines: PxU32) -> *PxDebugLine { return this.vtable.reserveLines(this, nbLines); }
    PxRenderBuffer_reservePoints :: inline (this: *PxRenderBuffer, nbLines: PxU32) -> *PxDebugPoint { return this.vtable.reservePoints(this, nbLines); }

    PxRenderBuffer_getNbTriangles :: inline (this: *PxRenderBuffer) -> PxU32 { return this.vtable.getNbTriangles(this); }
    PxRenderBuffer_getTriangles :: inline (this: *PxRenderBuffer) -> *PxDebugTriangle { return this.vtable.getTriangles(this); }
    PxRenderBuffer_addTriangle :: inline (this: *PxRenderBuffer, triangle: *PxDebugTriangle) { this.vtable.addTriangle(this, triangle); }

    PxRenderBuffer_append :: inline (this: *PxRenderBuffer, other: *PxRenderBuffer) { this.vtable.append(this, other); }
    PxRenderBuffer_clear :: inline (this: *PxRenderBuffer) { this.vtable.clear(this); }

    PxRenderBuffer_shift :: inline (this: *PxRenderBuffer, delta: *PxVec3) { this.vtable.shift(this, delta); }

    PxRenderBuffer_empty :: inline (this: *PxRenderBuffer) -> bool { return this.vtable.empty(this); }

    vtable :: (obj: *PxRenderBuffer) -> *PxRenderBuffer_VTable { return obj.vtable; }


    PxType :: PxU16;

    //! ID type for PxBase objects in a PxCollection
    PxSerialObjectId :: PxU64;

    /*
    \brief Callback class used to process PxBase objects.
    
    \see PxSerializer::requires
    */
    PxProcessPxBaseCallback :: struct {
        vtable: *PxProcessPxBaseCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxProcessPxBaseCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxProcessPxBaseCallback@physx@@UEAA@XZ";
    }
    PxProcessPxBaseCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxProcessPxBaseCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        process: (this: *PxProcessPxBaseCallback, unknown0: *PxBase) -> void #cpp_method;
    }

    PxProcessPxBaseCallback_Destructor :: inline (this: *PxProcessPxBaseCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }
    PxProcessPxBaseCallback_process :: inline (this: *PxProcessPxBaseCallback, unknown0: *PxBase) { this.vtable.process(this, unknown0); }

    vtable :: (obj: *PxProcessPxBaseCallback) -> *PxProcessPxBaseCallback_VTable { return obj.vtable; }


    /*
    \brief Binary serialization context class.
    
    This class is used to register reference values and write object
    and object extra data during serialization.
    It is mainly used by the serialization framework. Except for custom
    serializable types, users should not have to worry about it.
    
    \see PxDeserializationContext
    */
    PxSerializationContext :: struct {
        vtable: *PxSerializationContext_VTable;
    }
    PxSerializationContext_VTable :: struct #type_info_none {
        registerReference: (this: *PxSerializationContext, base: *PxBase, kind: PxU32, reference: u64) -> void #cpp_method;

        getCollection: (this: *PxSerializationContext) -> *PxCollection #cpp_method;

        writeData: (this: *PxSerializationContext, data: *void, size: PxU32) -> void #cpp_method;

        alignData: (this: *PxSerializationContext, alignment: PxU32 = 16) -> void #cpp_method;

        writeName: (this: *PxSerializationContext, name: *u8) -> void #cpp_method;

        Destructor: (this: *PxSerializationContext, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSerializationContext_registerReference :: inline (this: *PxSerializationContext, base: *PxBase, kind: PxU32, reference: u64) { this.vtable.registerReference(this, base, kind, reference); }

    PxSerializationContext_getCollection :: inline (this: *PxSerializationContext) -> *PxCollection { return this.vtable.getCollection(this); }

    PxSerializationContext_writeData :: inline (this: *PxSerializationContext, data: *void, size: PxU32) { this.vtable.writeData(this, data, size); }

    PxSerializationContext_alignData :: inline (this: *PxSerializationContext, alignment: PxU32 = 16) { this.vtable.alignData(this, alignment); }

    PxSerializationContext_writeName :: inline (this: *PxSerializationContext, name: *u8) { this.vtable.writeName(this, name); }

    PxSerializationContext_Destructor :: inline (this: *PxSerializationContext, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSerializationContext) -> *PxSerializationContext_VTable { return obj.vtable; }


    /*
    \brief Binary deserialization context class.
    
    This class is used to resolve references and access extra data during deserialization.
    It is mainly used by the serialization framework. Except for custom
    serializable types, users should not have to worry about it.
    
    \see PxSerializationContext
    */
    PxDeserializationContext :: struct {
        vtable: *PxDeserializationContext_VTable;
        /*
        \brief Helper function to read a name from the extra data during deserialization.
        
        This function is assumed to be called within the implementation of PxSerializer::createObject.
        
        \see PxSerializationContext::writeName
        */
        readName :: (this: *PxDeserializationContext, name: **u8) -> void #cpp_method #foreign physx_static "?readName@PxDeserializationContext@physx@@QEAAXAEAPEBD@Z";

        /*
        \brief Function to align the extra data stream to a power of 2 alignment
        
        This function is assumed to be called within the implementation of PxSerializer::createObject.
        
        \see PxSerializationContext::alignData, PxSerializer::createObject
        */
        alignExtraData :: (this: *PxDeserializationContext, alignment: PxU32 = 16) -> void #cpp_method #foreign physxcommon_static "?alignExtraData@PxDeserializationContext@physx@@QEAAXI@Z";

        mExtraDataAddress: *PxU8;
    }
    PxDeserializationContext_VTable :: struct #type_info_none {
        resolveReference: (this: *PxDeserializationContext, kind: PxU32, reference: u64) -> *PxBase #cpp_method;

        Destructor: (this: *PxDeserializationContext, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxDeserializationContext_resolveReference :: inline (this: *PxDeserializationContext, kind: PxU32, reference: u64) -> *PxBase { return this.vtable.resolveReference(this, kind, reference); }

    PxDeserializationContext_Destructor :: inline (this: *PxDeserializationContext, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxDeserializationContext) -> *PxDeserializationContext_VTable { return obj.vtable; }


    /*
    \brief Callback type for exporting binary meta data for a serializable type.
    \deprecated Binary conversion and binary meta data are deprecated.
    
    \see PxSerializationRegistry::registerBinaryMetaDataCallback
    
    \param stream	Stream to store binary meta data.
    */
    PxBinaryMetaDataCallback :: #type (stream: *PxOutputStream) -> void #c_call;

    /*
    \brief Class serving as a registry for XML (RepX) and binary serializable types.
    
    In order to serialize and deserialize objects the application needs
    to maintain an instance of this class. It can be created with
    PxSerialization::createSerializationRegistry() and released with
    PxSerializationRegistry::release().
    
    \see PxSerialization::createSerializationRegistry
    */
    PxSerializationRegistry :: struct {
        vtable: *PxSerializationRegistry_VTable;
    }
    PxSerializationRegistry_VTable :: struct #type_info_none {
        registerSerializer: (this: *PxSerializationRegistry, type: PxType, serializer: *PxSerializer) -> void #cpp_method;

        unregisterSerializer: (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer #cpp_method;

        registerBinaryMetaDataCallback: (this: *PxSerializationRegistry, callback: PxBinaryMetaDataCallback) -> void #cpp_method;

        getSerializer: (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer #cpp_method;

        registerRepXSerializer: (this: *PxSerializationRegistry, type: PxType, serializer: *PxRepXSerializer) -> void #cpp_method;

        unregisterRepXSerializer: (this: *PxSerializationRegistry, type: PxType) -> *PxRepXSerializer #cpp_method;

        getRepXSerializer: (this: *PxSerializationRegistry, typeName: *u8) -> *PxRepXSerializer #cpp_method;

        release: (this: *PxSerializationRegistry) -> void #cpp_method;

        Destructor: (this: *PxSerializationRegistry, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSerializationRegistry_registerSerializer :: inline (this: *PxSerializationRegistry, type: PxType, serializer: *PxSerializer) { this.vtable.registerSerializer(this, type, serializer); }

    PxSerializationRegistry_unregisterSerializer :: inline (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer { return this.vtable.unregisterSerializer(this, type); }

    PxSerializationRegistry_registerBinaryMetaDataCallback :: inline (this: *PxSerializationRegistry, callback: PxBinaryMetaDataCallback) { this.vtable.registerBinaryMetaDataCallback(this, callback); }

    PxSerializationRegistry_getSerializer :: inline (this: *PxSerializationRegistry, type: PxType) -> *PxSerializer { return this.vtable.getSerializer(this, type); }

    PxSerializationRegistry_registerRepXSerializer :: inline (this: *PxSerializationRegistry, type: PxType, serializer: *PxRepXSerializer) { this.vtable.registerRepXSerializer(this, type, serializer); }

    PxSerializationRegistry_unregisterRepXSerializer :: inline (this: *PxSerializationRegistry, type: PxType) -> *PxRepXSerializer { return this.vtable.unregisterRepXSerializer(this, type); }

    PxSerializationRegistry_getRepXSerializer :: inline (this: *PxSerializationRegistry, typeName: *u8) -> *PxRepXSerializer { return this.vtable.getRepXSerializer(this, typeName); }

    PxSerializationRegistry_release :: inline (this: *PxSerializationRegistry) { this.vtable.release(this); }

    PxSerializationRegistry_Destructor :: inline (this: *PxSerializationRegistry, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSerializationRegistry) -> *PxSerializationRegistry_VTable { return obj.vtable; }


    /*
    \brief Collection class for serialization.
    
    A collection is a set of PxBase objects. PxBase objects can be added to the collection
    regardless of other objects they depend on. Objects may be named using PxSerialObjectId values in order
    to resolve dependencies between objects of different collections.
    
    Serialization and deserialization only work through collections.
    
    A scene is typically serialized using the following steps:
    
    -# create a serialization registry
    -# create a collection for scene objects
    -# complete the scene objects (adds all dependent objects, e.g. meshes)
    -# serialize collection
    -# release collection
    -# release serialization registry
    
    For example the code may look like this:
    
    \code
    PxPhysics* physics; // The physics
    PxScene* scene;		// The physics scene
    SerialStream s;		// The user-defined stream doing the actual write to disk
    
    PxSerializationRegistry* registry = PxSerialization::createSerializationRegistry(*physics);	// step 1)
    PxCollection* collection = PxSerialization::createCollection(*scene);						// step 2)
    PxSerialization::complete(*collection, *registry);											// step 3)
    PxSerialization::serializeCollectionToBinary(s, *collection, *registry);					// step 4)
    collection->release();																		// step 5)
    registry->release();																		// step 6)
    \endcode
    
    A scene is typically deserialized using the following steps:
    
    -# load a serialized collection into memory
    -# create a serialization registry
    -# create a collection by passing the serialized memory block
    -# add collected objects to scene
    -# release collection
    -# release serialization registry
    
    For example the code may look like this:
    
    \code
    PxPhysics* physics; // The physics
    PxScene* scene;		// The physics scene
    void* memory128;	// a 128-byte aligned buffer previously loaded from disk by the user	- step 1)
    
    PxSerializationRegistry* registry = PxSerialization::createSerializationRegistry(*physics);		// step 2)
    PxCollection* collection = PxSerialization::createCollectionFromBinary(memory128, *registry);	// step 3)
    scene->addCollection(*collection);																// step 4)
    collection->release();																			// step 5)
    registry->release();																			// step 6)
    \endcode
    
    \see PxBase, PxCreateCollection()
    */
    PxCollection :: struct {
        vtable: *PxCollection_VTable;
        Constructor :: (this: *PxCollection) -> void #cpp_method #foreign physxcommon_static "??0PxCollection@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxCollection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxCollection@physx@@MEAA@XZ";
    }
    PxCollection_VTable :: struct #type_info_none {
        add: (this: *PxCollection, collection: *PxCollection) -> void #cpp_method;

        add_1: (this: *PxCollection, object: /*reference*/ *PxBase, id: PxSerialObjectId = 0) -> void #cpp_method;

        _remove: (this: *PxCollection, collection: *PxCollection) -> void #cpp_method;

        _remove_1: (this: *PxCollection, object: /*reference*/ *PxBase) -> void #cpp_method;

        contains: (this: *PxCollection, object: *PxBase) -> bool #cpp_method;

        addId: (this: *PxCollection, object: *PxBase, id: PxSerialObjectId) -> void #cpp_method;

        removeId: (this: *PxCollection, id: PxSerialObjectId) -> void #cpp_method;

        getNbObjects: (this: *PxCollection) -> PxU32 #cpp_method;

        getObject: (this: *PxCollection, index: PxU32) -> *PxBase #cpp_method;

        getObjects: (this: *PxCollection, userBuffer: **PxBase, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        find: (this: *PxCollection, id: PxSerialObjectId) -> *PxBase #cpp_method;

        getNbIds: (this: *PxCollection) -> PxU32 #cpp_method;

        getIds: (this: *PxCollection, userBuffer: *PxSerialObjectId, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getId: (this: *PxCollection, object: *PxBase) -> PxSerialObjectId #cpp_method;

        release: (this: *PxCollection) -> void #cpp_method;

        Destructor: (this: *PxCollection, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCollection_add :: inline (this: *PxCollection, collection: /*reference*/ *PxCollection) { this.vtable.add(this, collection); }

    PxCollection_add_1 :: inline (this: *PxCollection, object: /*reference*/ *PxBase, id: PxSerialObjectId = 0) { this.vtable.add_1(this, object, id); }

    PxCollection__remove :: inline (this: *PxCollection, collection: /*reference*/ *PxCollection) { this.vtable._remove(this, collection); }

    PxCollection__remove_1 :: inline (this: *PxCollection, object: /*reference*/ *PxBase) { this.vtable._remove_1(this, object); }

    PxCollection_contains :: inline (this: *PxCollection, object: *PxBase) -> bool { return this.vtable.contains(this, object); }

    PxCollection_addId :: inline (this: *PxCollection, object: *PxBase, id: PxSerialObjectId) { this.vtable.addId(this, object, id); }

    PxCollection_removeId :: inline (this: *PxCollection, id: PxSerialObjectId) { this.vtable.removeId(this, id); }

    PxCollection_getNbObjects :: inline (this: *PxCollection) -> PxU32 { return this.vtable.getNbObjects(this); }

    PxCollection_getObject :: inline (this: *PxCollection, index: PxU32) -> *PxBase { return this.vtable.getObject(this, index); }

    PxCollection_getObjects :: inline (this: *PxCollection, userBuffer: **PxBase, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getObjects(this, userBuffer, bufferSize, startIndex); }

    PxCollection_find :: inline (this: *PxCollection, id: PxSerialObjectId) -> *PxBase { return this.vtable.find(this, id); }

    PxCollection_getNbIds :: inline (this: *PxCollection) -> PxU32 { return this.vtable.getNbIds(this); }

    PxCollection_getIds :: inline (this: *PxCollection, userBuffer: *PxSerialObjectId, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getIds(this, userBuffer, bufferSize, startIndex); }

    PxCollection_getId :: inline (this: *PxCollection, object: *PxBase) -> PxSerialObjectId { return this.vtable.getId(this, object); }

    PxCollection_release :: inline (this: *PxCollection) { this.vtable.release(this); }

    PxCollection_Destructor :: inline (this: *PxCollection, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCollection) -> *PxCollection_VTable { return obj.vtable; }


    /*
    \brief an enumeration of concrete classes inheriting from PxBase
    
    Enumeration space is reserved for future PhysX core types, PhysXExtensions,
    PhysXVehicle and Custom application types.
    
    \see PxBase, PxTypeInfo
    */
    PxConcreteType :: struct {
        Enum :: enum s32 {
            UNDEFINED                             :: 0;

            HEIGHTFIELD                           :: 1;
            CONVEX_MESH                           :: 2;
            TRIANGLE_MESH_BVH33                   :: 3;
            TRIANGLE_MESH_BVH34                   :: 4;
            TETRAHEDRON_MESH                      :: 5;
            SOFTBODY_MESH                         :: 6;

            RIGID_DYNAMIC                         :: 7;
            RIGID_STATIC                          :: 8;
            SHAPE                                 :: 9;
            MATERIAL                              :: 10;
            SOFTBODY_MATERIAL                     :: 11;
            CLOTH_MATERIAL                        :: 12;
            PBD_MATERIAL                          :: 13;
            CONSTRAINT                            :: 14;
            AGGREGATE                             :: 15;
            ARTICULATION_REDUCED_COORDINATE       :: 16;
            ARTICULATION_LINK                     :: 17;
            ARTICULATION_JOINT_REDUCED_COORDINATE :: 18;
            ARTICULATION_SPATIAL_TENDON           :: 19;
            ARTICULATION_FIXED_TENDON             :: 20;
            ARTICULATION_ATTACHMENT               :: 21;
            ARTICULATION_TENDON_JOINT             :: 22;
            ARTICULATION_MIMIC_JOINT              :: 23;
            PRUNING_STRUCTURE                     :: 24;
            BVH                                   :: 25;
            SOFT_BODY                             :: 26;
            SOFT_BODY_STATE                       :: 27;
            PBD_PARTICLESYSTEM                    :: 28;
            FEM_CLOTH                             :: 29;
            HAIR_SYSTEM                           :: 30;
            PARTICLE_BUFFER                       :: 31;
            PARTICLE_DIFFUSE_BUFFER               :: 32;
            PARTICLE_CLOTH_BUFFER                 :: 33;
            PARTICLE_RIGID_BUFFER                 :: 34;

            PHYSX_CORE_COUNT                      :: 35;
            FIRST_PHYSX_EXTENSION                 :: 256;
            FIRST_VEHICLE_EXTENSION               :: 512;
            FIRST_USER_EXTENSION                  :: 1024;

            eUNDEFINED                             :: UNDEFINED;

            eHEIGHTFIELD                           :: HEIGHTFIELD;
            eCONVEX_MESH                           :: CONVEX_MESH;
            eTRIANGLE_MESH_BVH33                   :: TRIANGLE_MESH_BVH33;
            eTRIANGLE_MESH_BVH34                   :: TRIANGLE_MESH_BVH34;
            eTETRAHEDRON_MESH                      :: TETRAHEDRON_MESH;
            eSOFTBODY_MESH                         :: SOFTBODY_MESH;

            eRIGID_DYNAMIC                         :: RIGID_DYNAMIC;
            eRIGID_STATIC                          :: RIGID_STATIC;
            eSHAPE                                 :: SHAPE;
            eMATERIAL                              :: MATERIAL;
            eSOFTBODY_MATERIAL                     :: SOFTBODY_MATERIAL;
            eCLOTH_MATERIAL                        :: CLOTH_MATERIAL;
            ePBD_MATERIAL                          :: PBD_MATERIAL;
            eCONSTRAINT                            :: CONSTRAINT;
            eAGGREGATE                             :: AGGREGATE;
            eARTICULATION_REDUCED_COORDINATE       :: ARTICULATION_REDUCED_COORDINATE;
            eARTICULATION_LINK                     :: ARTICULATION_LINK;
            eARTICULATION_JOINT_REDUCED_COORDINATE :: ARTICULATION_JOINT_REDUCED_COORDINATE;
            eARTICULATION_SPATIAL_TENDON           :: ARTICULATION_SPATIAL_TENDON;
            eARTICULATION_FIXED_TENDON             :: ARTICULATION_FIXED_TENDON;
            eARTICULATION_ATTACHMENT               :: ARTICULATION_ATTACHMENT;
            eARTICULATION_TENDON_JOINT             :: ARTICULATION_TENDON_JOINT;
            eARTICULATION_MIMIC_JOINT              :: ARTICULATION_MIMIC_JOINT;
            ePRUNING_STRUCTURE                     :: PRUNING_STRUCTURE;
            eBVH                                   :: BVH;
            eSOFT_BODY                             :: SOFT_BODY;
            eSOFT_BODY_STATE                       :: SOFT_BODY_STATE;
            ePBD_PARTICLESYSTEM                    :: PBD_PARTICLESYSTEM;
            eFEM_CLOTH                             :: FEM_CLOTH;
            eHAIR_SYSTEM                           :: HAIR_SYSTEM;
            ePARTICLE_BUFFER                       :: PARTICLE_BUFFER;
            ePARTICLE_DIFFUSE_BUFFER               :: PARTICLE_DIFFUSE_BUFFER;
            ePARTICLE_CLOTH_BUFFER                 :: PARTICLE_CLOTH_BUFFER;
            ePARTICLE_RIGID_BUFFER                 :: PARTICLE_RIGID_BUFFER;

            ePHYSX_CORE_COUNT                      :: PHYSX_CORE_COUNT;
            eFIRST_PHYSX_EXTENSION                 :: FIRST_PHYSX_EXTENSION;
            eFIRST_VEHICLE_EXTENSION               :: FIRST_VEHICLE_EXTENSION;
            eFIRST_USER_EXTENSION                  :: FIRST_USER_EXTENSION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief a structure containing per-type information for types inheriting from PxBase
    
    \see PxBase, PxConcreteType
    */
    PxTypeInfo :: struct(T: Type) {}

    PxFEMClothMaterial :: struct {}

    PxFEMCloth :: struct {}
    PxHairSystem :: struct {}

    /*
    \brief Flags for PxBase.
    */
    PxBaseFlag :: struct {
        Enum :: enum s32 {
            OWNS_MEMORY   :: 1;
            IS_RELEASABLE :: 2;

            eOWNS_MEMORY   :: OWNS_MEMORY;
            eIS_RELEASABLE :: IS_RELEASABLE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxBaseFlags :: PxFlags(PxBaseFlag.Enum, PxU16);
    operator| :: (a: PxBaseFlag.Enum, b: PxBaseFlag.Enum) -> PxFlags(PxBaseFlag.Enum, PxU16) #foreign physxcommon_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@0@W4Enum@PxBaseFlag@0@0@Z";
    operator~ :: (a: PxBaseFlag.Enum) -> PxFlags(PxBaseFlag.Enum, PxU16) #foreign physxcommon_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@0@W4Enum@PxBaseFlag@0@@Z";

    /*
    \brief Base class for objects that can be members of a PxCollection.
    
    All PxBase sub-classes can be serialized.
    
    \see PxCollection
    */
    PxBase :: struct {
        vtable: *PxBase_VTable;
        /*
        \brief	Returns concrete type of object.
        \return	PxConcreteType::Enum of serialized object
        
        \see PxConcreteType
        */
        getConcreteType :: (this: *PxBase) -> PxType #cpp_method #foreign physxcharacterkinematic_static "?getConcreteType@PxBase@physx@@QEBAGXZ";

        /*
        \brief Set PxBaseFlag
        
        \param[in] flag The flag to be set
        \param[in] value The flags new value
        */
        setBaseFlag :: (this: *PxBase, flag: PxBaseFlag.Enum, value: bool) -> void #cpp_method #foreign physxcommon_static "?setBaseFlag@PxBase@physx@@QEAAXW4Enum@PxBaseFlag@2@_N@Z";

        /*
        \brief Returns PxBaseFlags
        
        \return	PxBaseFlags
        
        \see PxBaseFlags
        */
        getBaseFlags :: (this: *PxBase) -> PxBaseFlags #cpp_method #foreign physxcommon_static "?getBaseFlags@PxBase@physx@@QEBA?AV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@2@XZ";

        /*
        \brief Constructor setting concrete type and base flags.
        */
        Constructor :: (this: *PxBase, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxBase@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        /*
        \brief Deserialization constructor setting base flags.
        */
        Constructor :: (this: *PxBase, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxBase@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        mConcreteType:    PxType; // concrete type identifier - see PxConcreteType.
        mBaseFlags:       PxBaseFlags; // internal flags
        mBuiltInRefCount: PxU32;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief Whether the object is subordinate.
        
        A class is subordinate, if it can only be instantiated in the context of another class.
        
        \return	Whether the class is subordinate
        
        \see PxSerialization::isSerializable
        */
        virtual_isReleasable :: (this: *PxBase) -> bool #cpp_method #foreign physxcommon_static "?isReleasable@PxBase@physx@@UEBA_NXZ";

        /*
        \brief Destructor.
        */
        virtual_Destructor :: (this: *PxBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxBase@physx@@MEAA@XZ";

        /*
        \brief Returns whether a given type name matches with the type of this instance
        */
        virtual_isKindOf :: (this: *PxBase, superClass: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxBase@physx@@MEBA_NPEBD@Z";
    }
    PxBase_VTable :: struct #type_info_none {
        release: (this: *PxBase) -> void #cpp_method;

        getConcreteTypeName: (this: *PxBase) -> *u8 #cpp_method;

        isReleasable: (this: *PxBase) -> bool #cpp_method;

        Destructor: (this: *PxBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        isKindOf: (this: *PxBase, superClass: *u8) -> bool #cpp_method;
    }

    PxBase_release :: inline (this: *PxBase) { this.vtable.release(this); }

    PxBase_getConcreteTypeName :: inline (this: *PxBase) -> *u8 { return this.vtable.getConcreteTypeName(this); }

    PxBase_isReleasable :: inline (this: *PxBase) -> bool { return this.vtable.isReleasable(this); }

    PxBase_Destructor :: inline (this: *PxBase, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBase_isKindOf :: inline (this: *PxBase, superClass: *u8) -> bool { return this.vtable.isKindOf(this, superClass); }

    vtable :: (obj: *PxBase) -> *PxBase_VTable { return obj.vtable; }


    /*
    \brief Base class for ref-counted objects.
    */
    PxRefCounted :: struct {
        #as using pxbase: PxBase;

        Constructor :: (this: *PxRefCounted, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxRefCounted@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxRefCounted, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxRefCounted@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxrefcounted_vtable: *PxRefCounted_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_onRefCountZero :: (this: *PxRefCounted) -> void #cpp_method #foreign physxcommon_static "?onRefCountZero@PxRefCounted@physx@@MEAAXXZ";

        virtual_Destructor :: (this: *PxRefCounted, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxRefCounted@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxRefCounted, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxRefCounted@physx@@MEBA_NPEBD@Z";
    }
    PxRefCounted_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getReferenceCount: (this: *PxRefCounted) -> PxU32 #cpp_method;

        acquireReference: (this: *PxRefCounted) -> void #cpp_method;

        onRefCountZero: (this: *PxRefCounted) -> void #cpp_method;
    }

    PxRefCounted_getReferenceCount :: inline (this: *PxRefCounted) -> PxU32 { return this.pxrefcounted_vtable.getReferenceCount(this); }

    PxRefCounted_acquireReference :: inline (this: *PxRefCounted) { this.pxrefcounted_vtable.acquireReference(this); }

    PxRefCounted_onRefCountZero :: inline (this: *PxRefCounted) { this.pxrefcounted_vtable.onRefCountZero(this); }

    vtable :: (obj: *PxRefCounted) -> *PxRefCounted_VTable { return obj.pxrefcounted_vtable; }


    /*
    \brief Class to define the scale at which simulation runs. Most simulation tolerances are
    calculated in terms of the values here.
    
    \note if you change the simulation scale, you will probably also wish to change the scene's
    default value of gravity, and stable simulation will probably require changes to the scene's
    bounceThreshold also.
    */
    PxTolerancesScale :: struct {
        /*
        \brief The approximate size of objects in the simulation.
        
        For simulating roughly human-sized in metric units, 1 is a good choice.
        If simulation is done in centimetres, use 100 instead. This is used to
        estimate certain length-related tolerances.
        */
        length: PxReal;

        /*
        \brief The typical magnitude of velocities of objects in simulation. This is used to estimate
        whether a contact should be treated as bouncing or resting based on its impact velocity,
        and a kinetic energy threshold below which the simulation may put objects to sleep.
        
        For normal physical environments, a good choice is the approximate speed of an object falling
        under gravity for one second.
        */
        speed:  PxReal;

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid (returns always true).
        */
        isValid :: (this: *PxTolerancesScale) -> bool #cpp_method #foreign physx_static "?isValid@PxTolerancesScale@physx@@QEBA_NXZ";
    }

    /*
    *	\brief a table to manage strings.  Strings allocated through this object are expected to be owned by this object.
    */
    PxStringTable :: struct {
        vtable: *PxStringTable_VTable;
    }
    PxStringTable_VTable :: struct #type_info_none {
        Destructor: (this: *PxStringTable, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        allocateStr: (this: *PxStringTable, inSrc: *u8) -> *u8 #cpp_method;

        release: (this: *PxStringTable) -> void #cpp_method;
    }

    PxStringTable_Destructor :: inline (this: *PxStringTable, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxStringTable_allocateStr :: inline (this: *PxStringTable, inSrc: *u8) -> *u8 { return this.vtable.allocateStr(this, inSrc); }

    PxStringTable_release :: inline (this: *PxStringTable) { this.vtable.release(this); }

    vtable :: (obj: *PxStringTable) -> *PxStringTable_VTable { return obj.vtable; }


    /*
    \brief Serialization interface class.
    
    PxSerializer is used to extend serializable PxBase classes with serialization functionality. The
    interface is structured such that per-class adapter instances can be used as opposed to per-object
    adapter instances, avoiding per object allocations. Hence the methods take a reference to PxBase as a parameter.
    
    The PxSerializer interface needs to be implemented for binary or RepX serialization to work on custom
    types. If only RepX serialization is needed, some methods can be left empty, as they are only needed
    for binary serialization.
    
    A default implementation is available as a template adapter (PxSerializerDefaultAdapter).
    
    \see PxSerializerDefaultAdapter, PX_NEW_SERIALIZER_ADAPTER, PxSerializationRegistry::registerSerializer
    */
    PxSerializer :: struct {
        vtable: *PxSerializer_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        //\}
        //
        virtual_Destructor :: (this: *PxSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxSerializer@physx@@UEAA@XZ";
    }
    PxSerializer_VTable :: struct #type_info_none {
        getConcreteTypeName: (this: *PxSerializer) -> *u8 #cpp_method;

        requiresObjects: (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxProcessPxBaseCallback) -> void #cpp_method;

        isSubordinate: (this: *PxSerializer) -> bool #cpp_method;

        exportExtraData: (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) -> void #cpp_method;

        exportData: (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) -> void #cpp_method;

        registerReferences: (this: *PxSerializer, obj: *PxBase, s: *PxSerializationContext) -> void #cpp_method;

        getClassSize: (this: *PxSerializer) -> u64 #cpp_method;

        createObject: (this: *PxSerializer, address: **PxU8, _context: *PxDeserializationContext) -> *PxBase #cpp_method;

        Destructor: (this: *PxSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSerializer_getConcreteTypeName :: inline (this: *PxSerializer) -> *u8 { return this.vtable.getConcreteTypeName(this); }

    PxSerializer_requiresObjects :: inline (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxProcessPxBaseCallback) { this.vtable.requiresObjects(this, unknown0, unknown1); }

    PxSerializer_isSubordinate :: inline (this: *PxSerializer) -> bool { return this.vtable.isSubordinate(this); }

    PxSerializer_exportExtraData :: inline (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) { this.vtable.exportExtraData(this, unknown0, unknown1); }

    PxSerializer_exportData :: inline (this: *PxSerializer, unknown0: *PxBase, unknown1: *PxSerializationContext) { this.vtable.exportData(this, unknown0, unknown1); }

    PxSerializer_registerReferences :: inline (this: *PxSerializer, obj: *PxBase, s: *PxSerializationContext) { this.vtable.registerReferences(this, obj, s); }

    PxSerializer_getClassSize :: inline (this: *PxSerializer) -> u64 { return this.vtable.getClassSize(this); }

    PxSerializer_createObject :: inline (this: *PxSerializer, address: **PxU8, _context: *PxDeserializationContext) -> *PxBase { return this.vtable.createObject(this, address, _context); }

    PxSerializer_Destructor :: inline (this: *PxSerializer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSerializer) -> *PxSerializer_VTable { return obj.vtable; }


    /*
    \brief Default PxSerializer implementation.
    */
    PxSerializerDefaultAdapter :: struct(T: Type) {
        #as pxserializer: PxSerializer; // jai: no "using" to avoid name-clashes

        //\}
        //
        mTypeName: *u8;
    }

    /*
    \brief Flags used to configure binary meta data entries, typically set through PX_DEF_BIN_METADATA defines.
    
    \see PxMetaDataEntry
    */
    PxMetaDataFlag :: struct {
        Enum :: enum s32 {
            CLASS              :: 1;
            VIRTUAL            :: 2;
            TYPEDEF            :: 4;
            PTR                :: 8;
            HANDLE             :: 16;
            EXTRA_DATA         :: 32;
            EXTRA_ITEM         :: 64;
            EXTRA_ITEMS        :: 128;
            EXTRA_NAME         :: 256;
            UNION              :: 512;
            PADDING            :: 1024;
            ALIGNMENT          :: 2048;
            COUNT_MASK_MSB     :: 4096;
            COUNT_SKIP_IF_ONE  :: 8192;
            CONTROL_FLIP       :: 16384;
            CONTROL_MASK       :: 32768;
            CONTROL_MASK_RANGE :: 255;
            FORCE_DWORD        :: 2147483647;

            eCLASS              :: CLASS;
            eVIRTUAL            :: VIRTUAL;
            eTYPEDEF            :: TYPEDEF;
            ePTR                :: PTR;
            eHANDLE             :: HANDLE;
            eEXTRA_DATA         :: EXTRA_DATA;
            eEXTRA_ITEM         :: EXTRA_ITEM;
            eEXTRA_ITEMS        :: EXTRA_ITEMS;
            eEXTRA_NAME         :: EXTRA_NAME;
            eUNION              :: UNION;
            ePADDING            :: PADDING;
            eALIGNMENT          :: ALIGNMENT;
            eCOUNT_MASK_MSB     :: COUNT_MASK_MSB;
            eCOUNT_SKIP_IF_ONE  :: COUNT_SKIP_IF_ONE;
            eCONTROL_FLIP       :: CONTROL_FLIP;
            eCONTROL_MASK       :: CONTROL_MASK;
            eCONTROL_MASK_RANGE :: CONTROL_MASK_RANGE;
            eFORCE_DWORD        :: FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Struct to store meta data definitions.
    
    Note: The individual fields have different meaning depending on the meta data entry configuration.
    */
    PxMetaDataEntry :: struct {
        type:       *u8; //!< Field type (bool, byte, quaternion, etc)
        name:       *u8; //!< Field name (appears exactly as in the source file)
        offset:     PxU32; //!< Offset from the start of the class (ie from "this", field is located at "this"+Offset)
        size:       PxU32; //!< sizeof(Type)
        count:      PxU32; //!< Number of items of type Type (0 for dynamic sizes)
        offsetSize: PxU32; //!< Offset of dynamic size param, for dynamic arrays
        flags:      PxU32; //!< Field parameters
        alignment:  PxU32; //!< Explicit alignment 
    }

    /*
    \brief Callback interface that permits TriangleMesh, Heightfield, ConvexMesh or BVH to be used
    directly without the need to store the cooking results into a stream.
    
    Using this is advised only if real-time cooking is required; using "offline" cooking and
    streams is otherwise preferred.
    
    The default PxInsertionCallback implementations must be used. The PxPhysics
    default callback can be obtained using the PxPhysics::getPhysicsInsertionCallback().
    The PxCooking default callback can be obtained using the PxCooking::getStandaloneInsertionCallback().
    
    \see PxCooking PxPhysics
    */
    PxInsertionCallback :: struct {
        vtable: *PxInsertionCallback_VTable;
        Constructor :: (this: *PxInsertionCallback) -> void #cpp_method #foreign physxcommon_static "??0PxInsertionCallback@physx@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxInsertionCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxInsertionCallback@physx@@MEAA@XZ";
    }
    PxInsertionCallback_VTable :: struct #type_info_none {
        buildObjectFromData: (this: *PxInsertionCallback, type: PxConcreteType.Enum, data: *void) -> *PxBase #cpp_method;

        Destructor: (this: *PxInsertionCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxInsertionCallback_buildObjectFromData :: inline (this: *PxInsertionCallback, type: PxConcreteType.Enum, data: *void) -> *PxBase { return this.vtable.buildObjectFromData(this, type, data); }

    PxInsertionCallback_Destructor :: inline (this: *PxInsertionCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxInsertionCallback) -> *PxInsertionCallback_VTable { return obj.vtable; }


    PxTaskID :: u32;

    /*
    \brief Identifies the type of each heavyweight PxTask object
    
    \note This enum type is only used by PxTask objects, PxLightCpuTasks do not use this enum.
    
    \see PxTask
    \see PxLightCpuTask
    */
    PxTaskType :: struct {
        /*
        * \brief Identifies the type of each heavyweight PxTask object
        */
        Enum :: enum s32 {
            CPU         :: 0;
            NOT_PRESENT :: 1;
            COMPLETED   :: 2;

            eCPU         :: CPU;
            eNOT_PRESENT :: NOT_PRESENT;
            eCOMPLETED   :: COMPLETED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief The PxTaskManager interface
    
    A PxTaskManager instance holds references to user-provided dispatcher objects. When tasks are
    submitted the PxTaskManager routes them to the appropriate dispatcher and handles task profiling if enabled.
    Users should not implement the PxTaskManager interface, the SDK creates its own concrete PxTaskManager object
    per-scene which users can configure by passing dispatcher objects into the PxSceneDesc.
    
    \see PxCpuDispatcher
    
    */
    PxTaskManager :: struct {
        vtable: *PxTaskManager_VTable;
        /*
        \brief Construct a new PxTaskManager instance with the given [optional] dispatchers
        */
        createTaskManager :: (errorCallback: *PxErrorCallback, unknown0: *PxCpuDispatcher = null) -> *PxTaskManager #foreign physx_static "?createTaskManager@PxTaskManager@physx@@SAPEAV12@AEAVPxErrorCallback@2@PEAVPxCpuDispatcher@2@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxTaskManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxTaskManager@physx@@MEAA@XZ";
    }
    PxTaskManager_VTable :: struct #type_info_none {
        setCpuDispatcher: (this: *PxTaskManager, ref: *PxCpuDispatcher) -> void #cpp_method;

        getCpuDispatcher: (this: *PxTaskManager) -> *PxCpuDispatcher #cpp_method;

        resetDependencies: (this: *PxTaskManager) -> void #cpp_method;

        startSimulation: (this: *PxTaskManager) -> void #cpp_method;

        stopSimulation: (this: *PxTaskManager) -> void #cpp_method;

        taskCompleted: (this: *PxTaskManager, task: *PxTask) -> void #cpp_method;

        getNamedTask: (this: *PxTaskManager, name: *u8) -> PxTaskID #cpp_method;

        submitNamedTask: (this: *PxTaskManager, task: *PxTask, name: *u8, type: PxTaskType.Enum = .CPU) -> PxTaskID #cpp_method;

        submitUnnamedTask: (this: *PxTaskManager, task: *PxTask, type: PxTaskType.Enum = .CPU) -> PxTaskID #cpp_method;

        getTaskFromID: (this: *PxTaskManager, id: PxTaskID) -> *PxTask #cpp_method;

        release: (this: *PxTaskManager) -> void #cpp_method;

        Destructor: (this: *PxTaskManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        finishBefore: (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) -> void #cpp_method;
        startAfter: (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) -> void #cpp_method;

        addReference: (this: *PxTaskManager, unknown0: *PxLightCpuTask) -> void #cpp_method;

        addReference_1: (this: *PxTaskManager, taskID: PxTaskID) -> void #cpp_method;

        decrReference: (this: *PxTaskManager, unknown0: *PxLightCpuTask) -> void #cpp_method;

        decrReference_1: (this: *PxTaskManager, taskID: PxTaskID) -> void #cpp_method;
        getReference: (this: *PxTaskManager, taskID: PxTaskID) -> s32 #cpp_method;
    }

    PxTaskManager_setCpuDispatcher :: inline (this: *PxTaskManager, ref: *PxCpuDispatcher) { this.vtable.setCpuDispatcher(this, ref); }

    PxTaskManager_getCpuDispatcher :: inline (this: *PxTaskManager) -> *PxCpuDispatcher { return this.vtable.getCpuDispatcher(this); }

    PxTaskManager_resetDependencies :: inline (this: *PxTaskManager) { this.vtable.resetDependencies(this); }

    PxTaskManager_startSimulation :: inline (this: *PxTaskManager) { this.vtable.startSimulation(this); }

    PxTaskManager_stopSimulation :: inline (this: *PxTaskManager) { this.vtable.stopSimulation(this); }

    PxTaskManager_taskCompleted :: inline (this: *PxTaskManager, task: *PxTask) { this.vtable.taskCompleted(this, task); }

    PxTaskManager_getNamedTask :: inline (this: *PxTaskManager, name: *u8) -> PxTaskID { return this.vtable.getNamedTask(this, name); }

    PxTaskManager_submitNamedTask :: inline (this: *PxTaskManager, task: *PxTask, name: *u8, type: PxTaskType.Enum = .CPU) -> PxTaskID { return this.vtable.submitNamedTask(this, task, name, type); }

    PxTaskManager_submitUnnamedTask :: inline (this: *PxTaskManager, task: *PxTask, type: PxTaskType.Enum = .CPU) -> PxTaskID { return this.vtable.submitUnnamedTask(this, task, type); }

    PxTaskManager_getTaskFromID :: inline (this: *PxTaskManager, id: PxTaskID) -> *PxTask { return this.vtable.getTaskFromID(this, id); }

    PxTaskManager_release :: inline (this: *PxTaskManager) { this.vtable.release(this); }

    PxTaskManager_Destructor :: inline (this: *PxTaskManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxTaskManager_finishBefore :: inline (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) { this.vtable.finishBefore(this, task, taskID); }
    PxTaskManager_startAfter :: inline (this: *PxTaskManager, task: *PxTask, taskID: PxTaskID) { this.vtable.startAfter(this, task, taskID); }

    PxTaskManager_addReference :: inline (this: *PxTaskManager, unknown0: /*reference*/ *PxLightCpuTask) { this.vtable.addReference(this, unknown0); }

    PxTaskManager_addReference_1 :: inline (this: *PxTaskManager, taskID: PxTaskID) { this.vtable.addReference_1(this, taskID); }

    PxTaskManager_decrReference :: inline (this: *PxTaskManager, unknown0: /*reference*/ *PxLightCpuTask) { this.vtable.decrReference(this, unknown0); }

    PxTaskManager_decrReference_1 :: inline (this: *PxTaskManager, taskID: PxTaskID) { this.vtable.decrReference_1(this, taskID); }
    PxTaskManager_getReference :: inline (this: *PxTaskManager, taskID: PxTaskID) -> s32 { return this.vtable.getReference(this, taskID); }

    vtable :: (obj: *PxTaskManager) -> *PxTaskManager_VTable { return obj.vtable; }


    /*
    \brief A CpuDispatcher is responsible for scheduling the execution of tasks passed to it by the SDK.
    
    A typical implementation would for example use a thread pool with the dispatcher
    pushing tasks onto worker thread queues or a global queue.
    
    \see PxBaseTask
    \see PxTask
    \see PxTaskManager
    */
    PxCpuDispatcher :: struct {
        vtable: *PxCpuDispatcher_VTable;
    }
    PxCpuDispatcher_VTable :: struct #type_info_none {
        submitTask: (this: *PxCpuDispatcher, task: *PxBaseTask) -> void #cpp_method;

        getWorkerCount: (this: *PxCpuDispatcher) -> u32 #cpp_method;

        Destructor: (this: *PxCpuDispatcher, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCpuDispatcher_submitTask :: inline (this: *PxCpuDispatcher, task: *PxBaseTask) { this.vtable.submitTask(this, task); }

    PxCpuDispatcher_getWorkerCount :: inline (this: *PxCpuDispatcher) -> u32 { return this.vtable.getWorkerCount(this); }

    PxCpuDispatcher_Destructor :: inline (this: *PxCpuDispatcher, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCpuDispatcher) -> *PxCpuDispatcher_VTable { return obj.vtable; }


    /*
    * \brief Base class of all task types
    *
    * PxBaseTask defines a runnable reference counted task with built-in profiling.
    */
    PxBaseTask :: struct {
        vtable: *PxBaseTask_VTable;
        Constructor :: (this: *PxBaseTask) -> void #cpp_method #foreign physx_static "??0PxBaseTask@physx@@QEAA@XZ";

        /*
        * \brief Return PxTaskManager to which this task was submitted
        *
        * Note, can return NULL if task was not submitted, or has been
        * completed.
        */
        getTaskManager :: (this: *PxBaseTask) -> *PxTaskManager #cpp_method #foreign physx_static "?getTaskManager@PxBaseTask@physx@@QEBAPEAVPxTaskManager@2@XZ";

        setContextId :: (this: *PxBaseTask, id: PxU64) -> void #cpp_method #foreign physx_static "?setContextId@PxBaseTask@physx@@QEAAX_K@Z";

        mContextID: PxU64; //!< Context ID for profiler interface
        mTm:        *PxTaskManager; //!< Owning PxTaskManager instance

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxBaseTask, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxBaseTask@physx@@UEAA@XZ";
    }
    PxBaseTask_VTable :: struct #type_info_none {
        Destructor: (this: *PxBaseTask, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        run: (this: *PxBaseTask) -> void #cpp_method;

        getName: (this: *PxBaseTask) -> *u8 #cpp_method;

        addReference: (this: *PxBaseTask) -> void #cpp_method;

        removeReference: (this: *PxBaseTask) -> void #cpp_method;

        getReference: (this: *PxBaseTask) -> s32 #cpp_method;

        release: (this: *PxBaseTask) -> void #cpp_method;
    }

    PxBaseTask_Destructor :: inline (this: *PxBaseTask, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBaseTask_run :: inline (this: *PxBaseTask) { this.vtable.run(this); }

    PxBaseTask_getName :: inline (this: *PxBaseTask) -> *u8 { return this.vtable.getName(this); }

    PxBaseTask_addReference :: inline (this: *PxBaseTask) { this.vtable.addReference(this); }

    PxBaseTask_removeReference :: inline (this: *PxBaseTask) { this.vtable.removeReference(this); }

    PxBaseTask_getReference :: inline (this: *PxBaseTask) -> s32 { return this.vtable.getReference(this); }

    PxBaseTask_release :: inline (this: *PxBaseTask) { this.vtable.release(this); }

    vtable :: (obj: *PxBaseTask) -> *PxBaseTask_VTable { return obj.vtable; }


    /*
    * \brief A PxBaseTask implementation with deferred execution and full dependencies
    *
    * A PxTask must be submitted to a PxTaskManager to to be executed, Tasks may
    * optionally be named when they are submitted.
    */
    PxTask :: struct {
        #as using pxbasetask: PxBaseTask;

        mTaskID: PxTaskID; //!< ID assigned at submission
        #place pxbasetask; pxtask_vtable: *PxTask_VTable;
    }
    PxTask_VTable :: struct #type_info_none {
        using pxbasetask: PxBaseTask_VTable;
        submitted: (this: *PxTask) -> void #cpp_method;
    }
    PxTask_submitted :: inline (this: *PxTask) { this.pxtask_vtable.submitted(this); }

    vtable :: (obj: *PxTask) -> *PxTask_VTable { return obj.pxtask_vtable; }


    /*
    * \brief A PxBaseTask implementation with immediate execution and simple dependencies
    *
    * A PxLightCpuTask bypasses the PxTaskManager launch dependencies and will be
    * submitted directly to your scene's CpuDispatcher.  When the run() function
    * completes, it will decrement the reference count of the specified
    * continuation task.
    *
    * You must use a full-blown PxTask if you want your task to be resolved
    * by another PxTask, or you need more than a single dependency to be
    * resolved when your task completes, or your task will not run on the
    * CpuDispatcher.
    */
    PxLightCpuTask :: struct {
        #as using pxbasetask: PxBaseTask;

        Constructor :: (this: *PxLightCpuTask) -> void #cpp_method #foreign physx_static "??0PxLightCpuTask@physx@@QEAA@XZ";

        /*
        * \brief Initialize this task and specify the task that will have its ref count decremented on completion.
        *
        * Submission is deferred until the task's mRefCount is decremented to zero.
        * Note that we only use the PxTaskManager to query the appropriate dispatcher.
        *
        * \param[in] tm The PxTaskManager this task is managed by
        * \param[in] c The task to be executed when this task has finished running
        */
        setContinuation :: (this: *PxLightCpuTask, tm: *PxTaskManager, c: *PxBaseTask) -> void #cpp_method #foreign physx_static "?setContinuation@PxLightCpuTask@physx@@QEAAXAEAVPxTaskManager@2@PEAVPxBaseTask@2@@Z";

        /*
        * \brief Initialize this task and specify the task that will have its ref count decremented on completion.
        *
        * This overload of setContinuation() queries the PxTaskManager from the continuation
        * task, which cannot be NULL.
        * \param[in] c The task to be executed after this task has finished running
        */
        setContinuation :: (this: *PxLightCpuTask, c: *PxBaseTask) -> void #cpp_method #foreign physx_static "?setContinuation@PxLightCpuTask@physx@@QEAAXPEAVPxBaseTask@2@@Z";

        /*
        * \brief Retrieves continuation task
        */
        getContinuation :: (this: *PxLightCpuTask) -> *PxBaseTask #cpp_method #foreign physx_static "?getContinuation@PxLightCpuTask@physx@@QEBAPEAVPxBaseTask@2@XZ";

        mCont:     *PxBaseTask; //!< Continuation task, can be NULL
        mRefCount: s32; //!< PxTask is dispatched when reaches 0

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxLightCpuTask, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxLightCpuTask@physx@@UEAA@XZ";

        /*
        * \brief Manually decrement this task's reference count. If the reference
        * count reaches zero, the task will be dispatched.
        */
        virtual_removeReference :: (this: *PxLightCpuTask) -> void #cpp_method #foreign physx_static "?removeReference@PxLightCpuTask@physx@@UEAAXXZ";

        /* \brief Return the ref-count for this task */
        virtual_getReference :: (this: *PxLightCpuTask) -> s32 #cpp_method #foreign physx_static "?getReference@PxLightCpuTask@physx@@UEBAHXZ";

        /*
        * \brief Manually increment this task's reference count. The task will
        * not be allowed to run until removeReference() is called.
        */
        virtual_addReference :: (this: *PxLightCpuTask) -> void #cpp_method #foreign physx_static "?addReference@PxLightCpuTask@physx@@UEAAXXZ";

        /*
        * \brief called by CpuDispatcher after run method has completed
        *
        * Decrements the continuation task's reference count, if specified.
        */
        virtual_release :: (this: *PxLightCpuTask) -> void #cpp_method #foreign physx_static "?release@PxLightCpuTask@physx@@UEAAXXZ";
    }

    PxCudaContext :: struct {}

    PxCudaInteropRegisterFlag :: struct {
        Enum :: enum s32 {
            NONE           :: 0;
            READ_ONLY      :: 1;
            WRITE_DISCARD  :: 2;
            SURFACE_LDST   :: 4;
            TEXTURE_GATHER :: 8;

            eNONE           :: NONE;
            eREAD_ONLY      :: READ_ONLY;
            eWRITE_DISCARD  :: WRITE_DISCARD;
            eSURFACE_LDST   :: SURFACE_LDST;
            eTEXTURE_GATHER :: TEXTURE_GATHER;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief An interface class that the user can implement in order for PhysX to use a user-defined device memory allocator.
    */
    PxDeviceAllocatorCallback :: struct {
        vtable: *PxDeviceAllocatorCallback_VTable;
    }
    PxDeviceAllocatorCallback_VTable :: struct #type_info_none {
        memAlloc: (this: *PxDeviceAllocatorCallback, ptr: **void, size: u64) -> bool #cpp_method;

        memFree: (this: *PxDeviceAllocatorCallback, ptr: *void) -> bool #cpp_method;

        Destructor: (this: *PxDeviceAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxDeviceAllocatorCallback_memAlloc :: inline (this: *PxDeviceAllocatorCallback, ptr: **void, size: u64) -> bool { return this.vtable.memAlloc(this, ptr, size); }

    PxDeviceAllocatorCallback_memFree :: inline (this: *PxDeviceAllocatorCallback, ptr: *void) -> bool { return this.vtable.memFree(this, ptr); }

    PxDeviceAllocatorCallback_Destructor :: inline (this: *PxDeviceAllocatorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxDeviceAllocatorCallback) -> *PxDeviceAllocatorCallback_VTable { return obj.vtable; }


    /*
    \brief collection of set bits defined in NxCudaInteropRegisterFlag.
    
    \see NxCudaInteropRegisterFlag
    */
    PxCudaInteropRegisterFlags :: PxFlags(PxCudaInteropRegisterFlag.Enum, u32);

    //! \brief Descriptor used to create a PxCudaContextManager
    PxCudaContextManagerDesc :: struct {
        /*
        * \brief The CUDA context to manage
        *
        * If left NULL, the PxCudaContextManager will create a new context.  If
        * graphicsDevice is also not NULL, this new CUDA context will be bound to
        * that graphics device, enabling the use of CUDA/Graphics interop features.
        *
        * If ctx is not NULL, the specified context must be applied to the thread
        * that is allocating the PxCudaContextManager at creation time (aka, it
        * cannot be popped).  The PxCudaContextManager will take ownership of the
        * context until the manager is released.  All access to the context must be
        * gated by lock acquisition.
        *
        * If the user provides a context for the PxCudaContextManager, the context
        * _must_ have either been created on the GPU ordinal returned by
        * PxGetSuggestedCudaDeviceOrdinal() or on your graphics device.
        */
        ctx:             *CUcontext;

        /*
        * \brief D3D device pointer or OpenGl context handle
        *
        * Only applicable when ctx is NULL, thus forcing a new context to be
        * created.  In that case, the created context will be bound to this
        * graphics device.
        */
        graphicsDevice:  *void;

        /*
        * \brief Application-specific GUID
        *
        * If your application employs PhysX modules that use CUDA you need to use a GUID
        * so that patches for new architectures can be released for your game.You can obtain a GUID for your
        * application from Nvidia.
        */
        appGUID:         *u8;

        /*
        * \brief Application-specific device memory allocator
        *
        * the application can implement an device memory allocator, which inherites PxDeviceAllocatorCallback, and
        * pass that to the PxCudaContextManagerDesc. The SDK will use that allocator to allocate device memory instead of
        * using the defaul CUDA device memory allocator.
        */
        deviceAllocator: *PxDeviceAllocatorCallback;
    }

    /*
    \brief A cuda kernel index providing an index to the cuda module and the function name
    */
    PxKernelIndex :: struct {
        moduleIndex:  PxU32;
        functionName: *u8;
    }

    /*
    * \brief Manages thread locks, and task scheduling for a CUDA context
    *
    * A PxCudaContextManager manages access to a single CUDA context, allowing it to
    * be shared between multiple scenes.
    * The context must be acquired from the manager before using any CUDA APIs unless stated differently.
    *
    * The PxCudaContextManager is based on the CUDA driver API and explicitly does not
    * support the CUDA runtime API (aka, CUDART).
    */
    PxCudaContextManager :: struct {
        vtable: *PxCudaContextManager_VTable;
    }
    PxCudaContextManager_VTable :: struct #type_info_none {
        getMappedDevicePtr: (this: *PxCudaContextManager, pinnedHostBuffer: *void) -> CUdeviceptr #cpp_method;

        acquireContext: (this: *PxCudaContextManager) -> void #cpp_method;

        releaseContext: (this: *PxCudaContextManager) -> void #cpp_method;

        getContext: (this: *PxCudaContextManager) -> CUcontext #cpp_method;

        getCudaContext: (this: *PxCudaContextManager) -> *PxCudaContext #cpp_method;

        contextIsValid: (this: *PxCudaContextManager) -> bool #cpp_method;

        supportsArchSM10: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM11: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM12: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM13: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM20: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM30: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM35: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM50: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM52: (this: *PxCudaContextManager) -> bool #cpp_method;
        supportsArchSM60: (this: *PxCudaContextManager) -> bool #cpp_method;
        isIntegrated: (this: *PxCudaContextManager) -> bool #cpp_method;
        canMapHostMemory: (this: *PxCudaContextManager) -> bool #cpp_method;
        getDriverVersion: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getDeviceTotalMemBytes: (this: *PxCudaContextManager) -> u64 #cpp_method;
        getMultiprocessorCount: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getClockRate: (this: *PxCudaContextManager) -> u32 #cpp_method;
        getSharedMemPerBlock: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getSharedMemPerMultiprocessor: (this: *PxCudaContextManager) -> s32 #cpp_method;
        getMaxThreadsPerBlock: (this: *PxCudaContextManager) -> u32 #cpp_method;
        getDeviceName: (this: *PxCudaContextManager) -> *u8 #cpp_method;
        getDevice: (this: *PxCudaContextManager) -> CUdevice #cpp_method;

        setUsingConcurrentStreams: (this: *PxCudaContextManager, unknown0: bool) -> void #cpp_method;
        getUsingConcurrentStreams: (this: *PxCudaContextManager) -> bool #cpp_method;

        getDeviceMemoryInfo: (this: *PxCudaContextManager, free: *u64, total: *u64) -> void #cpp_method;

        usingDedicatedGPU: (this: *PxCudaContextManager) -> s32 #cpp_method;

        getCuModules: (this: *PxCudaContextManager) -> *CUmodule #cpp_method;

        release: (this: *PxCudaContextManager) -> void #cpp_method;

        Destructor: (this: *PxCudaContextManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        allocDeviceBufferInternal: (this: *PxCudaContextManager, numBytes: PxU64, filename: *u8 = null, line: PxI32 = -1) -> *void #cpp_method;
        allocPinnedHostBufferInternal: (this: *PxCudaContextManager, numBytes: PxU64, filename: *u8 = null, line: PxI32 = -1) -> *void #cpp_method;

        freeDeviceBufferInternal: (this: *PxCudaContextManager, deviceBuffer: *void) -> void #cpp_method;
        freePinnedHostBufferInternal: (this: *PxCudaContextManager, pinnedHostBuffer: *void) -> void #cpp_method;

        clearDeviceBufferAsyncInternal: (this: *PxCudaContextManager, deviceBuffer: *void, numBytes: PxU32, stream: CUstream, value: PxI32) -> void #cpp_method;

        copyDToHAsyncInternal: (this: *PxCudaContextManager, hostBuffer: *void, deviceBuffer: *void, numBytes: PxU32, stream: CUstream) -> void #cpp_method;
        copyHToDAsyncInternal: (this: *PxCudaContextManager, deviceBuffer: *void, hostBuffer: *void, numBytes: PxU32, stream: CUstream) -> void #cpp_method;
        copyDToDAsyncInternal: (this: *PxCudaContextManager, dstDeviceBuffer: *void, srcDeviceBuffer: *void, numBytes: PxU32, stream: CUstream) -> void #cpp_method;

        copyDToHInternal: (this: *PxCudaContextManager, hostBuffer: *void, deviceBuffer: *void, numBytes: PxU32) -> void #cpp_method;
        copyHToDInternal: (this: *PxCudaContextManager, deviceBuffer: *void, hostBuffer: *void, numBytes: PxU32) -> void #cpp_method;

        memsetD8AsyncInternal: (this: *PxCudaContextManager, dstDeviceBuffer: *void, value: *PxU8, numBytes: PxU32, stream: CUstream) -> void #cpp_method;
        memsetD32AsyncInternal: (this: *PxCudaContextManager, dstDeviceBuffer: *void, value: *PxU32, numIntegers: PxU32, stream: CUstream) -> void #cpp_method;
    }

    PxCudaContextManager_getMappedDevicePtr :: inline (this: *PxCudaContextManager, pinnedHostBuffer: *void) -> CUdeviceptr { return this.vtable.getMappedDevicePtr(this, pinnedHostBuffer); }

    PxCudaContextManager_acquireContext :: inline (this: *PxCudaContextManager) { this.vtable.acquireContext(this); }

    PxCudaContextManager_releaseContext :: inline (this: *PxCudaContextManager) { this.vtable.releaseContext(this); }

    PxCudaContextManager_getContext :: inline (this: *PxCudaContextManager) -> CUcontext { return this.vtable.getContext(this); }

    PxCudaContextManager_getCudaContext :: inline (this: *PxCudaContextManager) -> *PxCudaContext { return this.vtable.getCudaContext(this); }

    PxCudaContextManager_contextIsValid :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.contextIsValid(this); }

    PxCudaContextManager_supportsArchSM10 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM10(this); }
    PxCudaContextManager_supportsArchSM11 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM11(this); }
    PxCudaContextManager_supportsArchSM12 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM12(this); }
    PxCudaContextManager_supportsArchSM13 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM13(this); }
    PxCudaContextManager_supportsArchSM20 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM20(this); }
    PxCudaContextManager_supportsArchSM30 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM30(this); }
    PxCudaContextManager_supportsArchSM35 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM35(this); }
    PxCudaContextManager_supportsArchSM50 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM50(this); }
    PxCudaContextManager_supportsArchSM52 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM52(this); }
    PxCudaContextManager_supportsArchSM60 :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.supportsArchSM60(this); }
    PxCudaContextManager_isIntegrated :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.isIntegrated(this); }
    PxCudaContextManager_canMapHostMemory :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.canMapHostMemory(this); }
    PxCudaContextManager_getDriverVersion :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getDriverVersion(this); }
    PxCudaContextManager_getDeviceTotalMemBytes :: inline (this: *PxCudaContextManager) -> u64 { return this.vtable.getDeviceTotalMemBytes(this); }
    PxCudaContextManager_getMultiprocessorCount :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getMultiprocessorCount(this); }
    PxCudaContextManager_getClockRate :: inline (this: *PxCudaContextManager) -> u32 { return this.vtable.getClockRate(this); }
    PxCudaContextManager_getSharedMemPerBlock :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getSharedMemPerBlock(this); }
    PxCudaContextManager_getSharedMemPerMultiprocessor :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.getSharedMemPerMultiprocessor(this); }
    PxCudaContextManager_getMaxThreadsPerBlock :: inline (this: *PxCudaContextManager) -> u32 { return this.vtable.getMaxThreadsPerBlock(this); }
    PxCudaContextManager_getDeviceName :: inline (this: *PxCudaContextManager) -> *u8 { return this.vtable.getDeviceName(this); }
    PxCudaContextManager_getDevice :: inline (this: *PxCudaContextManager) -> CUdevice { return this.vtable.getDevice(this); }

    PxCudaContextManager_setUsingConcurrentStreams :: inline (this: *PxCudaContextManager, unknown0: bool) { this.vtable.setUsingConcurrentStreams(this, unknown0); }
    PxCudaContextManager_getUsingConcurrentStreams :: inline (this: *PxCudaContextManager) -> bool { return this.vtable.getUsingConcurrentStreams(this); }

    PxCudaContextManager_getDeviceMemoryInfo :: inline (this: *PxCudaContextManager, free: *u64, total: *u64) { this.vtable.getDeviceMemoryInfo(this, free, total); }

    PxCudaContextManager_usingDedicatedGPU :: inline (this: *PxCudaContextManager) -> s32 { return this.vtable.usingDedicatedGPU(this); }

    PxCudaContextManager_getCuModules :: inline (this: *PxCudaContextManager) -> *CUmodule { return this.vtable.getCuModules(this); }

    PxCudaContextManager_release :: inline (this: *PxCudaContextManager) { this.vtable.release(this); }

    PxCudaContextManager_Destructor :: inline (this: *PxCudaContextManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxCudaContextManager_allocDeviceBufferInternal :: inline (this: *PxCudaContextManager, numBytes: PxU64, filename: *u8 = null, line: PxI32 = -1) -> *void { return this.vtable.allocDeviceBufferInternal(this, numBytes, filename, line); }
    PxCudaContextManager_allocPinnedHostBufferInternal :: inline (this: *PxCudaContextManager, numBytes: PxU64, filename: *u8 = null, line: PxI32 = -1) -> *void { return this.vtable.allocPinnedHostBufferInternal(this, numBytes, filename, line); }

    PxCudaContextManager_freeDeviceBufferInternal :: inline (this: *PxCudaContextManager, deviceBuffer: *void) { this.vtable.freeDeviceBufferInternal(this, deviceBuffer); }
    PxCudaContextManager_freePinnedHostBufferInternal :: inline (this: *PxCudaContextManager, pinnedHostBuffer: *void) { this.vtable.freePinnedHostBufferInternal(this, pinnedHostBuffer); }

    PxCudaContextManager_clearDeviceBufferAsyncInternal :: inline (this: *PxCudaContextManager, deviceBuffer: *void, numBytes: PxU32, stream: CUstream, value: PxI32) { this.vtable.clearDeviceBufferAsyncInternal(this, deviceBuffer, numBytes, stream, value); }

    PxCudaContextManager_copyDToHAsyncInternal :: inline (this: *PxCudaContextManager, hostBuffer: *void, deviceBuffer: *void, numBytes: PxU32, stream: CUstream) { this.vtable.copyDToHAsyncInternal(this, hostBuffer, deviceBuffer, numBytes, stream); }
    PxCudaContextManager_copyHToDAsyncInternal :: inline (this: *PxCudaContextManager, deviceBuffer: *void, hostBuffer: *void, numBytes: PxU32, stream: CUstream) { this.vtable.copyHToDAsyncInternal(this, deviceBuffer, hostBuffer, numBytes, stream); }
    PxCudaContextManager_copyDToDAsyncInternal :: inline (this: *PxCudaContextManager, dstDeviceBuffer: *void, srcDeviceBuffer: *void, numBytes: PxU32, stream: CUstream) { this.vtable.copyDToDAsyncInternal(this, dstDeviceBuffer, srcDeviceBuffer, numBytes, stream); }

    PxCudaContextManager_copyDToHInternal :: inline (this: *PxCudaContextManager, hostBuffer: *void, deviceBuffer: *void, numBytes: PxU32) { this.vtable.copyDToHInternal(this, hostBuffer, deviceBuffer, numBytes); }
    PxCudaContextManager_copyHToDInternal :: inline (this: *PxCudaContextManager, deviceBuffer: *void, hostBuffer: *void, numBytes: PxU32) { this.vtable.copyHToDInternal(this, deviceBuffer, hostBuffer, numBytes); }

    PxCudaContextManager_memsetD8AsyncInternal :: inline (this: *PxCudaContextManager, dstDeviceBuffer: *void, value: *PxU8, numBytes: PxU32, stream: CUstream) { this.vtable.memsetD8AsyncInternal(this, dstDeviceBuffer, value, numBytes, stream); }
    PxCudaContextManager_memsetD32AsyncInternal :: inline (this: *PxCudaContextManager, dstDeviceBuffer: *void, value: *PxU32, numIntegers: PxU32, stream: CUstream) { this.vtable.memsetD32AsyncInternal(this, dstDeviceBuffer, value, numIntegers, stream); }

    vtable :: (obj: *PxCudaContextManager) -> *PxCudaContextManager_VTable { return obj.vtable; }


    /*
    * \brief Convenience class for holding CUDA lock within a scope
    */
    PxScopedCudaLock :: struct {
        /*
        * \brief ScopedCudaLock constructor
        */
        Constructor :: (this: *PxScopedCudaLock, ctx: *PxCudaContextManager) -> void #cpp_method #foreign physx_static "??0PxScopedCudaLock@physx@@QEAA@AEAVPxCudaContextManager@1@@Z";

        /*
        * \brief ScopedCudaLock destructor
        */
        Destructor :: (this: *PxScopedCudaLock) -> void #cpp_method #foreign physx_static "??1PxScopedCudaLock@physx@@QEAA@XZ";

        /*
        * \brief CUDA context manager pointer (initialized in the constructor)
        */
        mCtx: *PxCudaContextManager;
    }

    PxPhysicsGpu :: struct {}

    /*
    \brief A geometry type.
    
    Used to distinguish the type of a ::PxGeometry object.
    */
    PxGeometryType :: struct {
        Enum :: enum s32 {
            SPHERE          :: 0;
            PLANE           :: 1;
            CAPSULE         :: 2;
            BOX             :: 3;
            CONVEXMESH      :: 4;
            PARTICLESYSTEM  :: 5;
            TETRAHEDRONMESH :: 6;
            TRIANGLEMESH    :: 7;
            HEIGHTFIELD     :: 8;
            HAIRSYSTEM      :: 9;
            CUSTOM          :: 10;

            GEOMETRY_COUNT  :: 11;
            INVALID         :: -1;

            eSPHERE          :: SPHERE;
            ePLANE           :: PLANE;
            eCAPSULE         :: CAPSULE;
            eBOX             :: BOX;
            eCONVEXMESH      :: CONVEXMESH;
            ePARTICLESYSTEM  :: PARTICLESYSTEM;
            eTETRAHEDRONMESH :: TETRAHEDRONMESH;
            eTRIANGLEMESH    :: TRIANGLEMESH;
            eHEIGHTFIELD     :: HEIGHTFIELD;
            eHAIRSYSTEM      :: HAIRSYSTEM;
            eCUSTOM          :: CUSTOM;

            eGEOMETRY_COUNT  :: GEOMETRY_COUNT;
            eINVALID         :: INVALID;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief A geometry object.
    
    A geometry object defines the characteristics of a spatial object, but without any information
    about its placement in the world.
    
    \note This is an abstract class.  You cannot create instances directly.  Create an instance of one of the derived classes instead.
    */
    PxGeometry :: struct {
        /*
        \brief Returns the type of the geometry.
        \return The type of the object.
        */
        getType :: (this: *PxGeometry) -> PxGeometryType.Enum #cpp_method #foreign physxcharacterkinematic_static "?getType@PxGeometry@physx@@QEBA?AW4Enum@PxGeometryType@2@XZ";

        Constructor :: (this: *PxGeometry, type: PxGeometryType.Enum) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxGeometry@physx@@IEAA@W4Enum@PxGeometryType@1@@Z";
        CopyConstructor :: (this: *PxGeometry, that: *PxGeometry) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxGeometry@physx@@IEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxGeometry, that: PxGeometry) #no_context {
            CopyConstructor(this, *that);
        }

        mType:        PxGeometryType.Enum;

        mTypePadding: float; // PT: padding bytes on x64, used internally
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxGeometry, that: *physx.PxGeometry) -> void #cpp_method #foreign physx_static "??4PxGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxGeometry, that: physx.PxGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Class representing the geometry of a box.
    
    The geometry of a box can be fully specified by its half extents.  This is the half of its width, height, and depth.
    \note The scaling of the box is expected to be baked into these values, there is no additional scaling parameter.
    */
    PxBoxGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Constructor to initialize half extents from scalar parameters.
        \param hx Initial half extents' x component.
        \param hy Initial half extents' y component.
        \param hz Initial half extents' z component.
        */
        Constructor :: (this: *PxBoxGeometry, hx: PxReal = 0.0, hy: PxReal = 0.0, hz: PxReal = 0.0) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxBoxGeometry@physx@@QEAA@MMM@Z";

        /*
        \brief Constructor to initialize half extents from vector parameter.
        \param halfExtents_ Initial half extents.
        */
        Constructor :: (this: *PxBoxGeometry, halfExtents_: PxVec3) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxBoxGeometry@physx@@QEAA@V?$PxVec3T@M@1@@Z";

        /*
        \brief Copy constructor.
        
        \param[in] that		Other object
        */
        CopyConstructor :: (this: *PxBoxGeometry, that: *PxBoxGeometry) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxBoxGeometry@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxBoxGeometry, that: PxBoxGeometry) #no_context {
            CopyConstructor(this, *that);
        }

        /*
        \brief Returns true if the geometry is valid.
        
        \return True if the current settings are valid
        
        \note A valid box has a positive extent in each direction (halfExtents.x > 0, halfExtents.y > 0, halfExtents.z > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a box that has zero extent in any direction.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxBoxGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxBoxGeometry@physx@@QEBA_NXZ";

        /*
        \brief Half of the width, height, and depth of the box.
        */
        halfExtents: PxVec3;
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxBoxGeometry, that: *physx.PxBoxGeometry) -> void #cpp_method #foreign physxcommon_static "??4PxBoxGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxBoxGeometry, that: physx.PxBoxGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Geometry-level query flags.
    
    \see PxScene::raycast PxScene::overlap PxScene::sweep PxBVH::raycast PxBVH::overlap PxBVH::sweep PxGeometryQuery::raycast PxGeometryQuery::overlap PxGeometryQuery::sweep
    \see PxGeometryQuery::computePenetration PxGeometryQuery::pointDistance PxGeometryQuery::computeGeomBounds
    \see PxMeshQuery::findOverlapTriangleMesh PxMeshQuery::findOverlapHeightField PxMeshQuery::sweep
    */
    PxGeometryQueryFlag :: struct {
        Enum :: enum s32 {
            SIMD_GUARD :: 1;

            DEFAULT    :: 1;

            eSIMD_GUARD :: SIMD_GUARD;

            eDEFAULT    :: DEFAULT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxGeometryQueryFlags :: PxFlags(PxGeometryQueryFlag.Enum, PxU32);

    /*
    \brief Base class for callback reporting an unknown number of items to users.
    
    This can be used as-is and customized by users, or several pre-designed callbacks can be used instead (see below).
    
    This design lets users decide how to retrieve the results of a query:
    - either one by one via a regular callback
    - or one batch at a time via a callback
    - or written out directly to their own C-style buffer
    - or pushed back to their own PxArray
    - etc
    
    \see PxRegularReportCallback PxLocalStorageReportCallback PxExternalStorageReportCallback PxDynamicArrayReportCallback
    */
    PxReportCallback :: struct(T: Type) {
        mBuffer:   *T; // Destination buffer for writing results. if NULL, the system will use its internal buffer and set that pointer as it sees fit.

        mCapacity: PxU32; // Capacity of mBuffer. If mBuffer is NULL, this controls how many items are reported to users at the same time (with a limit of 256).
        mSize:     PxU32; //!< Current number of items in the buffer. This is entirely managed by the system.
    }

    /*
    \brief Regular report callback
    
    This reports results like a regular callback would:
    - without explicit buffer management from users
    - by default, one item at a time
    
    This customized callback sends results to users via the processResults() function.
    
    The capacity parameter dictates how many items can be reported at a time,
    i.e. how many times the flushResults/processResults function will be called by the system.
    
    \see PxReportCallback
    */
    PxRegularReportCallback :: struct(T: Type) {
        #as pxreportcallback: PxReportCallback(T); // jai: no "using" to avoid name-clashes
    }

    /*
    \brief Local storage report callback
    
    This is the same as a regular callback, except the destination buffer is a local buffer within the class.
    
    This customized callback sends results to users via the processResults() function.
    
    The capacity of the embedded buffer (determined by a template parameter) dictates how many items can be reported at a time,
    i.e. how many times the flushResults/processResults function will be called by the system.
    
    \see PxReportCallback
    */
    PxLocalStorageReportCallback :: struct(T: Type, capacityT: PxU32) {
        #as pxreportcallback: PxReportCallback(T); // jai: no "using" to avoid name-clashes

        mLocalStorage: [T] T;
    }

    /*
    \brief External storage report callback
    
    This is the same as a regular callback, except the destination buffer is a user-provided external buffer.
    
    Typically the provided buffer can be larger here than for PxLocalStorageReportCallback, and it could
    even be a scratchpad-kind of memory shared by multiple sub-systems.
    
    This would be the same as having a C-style buffer to write out results in the query interface.
    
    This customized callback sends results to users via the processResults() function.
    
    The capacity parameter dictates how many items can be reported at a time,
    i.e. how many times the flushResults/processResults function will be called by the system.
    
    \see PxReportCallback
    */
    PxExternalStorageReportCallback :: struct(T: Type) {
        #as pxreportcallback: PxReportCallback(T); // jai: no "using" to avoid name-clashes
    }

    /*
    \brief Dynamic array report callback
    
    This callback emulates the behavior of pushing results to a (user-provided) dynamic array.
    
    This customized callback does not actually call users back during the query, results are
    available afterwards in the provided dynamic array. This would be the same as having a PxArray
    directly in the query interface.
    
    \see PxReportCallback
    */
    PxDynamicArrayReportCallback :: struct(T: Type) {
        #as pxreportcallback: PxReportCallback(T); // jai: no "using" to avoid name-clashes

        mResults: *PxArray(T);
    }

    /*
    \brief Class representing a bounding volume hierarchy.
    
    PxBVH can be provided to PxScene::addActor. In this case the scene query
    pruning structure inside PhysX SDK will store/update one bound per actor.
    The scene queries against such an actor will query actor bounds and then
    make a local space query against the provided BVH, which is in actor's
    local space.
    
    PxBVH can also be used as a standalone data-structure for arbitrary
    purposes, unrelated to PxScene / PxActor.
    
    \see PxScene::addActor
    */
    PxBVH :: struct {
        #as using pxbase: PxBase;

        RaycastCallback :: struct {
            vtable: *RaycastCallback_VTable;
            Constructor :: (this: *RaycastCallback) -> void #cpp_method #foreign physxcommon_static "??0RaycastCallback@PxBVH@physx@@QEAA@XZ";

            // Virtual functions:
            // Normally you should call them via the vtable.
            // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
            // or need to create a vtable yourself.
            virtual_Destructor :: (this: *RaycastCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1RaycastCallback@PxBVH@physx@@UEAA@XZ";
        }
        RaycastCallback_VTable :: struct #type_info_none {
            Destructor: (this: *RaycastCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

            reportHit: (this: *RaycastCallback, boundsIndex: PxU32, distance: *PxReal) -> bool #cpp_method;
        }

        RaycastCallback_Destructor :: inline (this: *RaycastCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

        RaycastCallback_reportHit :: inline (this: *RaycastCallback, boundsIndex: PxU32, distance: *PxReal) -> bool { return this.vtable.reportHit(this, boundsIndex, distance); }

        vtable :: (obj: *RaycastCallback) -> *RaycastCallback_VTable { return obj.vtable; }


        OverlapCallback :: struct {
            vtable: *OverlapCallback_VTable;
            Constructor :: (this: *OverlapCallback) -> void #cpp_method #foreign physxcommon_static "??0OverlapCallback@PxBVH@physx@@QEAA@XZ";

            // Virtual functions:
            // Normally you should call them via the vtable.
            // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
            // or need to create a vtable yourself.
            virtual_Destructor :: (this: *OverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1OverlapCallback@PxBVH@physx@@UEAA@XZ";
        }
        OverlapCallback_VTable :: struct #type_info_none {
            Destructor: (this: *OverlapCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

            reportHit: (this: *OverlapCallback, boundsIndex: PxU32) -> bool #cpp_method;
        }

        OverlapCallback_Destructor :: inline (this: *OverlapCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

        OverlapCallback_reportHit :: inline (this: *OverlapCallback, boundsIndex: PxU32) -> bool { return this.vtable.reportHit(this, boundsIndex); }

        vtable :: (obj: *OverlapCallback) -> *OverlapCallback_VTable { return obj.vtable; }


        TraversalCallback :: struct {
            vtable: *TraversalCallback_VTable;
        }
        TraversalCallback_VTable :: struct #type_info_none {
            Destructor: (this: *TraversalCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

            visitNode: (this: *TraversalCallback, bounds: *PxBounds3) -> bool #cpp_method;

            reportLeaf: (this: *TraversalCallback, nbPrims: PxU32, prims: *PxU32) -> bool #cpp_method;
        }

        TraversalCallback_Destructor :: inline (this: *TraversalCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

        TraversalCallback_visitNode :: inline (this: *TraversalCallback, bounds: *PxBounds3) -> bool { return this.vtable.visitNode(this, bounds); }

        TraversalCallback_reportLeaf :: inline (this: *TraversalCallback, nbPrims: PxU32, prims: *PxU32) -> bool { return this.vtable.reportLeaf(this, nbPrims, prims); }

        vtable :: (obj: *TraversalCallback) -> *TraversalCallback_VTable { return obj.vtable; }


        Constructor :: (this: *PxBVH, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxBVH@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxbvh_vtable: *PxBVH_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxBVH) -> *u8 #cpp_method #foreign physxcommon_static "?getConcreteTypeName@PxBVH@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxBVH, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxBVH@physx@@MEAA@XZ";

        virtual_isKindOf :: (this: *PxBVH, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxBVH@physx@@MEBA_NPEBD@Z";
    }
    PxBVH_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        raycast: (this: *PxBVH, origin: *PxVec3, unitDir: *PxVec3, maxDist: float, cb: *PxBVH.RaycastCallback, queryFlags: PxGeometryQueryFlags) -> bool #cpp_method;

        sweep: (this: *PxBVH, geom: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, maxDist: float, cb: *PxBVH.RaycastCallback, queryFlags: PxGeometryQueryFlags) -> bool #cpp_method;

        overlap: (this: *PxBVH, geom: *PxGeometry, pose: *PxTransform, cb: *PxBVH.OverlapCallback, queryFlags: PxGeometryQueryFlags) -> bool #cpp_method;

        cull: (this: *PxBVH, nbPlanes: PxU32, planes: *PxPlane, cb: *PxBVH.OverlapCallback, queryFlags: PxGeometryQueryFlags) -> bool #cpp_method;

        getNbBounds: (this: *PxBVH) -> PxU32 #cpp_method;

        getBounds: (this: *PxBVH) -> *PxBounds3 #cpp_method;

        refit: (this: *PxBVH) -> void #cpp_method;

        updateBounds: (this: *PxBVH, boundsIndex: PxU32, newBounds: *PxBounds3) -> bool #cpp_method;

        partialRefit: (this: *PxBVH) -> void #cpp_method;

        traverse: (this: *PxBVH, cb: *PxBVH.TraversalCallback) -> bool #cpp_method;
    }

    PxBVH_raycast :: inline (this: *PxBVH, origin: *PxVec3, unitDir: *PxVec3, maxDist: float, cb: *PxBVH.RaycastCallback, queryFlags: PxGeometryQueryFlags) -> bool { return this.pxbvh_vtable.raycast(this, origin, unitDir, maxDist, cb, queryFlags); }

    PxBVH_sweep :: inline (this: *PxBVH, geom: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, maxDist: float, cb: *PxBVH.RaycastCallback, queryFlags: PxGeometryQueryFlags) -> bool { return this.pxbvh_vtable.sweep(this, geom, pose, unitDir, maxDist, cb, queryFlags); }

    PxBVH_overlap :: inline (this: *PxBVH, geom: *PxGeometry, pose: *PxTransform, cb: *PxBVH.OverlapCallback, queryFlags: PxGeometryQueryFlags) -> bool { return this.pxbvh_vtable.overlap(this, geom, pose, cb, queryFlags); }

    PxBVH_cull :: inline (this: *PxBVH, nbPlanes: PxU32, planes: *PxPlane, cb: *PxBVH.OverlapCallback, queryFlags: PxGeometryQueryFlags) -> bool { return this.pxbvh_vtable.cull(this, nbPlanes, planes, cb, queryFlags); }

    PxBVH_getNbBounds :: inline (this: *PxBVH) -> PxU32 { return this.pxbvh_vtable.getNbBounds(this); }

    PxBVH_getBounds :: inline (this: *PxBVH) -> *PxBounds3 { return this.pxbvh_vtable.getBounds(this); }

    PxBVH_refit :: inline (this: *PxBVH) { this.pxbvh_vtable.refit(this); }

    PxBVH_updateBounds :: inline (this: *PxBVH, boundsIndex: PxU32, newBounds: *PxBounds3) -> bool { return this.pxbvh_vtable.updateBounds(this, boundsIndex, newBounds); }

    PxBVH_partialRefit :: inline (this: *PxBVH) { this.pxbvh_vtable.partialRefit(this); }

    PxBVH_traverse :: inline (this: *PxBVH, cb: *PxBVH.TraversalCallback) -> bool { return this.pxbvh_vtable.traverse(this, cb); }

    vtable :: (obj: *PxBVH) -> *PxBVH_VTable { return obj.pxbvh_vtable; }


    /*
    \brief Desired build strategy for bounding-volume hierarchies
    */
    PxBVHBuildStrategy :: struct {
        Enum :: enum s32 {
            FAST    :: 0;
            DEFAULT :: 1;
            SAH     :: 2;

            LAST    :: 3;

            eFAST    :: FAST;
            eDEFAULT :: DEFAULT;
            eSAH     :: SAH;

            eLAST    :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Class representing the geometry of a capsule.
    
    Capsules are shaped as the union of a cylinder of length 2 * halfHeight and with the
    given radius centered at the origin and extending along the x axis, and two hemispherical ends.
    \note The scaling of the capsule is expected to be baked into these values, there is no additional scaling parameter.
    
    The function PxTransformFromSegment is a helper for generating an appropriate transform for the capsule from the capsule's interior line segment.
    
    \see PxTransformFromSegment
    */
    PxCapsuleGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Constructor, initializes to a capsule with passed radius and half height.
        */
        Constructor :: (this: *PxCapsuleGeometry, radius_: PxReal = 0.0, halfHeight_: PxReal = 0.0) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxCapsuleGeometry@physx@@QEAA@MM@Z";

        /*
        \brief Copy constructor.
        
        \param[in] that		Other object
        */
        CopyConstructor :: (this: *PxCapsuleGeometry, that: *PxCapsuleGeometry) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxCapsuleGeometry@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxCapsuleGeometry, that: PxCapsuleGeometry) #no_context {
            CopyConstructor(this, *that);
        }

        /*
        \brief Returns true if the geometry is valid.
        
        \return True if the current settings are valid.
        
        \note A valid capsule has radius > 0, halfHeight >= 0.
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a capsule that has zero radius or height.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxCapsuleGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxCapsuleGeometry@physx@@QEBA_NXZ";

        /*
        \brief The radius of the capsule.
        */
        radius:     PxReal;

        /*
        \brief half of the capsule's height, measured between the centers of the hemispherical ends.
        */
        halfHeight: PxReal;
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxCapsuleGeometry, that: *physx.PxCapsuleGeometry) -> void #cpp_method #foreign physx_static "??4PxCapsuleGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxCapsuleGeometry, that: physx.PxCapsuleGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Polygon data
    
    Plane format: (mPlane[0],mPlane[1],mPlane[2]).dot(x) + mPlane[3] = 0
    With the normal outward-facing from the hull.
    */
    PxHullPolygon :: struct {
        mPlane:     [4] PxReal; //!< Plane equation for this polygon
        mNbVerts:   PxU16; //!< Number of vertices/edges in the polygon
        mIndexBase: PxU16; //!< Offset in index buffer
    }

    /*
    \brief A convex mesh.
    
    Internally represented as a list of convex polygons. The number
    of polygons is limited to 256.
    
    To avoid duplicating data when you have several instances of a particular
    mesh positioned differently, you do not use this class to represent a
    convex object directly. Instead, you create an instance of this mesh via
    the PxConvexMeshGeometry and PxShape classes.
    
    <h3>Creation</h3>
    
    To create an instance of this class call PxPhysics::createConvexMesh(),
    and PxConvexMesh::release() to delete it. This is only possible
    once you have released all of its #PxShape instances.
    
    <h3>Visualizations:</h3>
    \li #PxVisualizationParameter::eCOLLISION_AABBS
    \li #PxVisualizationParameter::eCOLLISION_SHAPES
    \li #PxVisualizationParameter::eCOLLISION_AXES
    \li #PxVisualizationParameter::eCOLLISION_FNORMALS
    \li #PxVisualizationParameter::eCOLLISION_EDGES
    
    \see PxConvexMeshDesc PxPhysics.createConvexMesh()
    */
    PxConvexMesh :: struct {
        #as using pxrefcounted: PxRefCounted;

        Constructor :: (this: *PxConvexMesh, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxConvexMesh@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxConvexMesh, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxConvexMesh@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrefcounted; pxconvexmesh_vtable: *PxConvexMesh_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxConvexMesh) -> *u8 #cpp_method #foreign physxcommon_static "?getConcreteTypeName@PxConvexMesh@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxConvexMesh, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxConvexMesh@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxConvexMesh, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxConvexMesh@physx@@MEBA_NPEBD@Z";
    }
    PxConvexMesh_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        getNbVertices: (this: *PxConvexMesh) -> PxU32 #cpp_method;

        getVertices: (this: *PxConvexMesh) -> *PxVec3 #cpp_method;

        getIndexBuffer: (this: *PxConvexMesh) -> *PxU8 #cpp_method;

        getNbPolygons: (this: *PxConvexMesh) -> PxU32 #cpp_method;

        getPolygonData: (this: *PxConvexMesh, index: PxU32, data: *PxHullPolygon) -> bool #cpp_method;

        getMassInformation: (this: *PxConvexMesh, mass: *PxReal, localInertia: *PxMat33, localCenterOfMass: *PxVec3) -> void #cpp_method;

        getLocalBounds: (this: *PxConvexMesh) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getSDF: (this: *PxConvexMesh) -> *PxReal #cpp_method;

        isGpuCompatible: (this: *PxConvexMesh) -> bool #cpp_method;
    }

    PxConvexMesh_getNbVertices :: inline (this: *PxConvexMesh) -> PxU32 { return this.pxconvexmesh_vtable.getNbVertices(this); }

    PxConvexMesh_getVertices :: inline (this: *PxConvexMesh) -> *PxVec3 { return this.pxconvexmesh_vtable.getVertices(this); }

    PxConvexMesh_getIndexBuffer :: inline (this: *PxConvexMesh) -> *PxU8 { return this.pxconvexmesh_vtable.getIndexBuffer(this); }

    PxConvexMesh_getNbPolygons :: inline (this: *PxConvexMesh) -> PxU32 { return this.pxconvexmesh_vtable.getNbPolygons(this); }

    PxConvexMesh_getPolygonData :: inline (this: *PxConvexMesh, index: PxU32, data: *PxHullPolygon) -> bool { return this.pxconvexmesh_vtable.getPolygonData(this, index, data); }

    PxConvexMesh_getMassInformation :: inline (this: *PxConvexMesh, mass: *PxReal, localInertia: *PxMat33, localCenterOfMass: *PxVec3) { this.pxconvexmesh_vtable.getMassInformation(this, mass, localInertia, localCenterOfMass); }

    PxConvexMesh_getLocalBounds :: inline (this: *PxConvexMesh) -> PxBounds3 { return this.pxconvexmesh_vtable.getLocalBounds(this); }

    PxConvexMesh_getSDF :: inline (this: *PxConvexMesh) -> *PxReal { return this.pxconvexmesh_vtable.getSDF(this); }

    PxConvexMesh_isGpuCompatible :: inline (this: *PxConvexMesh) -> bool { return this.pxconvexmesh_vtable.isGpuCompatible(this); }

    vtable :: (obj: *PxConvexMesh) -> *PxConvexMesh_VTable { return obj.pxconvexmesh_vtable; }


    /*
    \brief A class expressing a nonuniform scaling transformation.
    
    The scaling is along arbitrary axes that are specified by PxMeshScale::rotation. Specifically, PxMeshScale::rotation
    describes the rotation from the scaling-axes frame to the mesh-local frame, i.e. PxMeshScale::rotation.rotate(v) transforms
    the coordinates of vertex v from the mesh-local frame to the scaling-axes frame.
    
    \note	Negative scale values are supported for PxTriangleMeshGeometry
    with absolute values for each component within [PX_MIN_ABS_MESH_SCALE, PX_MAX_ABS_MESH_SCALE] range.
    Negative scale causes a reflection around the specified axis, in addition PhysX will flip the normals
    for mesh triangles when scale.x*scale.y*scale.z < 0.
    \note	Only positive scale values are supported for PxConvexMeshGeometry
    with values for each component within [PX_MIN_ABS_MESH_SCALE, PX_MAX_ABS_MESH_SCALE] range).
    
    \see PxConvexMeshGeometry PxTriangleMeshGeometry
    */
    PxMeshScale :: struct {
        /*
        \brief Constructor initializes to identity scale.
        */
        Constructor :: (this: *PxMeshScale) -> void #cpp_method #foreign physxcommon_static "??0PxMeshScale@physx@@QEAA@XZ";

        /*
        \brief Constructor to initialize to arbitrary scale and identity scale rotation.
        */
        Constructor :: (this: *PxMeshScale, s: *PxVec3) -> void #cpp_method #foreign physxcommon_static "??0PxMeshScale@physx@@QEAA@AEBV?$PxVec3T@M@1@@Z";
        Constructor :: (this: *PxMeshScale, s: PxVec3) #no_context {
            Constructor(this, *s);
        }

        /*
        \brief Constructor to initialize to arbitrary scaling.
        */
        Constructor :: (this: *PxMeshScale, s: *PxVec3, r: *PxQuat) -> void #cpp_method #foreign physxcommon_static "??0PxMeshScale@physx@@QEAA@AEBV?$PxVec3T@M@1@AEBV?$PxQuatT@M@1@@Z";
        Constructor :: (this: *PxMeshScale, s: PxVec3, r: PxQuat) #no_context {
            Constructor(this, *s, *r);
        }

        /*
        \brief Returns true if the scaling is an identity transformation.
        */
        isIdentity :: (this: *PxMeshScale) -> bool #cpp_method #foreign physxcommon_static "?isIdentity@PxMeshScale@physx@@QEBA_NXZ";

        /*
        \brief Returns the inverse of this scaling transformation.
        */
        getInverse :: (this: *PxMeshScale) -> PxMeshScale #cpp_method #cpp_return_type_is_non_pod #foreign physxcommon_static "?getInverse@PxMeshScale@physx@@QEBA?AV12@XZ";

        /*
        \brief Converts this transformation to a 3x3 matrix representation.
        */
        toMat33 :: (this: *PxMeshScale) -> PxMat33 #cpp_method #foreign physxcharacterkinematic_static "?toMat33@PxMeshScale@physx@@QEBA?AV?$PxMat33T@M@2@XZ";

        /*
        \brief Returns true if combination of negative scale components will cause the triangle normal to flip. The SDK will flip the normals internally.
        */
        hasNegativeDeterminant :: (this: *PxMeshScale) -> bool #cpp_method #foreign physxcommon_static "?hasNegativeDeterminant@PxMeshScale@physx@@QEBA_NXZ";

        transform :: (this: *PxMeshScale, v: *PxVec3) -> PxVec3 #cpp_method #foreign physxcommon_static "?transform@PxMeshScale@physx@@QEBA?AV?$PxVec3T@M@2@AEBV32@@Z";
        transform :: (this: *PxMeshScale, v: PxVec3) -> PxVec3 #no_context {
            return transform(this, *v);
        }

        isValidForTriangleMesh :: (this: *PxMeshScale) -> bool #cpp_method #foreign physxcommon_static "?isValidForTriangleMesh@PxMeshScale@physx@@QEBA_NXZ";

        isValidForConvexMesh :: (this: *PxMeshScale) -> bool #cpp_method #foreign physxcommon_static "?isValidForConvexMesh@PxMeshScale@physx@@QEBA_NXZ";

        scale:    PxVec3; //!< A nonuniform scaling
        rotation: PxQuat; //!< The orientation of the scaling axes
    }

    /*
    \brief Flags controlling the simulated behavior of the convex mesh geometry.
    
    Used in ::PxConvexMeshGeometryFlags.
    */
    PxConvexMeshGeometryFlag :: struct {
        Enum :: enum s32 {
            eTIGHT_BOUNDS :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxConvexMeshGeometryFlag.
    
    \see PxConvexMeshGeometryFlag
    */
    PxConvexMeshGeometryFlags :: PxFlags(PxConvexMeshGeometryFlag.Enum, PxU8);

    /*
    \brief Convex mesh geometry class.
    
    This class unifies a convex mesh object with a scaling transform, and
    lets the combined object be used anywhere a PxGeometry is needed.
    
    The scaling is a transform along arbitrary axes contained in the scale object.
    The vertices of the mesh in geometry (or shape) space is the
    PxMeshScale::toMat33() transform, multiplied by the vertex space vertices
    in the PxConvexMesh object.
    */
    PxConvexMeshGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Constructor. By default creates an empty object with a NULL mesh and identity scale.
        
        \param[in] mesh		Mesh pointer. May be NULL, though this will not make the object valid for shape construction.
        \param[in] scaling	Scale factor.
        \param[in] flags	Mesh flags.
        \
        */
        Constructor :: (this: *PxConvexMeshGeometry, mesh: *PxConvexMesh = null, scaling: *PxMeshScale, flags: PxConvexMeshGeometryFlags) -> void #cpp_method #foreign physx_static "??0PxConvexMeshGeometry@physx@@QEAA@PEAVPxConvexMesh@1@AEBVPxMeshScale@1@V?$PxFlags@W4Enum@PxConvexMeshGeometryFlag@physx@@E@1@@Z";
        Constructor :: (this: *PxConvexMeshGeometry, mesh: *PxConvexMesh = null, scaling: PxMeshScale = PxMeshScale.{}, flags: PxConvexMeshGeometryFlags) #no_context {
            Constructor(this, mesh, *scaling, flags);
        }

        /*
        \brief Copy constructor.
        
        \param[in] that		Other object
        */
        CopyConstructor :: (this: *PxConvexMeshGeometry, that: *PxConvexMeshGeometry) -> void #cpp_method #foreign physx_static "??0PxConvexMeshGeometry@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxConvexMeshGeometry, that: PxConvexMeshGeometry) #no_context {
            CopyConstructor(this, *that);
        }

        /*
        \brief Returns true if the geometry is valid.
        
        \return True if the current settings are valid for shape creation.
        
        \note A valid convex mesh has a positive scale value in each direction (scale.x > 0, scale.y > 0, scale.z > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a convex that has zero extent in any direction.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxConvexMeshGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxConvexMeshGeometry@physx@@QEBA_NXZ";

        scale:            PxMeshScale; //!< The scaling transformation (from vertex space to shape space).
        convexMesh:       *PxConvexMesh; //!< A reference to the convex mesh object.
        meshFlags:        PxConvexMeshGeometryFlags; //!< Mesh flags.
        paddingFromFlags: PxPadding(UnknownTemplateArgumentPlaceholder) = 3; //!< padding for mesh flags
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxConvexMeshGeometry, that: *physx.PxConvexMeshGeometry) -> void #cpp_method #foreign physx_static "??4PxConvexMeshGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxConvexMeshGeometry, that: physx.PxConvexMeshGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief A class representing the geometry of a sphere.
    
    Spheres are defined by their radius.
    \note The scaling of the sphere is expected to be baked into this value, there is no additional scaling parameter.
    */
    PxSphereGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Constructor.
        */
        Constructor :: (this: *PxSphereGeometry, ir: PxReal = 0.0) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxSphereGeometry@physx@@QEAA@M@Z";

        /*
        \brief Returns true if the geometry is valid.
        
        \return True if the current settings are valid
        
        \note A valid sphere has radius > 0.
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a sphere that has zero radius.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxSphereGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxSphereGeometry@physx@@QEBA_NXZ";

        /*
        \brief The radius of the sphere.
        */
        radius: PxReal;
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxSphereGeometry, that: *physx.PxSphereGeometry) -> void #cpp_method #foreign physx_static "??4PxSphereGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxSphereGeometry, that: physx.PxSphereGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Class describing a plane geometry.
    
    The plane geometry specifies the half-space volume x<=0. As with other geometry types,
    when used in a PxShape the collision volume is obtained by transforming the halfspace
    by the shape local pose and the actor global pose.
    
    To generate a PxPlane from a PxTransform, transform PxPlane(1,0,0,0).
    
    To generate a PxTransform from a PxPlane, use PxTransformFromPlaneEquation.
    
    \see PxShape.setGeometry() PxShape.getPlaneGeometry() PxTransformFromPlaneEquation
    */
    PxPlaneGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Returns true if the geometry is valid.
        
        \return True if the current settings are valid
        */
        isValid :: (this: *PxPlaneGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxPlaneGeometry@physx@@QEBA_NXZ";
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxPlaneGeometry, that: *physx.PxPlaneGeometry) -> void #cpp_method #foreign physx_static "??4PxPlaneGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxPlaneGeometry, that: physx.PxPlaneGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Flags controlling the simulated behavior of the triangle mesh geometry.
    
    Used in ::PxMeshGeometryFlags.
    */
    PxMeshGeometryFlag :: struct {
        Enum :: enum s32 {
            TIGHT_BOUNDS :: 1;
            DOUBLE_SIDED :: 2;

            eTIGHT_BOUNDS :: TIGHT_BOUNDS;
            eDOUBLE_SIDED :: DOUBLE_SIDED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxMeshGeometryFlag.
    
    \see PxMeshGeometryFlag
    */
    PxMeshGeometryFlags :: PxFlags(PxMeshGeometryFlag.Enum, PxU8);

    /*
    \brief Triangle mesh geometry class.
    
    This class unifies a mesh object with a scaling transform, and
    lets the combined object be used anywhere a PxGeometry is needed.
    
    The scaling is a transform along arbitrary axes contained in the scale object.
    The vertices of the mesh in geometry (or shape) space is the
    PxMeshScale::toMat33() transform, multiplied by the vertex space vertices
    in the PxTriangleMeshGeometry object.
    */
    PxTriangleMeshGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Constructor. By default creates an empty object with a NULL mesh and identity scale.
        
        \param[in] mesh		Mesh pointer. May be NULL, though this will not make the object valid for shape construction.
        \param[in] scaling	Scale factor.
        \param[in] flags	Mesh flags.
        */
        Constructor :: (this: *PxTriangleMeshGeometry, mesh: *PxTriangleMesh = null, scaling: *PxMeshScale, flags: PxMeshGeometryFlags = PxMeshGeometryFlags.{}) -> void #cpp_method #foreign physx_static "??0PxTriangleMeshGeometry@physx@@QEAA@PEAVPxTriangleMesh@1@AEBVPxMeshScale@1@V?$PxFlags@W4Enum@PxMeshGeometryFlag@physx@@E@1@@Z";
        Constructor :: (this: *PxTriangleMeshGeometry, mesh: *PxTriangleMesh = null, scaling: PxMeshScale = PxMeshScale.{}, flags: PxMeshGeometryFlags = PxMeshGeometryFlags.{}) #no_context {
            Constructor(this, mesh, *scaling, flags);
        }

        /*
        \brief Copy constructor.
        
        \param[in] that		Other object
        */
        CopyConstructor :: (this: *PxTriangleMeshGeometry, that: *PxTriangleMeshGeometry) -> void #cpp_method #foreign physx_static "??0PxTriangleMeshGeometry@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxTriangleMeshGeometry, that: PxTriangleMeshGeometry) #no_context {
            CopyConstructor(this, *that);
        }

        /*
        \brief Returns true if the geometry is valid.
        
        \return  True if the current settings are valid for shape creation.
        
        \note A valid triangle mesh has a positive scale value in each direction (scale.scale.x > 0, scale.scale.y > 0, scale.scale.z > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a triangle mesh that has zero extents in any direction.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxTriangleMeshGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxTriangleMeshGeometry@physx@@QEBA_NXZ";

        scale:            PxMeshScale; //!< The scaling transformation.
        meshFlags:        PxMeshGeometryFlags; //!< Mesh flags.
        paddingFromFlags: PxPadding(UnknownTemplateArgumentPlaceholder) = 3; //!< padding for mesh flags
        triangleMesh:     *PxTriangleMesh; //!< A reference to the mesh object.
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxTriangleMeshGeometry, that: *physx.PxTriangleMeshGeometry) -> void #cpp_method #foreign physx_static "??4PxTriangleMeshGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxTriangleMeshGeometry, that: physx.PxTriangleMeshGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Height field geometry class.
    
    This class allows to create a scaled height field geometry instance.
    
    There is a minimum allowed value for Y and XZ scaling - PX_MIN_HEIGHTFIELD_XZ_SCALE, heightfield creation will fail if XZ value is below this value.
    */
    PxHeightFieldGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Constructor.
        */
        Constructor :: (this: *PxHeightFieldGeometry, hf: *PxHeightField = null, flags: PxMeshGeometryFlags, heightScale_: PxReal = 1.0, rowScale_: PxReal = 1.0, columnScale_: PxReal = 1.0) -> void #cpp_method #foreign physx_static "??0PxHeightFieldGeometry@physx@@QEAA@PEAVPxHeightField@1@V?$PxFlags@W4Enum@PxMeshGeometryFlag@physx@@E@1@MMM@Z";

        /*
        \brief Copy constructor.
        
        \param[in] that		Other object
        */
        CopyConstructor :: (this: *PxHeightFieldGeometry, that: *PxHeightFieldGeometry) -> void #cpp_method #foreign physx_static "??0PxHeightFieldGeometry@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxHeightFieldGeometry, that: PxHeightFieldGeometry) #no_context {
            CopyConstructor(this, *that);
        }

        /*
        \brief Returns true if the geometry is valid.
        
        \return True if the current settings are valid
        
        \note A valid height field has a positive scale value in each direction (heightScale > 0, rowScale > 0, columnScale > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a height field that has zero extents in any direction.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxHeightFieldGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxHeightFieldGeometry@physx@@QEBA_NXZ";

        /*
        \brief The height field data.
        */
        heightField:      *PxHeightField;

        /*
        \brief The scaling factor for the height field in vertical direction (y direction in local space).
        */
        heightScale:      PxReal;

        /*
        \brief The scaling factor for the height field in the row direction (x direction in local space).
        */
        rowScale:         PxReal;

        /*
        \brief The scaling factor for the height field in the column direction (z direction in local space).
        */
        columnScale:      PxReal;

        /*
        \brief Flags to specify some collision properties for the height field.
        */
        heightFieldFlags: PxMeshGeometryFlags;

        paddingFromFlags: PxPadding(UnknownTemplateArgumentPlaceholder) = 3; //!< padding for mesh flags.
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxHeightFieldGeometry, that: *physx.PxHeightFieldGeometry) -> void #cpp_method #foreign physx_static "??4PxHeightFieldGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxHeightFieldGeometry, that: physx.PxHeightFieldGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Identifies dirty particle buffers that need to be updated in the particle system.
    
    This flag can be used mark the device user buffers that are dirty and need to be written to the particle system.
    */
    PxParticleBufferFlag :: struct {
        Enum :: enum s32 {
            NONE                 :: 0;

            UPDATE_POSITION      :: 1;
            UPDATE_VELOCITY      :: 2;
            UPDATE_PHASE         :: 4;
            UPDATE_RESTPOSITION  :: 8;
            UPDATE_CLOTH         :: 32;
            UPDATE_RIGID         :: 64;
            UPDATE_DIFFUSE_PARAM :: 128;
            UPDATE_ATTACHMENTS   :: 256;

            ALL                  :: 495;

            eNONE                 :: NONE;

            eUPDATE_POSITION      :: UPDATE_POSITION;
            eUPDATE_VELOCITY      :: UPDATE_VELOCITY;
            eUPDATE_PHASE         :: UPDATE_PHASE;
            eUPDATE_RESTPOSITION  :: UPDATE_RESTPOSITION;
            eUPDATE_CLOTH         :: UPDATE_CLOTH;
            eUPDATE_RIGID         :: UPDATE_RIGID;
            eUPDATE_DIFFUSE_PARAM :: UPDATE_DIFFUSE_PARAM;
            eUPDATE_ATTACHMENTS   :: UPDATE_ATTACHMENTS;

            eALL                  :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxParticleBufferFlags :: PxFlags(PxParticleBufferFlag.Enum, PxU32);

    /*
    \brief A pair of particle buffer unique id and GPU particle system index.
    
    \see PxScene::applyParticleBufferData
    
    \deprecated There is no replacement.
    */
    PxGpuParticleBufferIndexPair :: struct {
        systemIndex: PxU32; // gpu particle system index	
        bufferIndex: PxU32; // particle buffer unique id
    }

    /*
    \brief Identifies per-particle behavior for a PxParticleSystem.
    
    See #PxPBDParticleSystem::createPhase().
    */
    PxParticlePhaseFlag :: struct {
        Enum :: enum s32 {
            GroupMask         :: 1048575;
            FlagsMask         :: -1048576;

            SelfCollide       :: 1048576;
            SelfCollideFilter :: 2097152;
            Fluid             :: 4194304;

            eParticlePhaseGroupMask         :: GroupMask;
            eParticlePhaseFlagsMask         :: FlagsMask;

            eParticlePhaseSelfCollide       :: SelfCollide;
            eParticlePhaseSelfCollideFilter :: SelfCollideFilter;
            eParticlePhaseFluid             :: Fluid;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxParticlePhaseFlags :: PxFlags(PxParticlePhaseFlag.Enum, PxU32);

    /*
    \brief Collection of flags describing the actions to take for a collision pair.
    
    \see PxPairFlags PxSimulationFilterShader.filter() PxSimulationFilterCallback
    */
    PxPairFlag :: struct {
        Enum :: enum s32 {
            SOLVE_CONTACT                   :: 1;

            MODIFY_CONTACTS                 :: 2;

            NOTIFY_TOUCH_FOUND              :: 4;

            NOTIFY_TOUCH_PERSISTS           :: 8;

            NOTIFY_TOUCH_LOST               :: 16;

            NOTIFY_TOUCH_CCD                :: 32;

            NOTIFY_THRESHOLD_FORCE_FOUND    :: 64;

            NOTIFY_THRESHOLD_FORCE_PERSISTS :: 128;

            NOTIFY_THRESHOLD_FORCE_LOST     :: 256;

            NOTIFY_CONTACT_POINTS           :: 512;

            DETECT_DISCRETE_CONTACT         :: 1024;

            DETECT_CCD_CONTACT              :: 2048;

            PRE_SOLVER_VELOCITY             :: 4096;

            POST_SOLVER_VELOCITY            :: 8192;

            CONTACT_EVENT_POSE              :: 16384;

            NEXT_FREE                       :: 32768;

            CONTACT_DEFAULT                 :: 1025;

            TRIGGER_DEFAULT                 :: 1044;

            eSOLVE_CONTACT                   :: SOLVE_CONTACT;

            eMODIFY_CONTACTS                 :: MODIFY_CONTACTS;

            eNOTIFY_TOUCH_FOUND              :: NOTIFY_TOUCH_FOUND;

            eNOTIFY_TOUCH_PERSISTS           :: NOTIFY_TOUCH_PERSISTS;

            eNOTIFY_TOUCH_LOST               :: NOTIFY_TOUCH_LOST;

            eNOTIFY_TOUCH_CCD                :: NOTIFY_TOUCH_CCD;

            eNOTIFY_THRESHOLD_FORCE_FOUND    :: NOTIFY_THRESHOLD_FORCE_FOUND;

            eNOTIFY_THRESHOLD_FORCE_PERSISTS :: NOTIFY_THRESHOLD_FORCE_PERSISTS;

            eNOTIFY_THRESHOLD_FORCE_LOST     :: NOTIFY_THRESHOLD_FORCE_LOST;

            eNOTIFY_CONTACT_POINTS           :: NOTIFY_CONTACT_POINTS;

            eDETECT_DISCRETE_CONTACT         :: DETECT_DISCRETE_CONTACT;

            eDETECT_CCD_CONTACT              :: DETECT_CCD_CONTACT;

            ePRE_SOLVER_VELOCITY             :: PRE_SOLVER_VELOCITY;

            ePOST_SOLVER_VELOCITY            :: POST_SOLVER_VELOCITY;

            eCONTACT_EVENT_POSE              :: CONTACT_EVENT_POSE;

            eNEXT_FREE                       :: NEXT_FREE;

            eCONTACT_DEFAULT                 :: CONTACT_DEFAULT;

            eTRIGGER_DEFAULT                 :: TRIGGER_DEFAULT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxPairFlag.
    
    \see PxPairFlag
    */
    PxPairFlags :: PxFlags(PxPairFlag.Enum, PxU16);
    operator| :: (a: PxPairFlag.Enum, b: PxPairFlag.Enum) -> PxFlags(PxPairFlag.Enum, PxU16) #foreign physx_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxPairFlag@physx@@G@0@W4Enum@PxPairFlag@0@0@Z";
    operator~ :: (a: PxPairFlag.Enum) -> PxFlags(PxPairFlag.Enum, PxU16) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxPairFlag@physx@@G@0@W4Enum@PxPairFlag@0@@Z";

    /*
    \brief Collection of flags describing the filter actions to take for a collision pair.
    
    \see PxFilterFlags PxSimulationFilterShader PxSimulationFilterCallback
    */
    PxFilterFlag :: struct {
        Enum :: enum s32 {
            KILL     :: 1;

            SUPPRESS :: 2;

            CALLBACK :: 4;

            NOTIFY   :: 12;

            DEFAULT  :: 0;

            eKILL     :: KILL;

            eSUPPRESS :: SUPPRESS;

            eCALLBACK :: CALLBACK;

            eNOTIFY   :: NOTIFY;

            eDEFAULT  :: DEFAULT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxFilterFlag.
    
    \see PxFilterFlag
    */
    PxFilterFlags :: PxFlags(PxFilterFlag.Enum, PxU16);
    operator| :: (a: PxFilterFlag.Enum, b: PxFilterFlag.Enum) -> PxFlags(PxFilterFlag.Enum, PxU16) #foreign physx_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxFilterFlag@physx@@G@0@W4Enum@PxFilterFlag@0@0@Z";

    /*
    \brief PxFilterData is user-definable data which gets passed into the collision filtering shader and/or callback.
    
    \see PxShape.setSimulationFilterData() PxShape.getSimulationFilterData()  PxSimulationFilterShader PxSimulationFilterCallback
    */
    PxFilterData :: struct {
        Constructor :: (this: *PxFilterData, unknown0: PxEMPTY) -> void #cpp_method #foreign physx_static "??0PxFilterData@physx@@QEAA@W4PxEMPTY@1@@Z";

        /*
        \brief Default constructor.
        */
        Constructor :: (this: *PxFilterData) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxFilterData@physx@@QEAA@XZ";

        /*
        \brief Copy constructor.
        */
        CopyConstructor :: (this: *PxFilterData, fd: *PxFilterData) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxFilterData@physx@@QEAA@AEBU01@@Z";
        CopyConstructor :: (this: *PxFilterData, fd: PxFilterData) #no_context {
            CopyConstructor(this, *fd);
        }

        word0: PxU32;
        word1: PxU32;
        word2: PxU32;
        word3: PxU32;
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxFilterData, fd: *physx.PxFilterData) -> void #cpp_method #foreign physx_static "??4PxFilterData@physx@@QEAAXAEBU01@@Z";
    operator_assign :: (this: *physx.PxFilterData, fd: physx.PxFilterData) #no_context {
        operator_assign(this, *fd);
    }

    /*
    \brief Identifies each type of filter object.
    
    \see PxGetFilterObjectType()
    */
    PxFilterObjectType :: struct {
        Enum :: enum s32 {
            RIGID_STATIC   :: 0;

            RIGID_DYNAMIC  :: 1;

            ARTICULATION   :: 2;

            PARTICLESYSTEM :: 3;

            SOFTBODY       :: 4;

            FEMCLOTH       :: 5;

            HAIRSYSTEM     :: 6;

            MAX_TYPE_COUNT :: 16;

            UNDEFINED      :: 15;

            eRIGID_STATIC   :: RIGID_STATIC;

            eRIGID_DYNAMIC  :: RIGID_DYNAMIC;

            eARTICULATION   :: ARTICULATION;

            ePARTICLESYSTEM :: PARTICLESYSTEM;

            eSOFTBODY       :: SOFTBODY;

            eFEMCLOTH       :: FEMCLOTH;

            eHAIRSYSTEM     :: HAIRSYSTEM;

            eMAX_TYPE_COUNT :: MAX_TYPE_COUNT;

            eUNDEFINED      :: UNDEFINED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    // For internal use only
    PxFilterObjectFlag :: struct {
        Enum :: enum s32 {
            KINEMATIC :: 16;
            TRIGGER   :: 32;

            NEXT_FREE :: 64;

            eKINEMATIC :: KINEMATIC;
            eTRIGGER   :: TRIGGER;

            eNEXT_FREE :: NEXT_FREE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Structure which gets passed into the collision filtering shader and/or callback providing additional information on objects of a collision pair
    
    \see PxSimulationFilterShader PxSimulationFilterCallback getActorType() PxFilterObjectIsKinematic() PxFilterObjectIsTrigger()
    */
    PxFilterObjectAttributes :: PxU32;

    /*
    \brief Extract filter object type from the filter attributes of a collision pair object
    
    \param[in] attr The filter attribute of a collision pair object
    \return The type of the collision pair object.
    
    \see PxFilterObjectType
    */
    PxGetFilterObjectType :: (attr: PxFilterObjectAttributes) -> PxFilterObjectType.Enum #foreign physx_static "?PxGetFilterObjectType@physx@@YA?AW4Enum@PxFilterObjectType@1@I@Z";

    /*
    \brief Specifies whether the collision object belongs to a kinematic rigid body
    
    \param[in] attr The filter attribute of a collision pair object
    \return True if the object belongs to a kinematic rigid body, else false
    
    \see PxRigidBodyFlag::eKINEMATIC
    */
    PxFilterObjectIsKinematic :: (attr: PxFilterObjectAttributes) -> bool #foreign physx_static "?PxFilterObjectIsKinematic@physx@@YA_NI@Z";

    /*
    \brief Specifies whether the collision object is a trigger shape
    
    \param[in] attr The filter attribute of a collision pair object
    \return True if the object is a trigger shape, else false
    
    \see PxShapeFlag::eTRIGGER_SHAPE
    */
    PxFilterObjectIsTrigger :: (attr: PxFilterObjectAttributes) -> bool #foreign physx_static "?PxFilterObjectIsTrigger@physx@@YA_NI@Z";

    /*
    \brief Filter method to specify how a pair of potentially colliding objects should be processed.
    
    Collision filtering is a mechanism to specify how a pair of potentially colliding objects should be processed by the
    simulation. A pair of objects is potentially colliding if the bounding volumes of the two objects overlap.
    In short, a collision filter decides whether a collision pair should get processed, temporarily ignored or discarded.
    If a collision pair should get processed, the filter can additionally specify how it should get processed, for instance,
    whether contacts should get resolved, which callbacks should get invoked or which reports should be sent etc.
    The function returns the PxFilterFlag flags and sets the PxPairFlag flags to define what the simulation should do with the given collision pair.
    
    \note A default implementation of a filter shader is provided in the PhysX extensions library, see #PxDefaultSimulationFilterShader.
    
    This methods gets called when:
    \li The bounding volumes of two objects start to overlap.
    \li The bounding volumes of two objects overlap and the filter data or filter attributes of one of the objects changed
    \li A re-filtering was forced through resetFiltering() (see #PxScene::resetFiltering())
    \li Filtering is requested in scene queries
    
    \note Certain pairs of objects are always ignored and this method does not get called. This is the case for the
    following pairs:
    
    \li Pair of static rigid actors
    \li A static rigid actor and a kinematic actor (unless one is a trigger or if explicitly enabled through PxPairFilteringMode::eKEEP)
    \li Two kinematic actors (unless one is a trigger or if explicitly enabled through PxPairFilteringMode::eKEEP)
    \li Two jointed rigid bodies and the joint was defined to disable collision
    \li Two articulation links if connected through an articulation joint
    
    \note This is a performance critical method and should be stateless. You should neither access external objects
    from within this method nor should you call external methods that are not inlined. If you need a more complex
    logic to filter a collision pair then use the filter callback mechanism for this pair (see #PxSimulationFilterCallback,
    #PxFilterFlag::eCALLBACK, #PxFilterFlag::eNOTIFY).
    
    \param[in] attributes0 The filter attribute of the first object
    \param[in] filterData0 The custom filter data of the first object
    \param[in] attributes1 The filter attribute of the second object
    \param[in] filterData1 The custom filter data of the second object
    \param[out] pairFlags Flags giving additional information on how an accepted pair should get processed
    \param[in] constantBlock The constant global filter data (see #PxSceneDesc.filterShaderData)
    \param[in] constantBlockSize Size of the global filter data (see #PxSceneDesc.filterShaderDataSize)
    \return Filter flags defining whether the pair should be discarded, temporarily ignored, processed and whether the
    filter callback should get invoked for this pair.
    
    \see PxSimulationFilterCallback PxFilterData PxFilterObjectAttributes PxFilterFlag PxFilterFlags PxPairFlag PxPairFlags PxSceneDesc.filterShader
    */
    PxSimulationFilterShader :: #type (attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, pairFlags: *PxPairFlags, constantBlock: *void, constantBlockSize: PxU32) -> PxFilterFlags #c_call;

    /*
    \brief Filter callback to specify handling of collision pairs.
    
    This class is provided to implement more complex and flexible collision pair filtering logic, for instance, taking
    the state of the user application into account. Filter callbacks also give the user the opportunity to track collision
    pairs and update their filter state.
    
    You might want to check the documentation on #PxSimulationFilterShader as well since it includes more general information
    on filtering.
    
    \note SDK state should not be modified from within the callbacks. In particular objects should not
    be created or destroyed. If state modification is needed then the changes should be stored to a buffer
    and performed after the simulation step.
    
    \note The callbacks may execute in user threads or simulation threads, possibly simultaneously. The corresponding objects
    may have been deleted by the application earlier in the frame. It is the application's responsibility to prevent race conditions
    arising from using the SDK API in the callback while an application thread is making write calls to the scene, and to ensure that
    the callbacks are thread-safe. Return values which depend on when the callback is called during the frame will introduce nondeterminism
    into the simulation.
    
    \see PxSceneDesc.filterCallback PxSimulationFilterShader
    */
    PxSimulationFilterCallback :: struct {
        vtable: *PxSimulationFilterCallback_VTable;
    }
    PxSimulationFilterCallback_VTable :: struct #type_info_none {
        pairFound: (this: *PxSimulationFilterCallback, pairID: PxU64, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, a0: *PxActor, s0: *PxShape, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, a1: *PxActor, s1: *PxShape, pairFlags: *PxPairFlags) -> PxFilterFlags #cpp_method;

        pairLost: (this: *PxSimulationFilterCallback, pairID: PxU64, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, objectRemoved: bool) -> void #cpp_method;

        statusChange: (this: *PxSimulationFilterCallback, pairID: *PxU64, pairFlags: *PxPairFlags, filterFlags: *PxFilterFlags) -> bool #cpp_method;

        Destructor: (this: *PxSimulationFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSimulationFilterCallback_pairFound :: inline (this: *PxSimulationFilterCallback, pairID: PxU64, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, a0: *PxActor, s0: *PxShape, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, a1: *PxActor, s1: *PxShape, pairFlags: *PxPairFlags) -> PxFilterFlags { return this.vtable.pairFound(this, pairID, attributes0, filterData0, a0, s0, attributes1, filterData1, a1, s1, pairFlags); }

    PxSimulationFilterCallback_pairLost :: inline (this: *PxSimulationFilterCallback, pairID: PxU64, attributes0: PxFilterObjectAttributes, filterData0: PxFilterData, attributes1: PxFilterObjectAttributes, filterData1: PxFilterData, objectRemoved: bool) { this.vtable.pairLost(this, pairID, attributes0, filterData0, attributes1, filterData1, objectRemoved); }

    PxSimulationFilterCallback_statusChange :: inline (this: *PxSimulationFilterCallback, pairID: *PxU64, pairFlags: *PxPairFlags, filterFlags: *PxFilterFlags) -> bool { return this.vtable.statusChange(this, pairID, pairFlags, filterFlags); }

    PxSimulationFilterCallback_Destructor :: inline (this: *PxSimulationFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSimulationFilterCallback) -> *PxSimulationFilterCallback_VTable { return obj.vtable; }


    PxPairFilteringMode :: struct {
        Enum :: enum s32 {
            KEEP     :: 0;

            SUPPRESS :: 1;

            KILL     :: 2;

            DEFAULT  :: 1;

            eKEEP     :: KEEP;

            eSUPPRESS :: SUPPRESS;

            eKILL     :: KILL;

            eDEFAULT  :: DEFAULT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Struct for storing a particle/vertex - rigid filter pair with comparison operators
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    */
    PxParticleRigidFilterPair :: struct {
        mID0: PxU64; //!< Rigid node index
        mID1: PxU64; //!< Particle/vertex id
    }

    /*
    \brief An ID to identify different clients for multiclient support.
    
    \see PxScene::createClient()
    */
    PxClientID :: PxU8;

    /*
    \brief The predefined default PxClientID value.
    
    \see PxClientID PxScene::createClient()
    */
    PX_DEFAULT_CLIENT: PxClientID : 0;

    /*
    \brief Group index which allows to specify 1- or 2-way interaction
    */
    PxDominanceGroup :: PxU8;

    /*
    \brief Flags which control the behavior of an actor.
    
    \see PxActorFlags PxActor PxActor.setActorFlag() PxActor.getActorFlags()
    */
    PxActorFlag :: struct {
        Enum :: enum s32 {
            VISUALIZATION       :: 1;

            DISABLE_GRAVITY     :: 2;

            SEND_SLEEP_NOTIFIES :: 4;

            DISABLE_SIMULATION  :: 8;

            eVISUALIZATION       :: VISUALIZATION;

            eDISABLE_GRAVITY     :: DISABLE_GRAVITY;

            eSEND_SLEEP_NOTIFIES :: SEND_SLEEP_NOTIFIES;

            eDISABLE_SIMULATION  :: DISABLE_SIMULATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxActorFlag.
    
    \see PxActorFlag
    */
    PxActorFlags :: PxFlags(PxActorFlag.Enum, PxU8);
    operator~ :: (a: PxActorFlag.Enum) -> PxFlags(PxActorFlag.Enum, PxU8) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxActorFlag@physx@@E@0@W4Enum@PxActorFlag@0@@Z";

    /*
    \brief Identifies each type of actor.
    \see PxActor
    */
    PxActorType :: struct {
        Enum :: enum s32 {
            RIGID_STATIC       :: 0;

            RIGID_DYNAMIC      :: 1;

            ARTICULATION_LINK  :: 2;

            SOFTBODY           :: 3;

            FEMCLOTH           :: 4;

            PBD_PARTICLESYSTEM :: 5;

            HAIRSYSTEM         :: 6;

            ACTOR_COUNT        :: 7;

            ACTOR_FORCE_DWORD  :: 2147483647;

            eRIGID_STATIC       :: RIGID_STATIC;

            eRIGID_DYNAMIC      :: RIGID_DYNAMIC;

            eARTICULATION_LINK  :: ARTICULATION_LINK;

            eSOFTBODY           :: SOFTBODY;

            eFEMCLOTH           :: FEMCLOTH;

            ePBD_PARTICLESYSTEM :: PBD_PARTICLESYSTEM;

            eHAIRSYSTEM         :: HAIRSYSTEM;

            eACTOR_COUNT        :: ACTOR_COUNT;

            eACTOR_FORCE_DWORD  :: ACTOR_FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief PxActor is the base class for the main simulation objects in the physics SDK.
    
    The actor is owned by and contained in a PxScene.
    */
    PxActor :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxActor, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxActor@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxActor, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxActor@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxactor_vtable: *PxActor_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxActor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxActor@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxActor, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxActor@physx@@MEBA_NPEBD@Z";
    }
    PxActor_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getType: (this: *PxActor) -> PxActorType.Enum #cpp_method;

        getScene: (this: *PxActor) -> *PxScene #cpp_method;

        setName: (this: *PxActor, name: *u8) -> void #cpp_method;

        getName: (this: *PxActor) -> *u8 #cpp_method;

        getWorldBounds: (this: *PxActor, inflation: float = 1.01) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        setActorFlag: (this: *PxActor, flag: PxActorFlag.Enum, value: bool) -> void #cpp_method;

        setActorFlags: (this: *PxActor, inFlags: PxActorFlags) -> void #cpp_method;

        getActorFlags: (this: *PxActor) -> PxActorFlags #cpp_method;

        setDominanceGroup: (this: *PxActor, dominanceGroup: PxDominanceGroup) -> void #cpp_method;

        getDominanceGroup: (this: *PxActor) -> PxDominanceGroup #cpp_method;

        setOwnerClient: (this: *PxActor, inClient: PxClientID) -> void #cpp_method;

        getOwnerClient: (this: *PxActor) -> PxClientID #cpp_method;

        getAggregate: (this: *PxActor) -> *PxAggregate #cpp_method;
    }

    PxActor_getType :: inline (this: *PxActor) -> PxActorType.Enum { return this.pxactor_vtable.getType(this); }

    PxActor_getScene :: inline (this: *PxActor) -> *PxScene { return this.pxactor_vtable.getScene(this); }

    PxActor_setName :: inline (this: *PxActor, name: *u8) { this.pxactor_vtable.setName(this, name); }

    PxActor_getName :: inline (this: *PxActor) -> *u8 { return this.pxactor_vtable.getName(this); }

    PxActor_getWorldBounds :: inline (this: *PxActor, inflation: float = 1.01) -> PxBounds3 { return this.pxactor_vtable.getWorldBounds(this, inflation); }

    PxActor_setActorFlag :: inline (this: *PxActor, flag: PxActorFlag.Enum, value: bool) { this.pxactor_vtable.setActorFlag(this, flag, value); }

    PxActor_setActorFlags :: inline (this: *PxActor, inFlags: PxActorFlags) { this.pxactor_vtable.setActorFlags(this, inFlags); }

    PxActor_getActorFlags :: inline (this: *PxActor) -> PxActorFlags { return this.pxactor_vtable.getActorFlags(this); }

    PxActor_setDominanceGroup :: inline (this: *PxActor, dominanceGroup: PxDominanceGroup) { this.pxactor_vtable.setDominanceGroup(this, dominanceGroup); }

    PxActor_getDominanceGroup :: inline (this: *PxActor) -> PxDominanceGroup { return this.pxactor_vtable.getDominanceGroup(this); }

    PxActor_setOwnerClient :: inline (this: *PxActor, inClient: PxClientID) { this.pxactor_vtable.setOwnerClient(this, inClient); }

    PxActor_getOwnerClient :: inline (this: *PxActor) -> PxClientID { return this.pxactor_vtable.getOwnerClient(this); }

    PxActor_getAggregate :: inline (this: *PxActor) -> *PxAggregate { return this.pxactor_vtable.getAggregate(this); }

    vtable :: (obj: *PxActor) -> *PxActor_VTable { return obj.pxactor_vtable; }


    PxGpuParticleSystem :: struct {}

    /*
    \brief Container to hold a pair of corresponding device and host pointers. These pointers should point to GPU / CPU mirrors of the same data, but
    this is not enforced.
    */
    PxGpuMirroredPointer :: struct(_Type: Type) {
        mDevicePtr: *Type;
        mHostPtr:   *Type;
    }

    /*
    \brief Particle system callback base class to schedule work that should be done before, while or after the particle system updates.
    A call to fetchResultsParticleSystem() on the PxScene will synchronize the work such that the caller knows that all tasks of this callback completed.
    */
    PxParticleSystemCallback :: struct {
        vtable: *PxParticleSystemCallback_VTable;
    }
    PxParticleSystemCallback_VTable :: struct #type_info_none {
        onBegin: (this: *PxParticleSystemCallback, gpuParticleSystem: *PxGpuMirroredPointer(PxGpuParticleSystem), stream: CUstream) -> void #cpp_method;

        onAdvance: (this: *PxParticleSystemCallback, gpuParticleSystem: *PxGpuMirroredPointer(PxGpuParticleSystem), stream: CUstream) -> void #cpp_method;

        onPostSolve: (this: *PxParticleSystemCallback, gpuParticleSystem: *PxGpuMirroredPointer(PxGpuParticleSystem), stream: CUstream) -> void #cpp_method;

        Destructor: (this: *PxParticleSystemCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxParticleSystemCallback_onBegin :: inline (this: *PxParticleSystemCallback, gpuParticleSystem: *PxGpuMirroredPointer(PxGpuParticleSystem), stream: CUstream) { this.vtable.onBegin(this, gpuParticleSystem, stream); }

    PxParticleSystemCallback_onAdvance :: inline (this: *PxParticleSystemCallback, gpuParticleSystem: *PxGpuMirroredPointer(PxGpuParticleSystem), stream: CUstream) { this.vtable.onAdvance(this, gpuParticleSystem, stream); }

    PxParticleSystemCallback_onPostSolve :: inline (this: *PxParticleSystemCallback, gpuParticleSystem: *PxGpuMirroredPointer(PxGpuParticleSystem), stream: CUstream) { this.vtable.onPostSolve(this, gpuParticleSystem, stream); }

    PxParticleSystemCallback_Destructor :: inline (this: *PxParticleSystemCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxParticleSystemCallback) -> *PxParticleSystemCallback_VTable { return obj.vtable; }


    /*
    \brief Special callback that forwards calls to arbitrarily many sub-callbacks
    */
    PxMultiCallback :: struct {
        #as using pxparticlesystemcallback: PxParticleSystemCallback;

        mCallbacks: PxArray(*PxParticleSystemCallback);
    }

    /*
    \brief Flags which control the behaviour of a particle system.
    
    See #PxPBDParticleSystem::setParticleFlag(), #PxPBDParticleSystem::setParticleFlags(), #PxPBDParticleSystem::getParticleFlags()
    */
    PxParticleFlag :: struct {
        Enum :: enum s32 {
            DISABLE_SELF_COLLISION  :: 1;
            DISABLE_RIGID_COLLISION :: 2;
            FULL_DIFFUSE_ADVECTION  :: 4;
            ENABLE_SPECULATIVE_CCD  :: 8;

            eDISABLE_SELF_COLLISION  :: DISABLE_SELF_COLLISION;
            eDISABLE_RIGID_COLLISION :: DISABLE_RIGID_COLLISION;
            eFULL_DIFFUSE_ADVECTION  :: FULL_DIFFUSE_ADVECTION;
            eENABLE_SPECULATIVE_CCD  :: ENABLE_SPECULATIVE_CCD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxParticleFlags :: PxFlags(PxParticleFlag.Enum, PxU32);

    /*
    \brief Collection of flags providing a mechanism to lock motion along a specific axis.
    
    \see PxParticleSystem.setParticleLockFlag(), PxParticleSystem.getParticleLockFlags()
    */
    PxParticleLockFlag :: struct {
        Enum :: enum s32 {
            X :: 1;
            Y :: 2;
            Z :: 4;

            eLOCK_X :: X;
            eLOCK_Y :: Y;
            eLOCK_Z :: Z;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxParticleLockFlags :: PxFlags(PxParticleLockFlag.Enum, PxU8);
    operator~ :: (a: PxParticleLockFlag.Enum) -> PxFlags(PxParticleLockFlag.Enum, PxU8) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxParticleLockFlag@physx@@E@0@W4Enum@PxParticleLockFlag@0@@Z";

    /*
    \brief A particle system that uses the position based dynamics(PBD) solver.
    
    The position based dynamics solver for particle systems supports behaviors like
    fluid, cloth, inflatables etc.
    
    */
    PxPBDParticleSystem :: struct {
        #as using pxactor: PxActor;

        Constructor :: (this: *PxPBDParticleSystem, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxPBDParticleSystem@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxPBDParticleSystem, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxPBDParticleSystem@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxactor; pxpbdparticlesystem_vtable: *PxPBDParticleSystem_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxPBDParticleSystem, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxPBDParticleSystem@physx@@UEAA@XZ";

        virtual_getConcreteTypeName :: (this: *PxPBDParticleSystem) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxPBDParticleSystem@physx@@UEBAPEBDXZ";

        virtual_isKindOf :: (this: *PxPBDParticleSystem, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxPBDParticleSystem@physx@@MEBA_NPEBD@Z";
    }
    PxPBDParticleSystem_VTable :: struct #type_info_none {
        using pxactor: PxActor_VTable;
        setSolverIterationCounts: (this: *PxPBDParticleSystem, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) -> void #cpp_method;

        getSolverIterationCounts: (this: *PxPBDParticleSystem, minPositionIters: *PxU32, minVelocityIters: *PxU32) -> void #cpp_method;

        getSimulationFilterData: (this: *PxPBDParticleSystem) -> PxFilterData #cpp_method #cpp_return_type_is_non_pod;

        setSimulationFilterData: (this: *PxPBDParticleSystem, data: *PxFilterData) -> void #cpp_method;

        setParticleFlag: (this: *PxPBDParticleSystem, flag: PxParticleFlag.Enum, val: bool) -> void #cpp_method;

        setParticleFlags: (this: *PxPBDParticleSystem, flags: PxParticleFlags) -> void #cpp_method;

        getParticleFlags: (this: *PxPBDParticleSystem) -> PxParticleFlags #cpp_method;

        setMaxDepenetrationVelocity: (this: *PxPBDParticleSystem, maxDepenetrationVelocity: PxReal) -> void #cpp_method;

        getMaxDepenetrationVelocity: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        setMaxVelocity: (this: *PxPBDParticleSystem, maxVelocity: PxReal) -> void #cpp_method;

        getMaxVelocity: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        getCudaContextManager: (this: *PxPBDParticleSystem) -> *PxCudaContextManager #cpp_method;

        setRestOffset: (this: *PxPBDParticleSystem, restOffset: PxReal) -> void #cpp_method;

        getRestOffset: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        setContactOffset: (this: *PxPBDParticleSystem, contactOffset: PxReal) -> void #cpp_method;

        getContactOffset: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        setParticleContactOffset: (this: *PxPBDParticleSystem, particleContactOffset: PxReal) -> void #cpp_method;

        getParticleContactOffset: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        setSolidRestOffset: (this: *PxPBDParticleSystem, solidRestOffset: PxReal) -> void #cpp_method;

        getSolidRestOffset: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        addRigidAttachment: (this: *PxPBDParticleSystem, actor: *PxRigidActor) -> void #cpp_method;

        removeRigidAttachment: (this: *PxPBDParticleSystem, actor: *PxRigidActor) -> void #cpp_method;

        enableCCD: (this: *PxPBDParticleSystem, enable: bool) -> void #cpp_method;

        getParticleLockFlags: (this: *PxPBDParticleSystem) -> PxParticleLockFlags #cpp_method;

        setParticleLockFlag: (this: *PxPBDParticleSystem, flag: PxParticleLockFlag.Enum, value: bool) -> void #cpp_method;

        setParticleLockFlags: (this: *PxPBDParticleSystem, flags: PxParticleLockFlags) -> void #cpp_method;

        createPhase: (this: *PxPBDParticleSystem, material: *PxPBDMaterial, flags: PxParticlePhaseFlags) -> PxU32 #cpp_method;

        getNbParticleMaterials: (this: *PxPBDParticleSystem) -> PxU32 #cpp_method;

        getParticleMaterials: (this: *PxPBDParticleSystem, userBuffer: **PxPBDMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        setParticleSystemCallback: (this: *PxPBDParticleSystem, callback: *PxParticleSystemCallback) -> void #cpp_method;

        getParticleSystemCallback: (this: *PxPBDParticleSystem) -> *PxParticleSystemCallback #cpp_method;

        addParticleBuffer: (this: *PxPBDParticleSystem, particleBuffer: *PxParticleBuffer) -> void #cpp_method;

        removeParticleBuffer: (this: *PxPBDParticleSystem, particleBuffer: *PxParticleBuffer) -> void #cpp_method;

        getGpuParticleSystemIndex: (this: *PxPBDParticleSystem) -> PxU32 #cpp_method;

        setWind: (this: *PxPBDParticleSystem, wind: *PxVec3) -> void #cpp_method;

        getWind: (this: *PxPBDParticleSystem) -> PxVec3 #cpp_method;

        setFluidBoundaryDensityScale: (this: *PxPBDParticleSystem, fluidBoundaryDensityScale: PxReal) -> void #cpp_method;

        getFluidBoundaryDensityScale: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        setFluidRestOffset: (this: *PxPBDParticleSystem, fluidRestOffset: PxReal) -> void #cpp_method;

        getFluidRestOffset: (this: *PxPBDParticleSystem) -> PxReal #cpp_method;

        setGridSizeX: (this: *PxPBDParticleSystem, gridSizeX: PxU32) -> void #cpp_method;

        getGridSizeX: (this: *PxPBDParticleSystem) -> PxU32 #cpp_method;

        setGridSizeY: (this: *PxPBDParticleSystem, gridSizeY: PxU32) -> void #cpp_method;

        getGridSizeY: (this: *PxPBDParticleSystem) -> PxU32 #cpp_method;

        setGridSizeZ: (this: *PxPBDParticleSystem, gridSizeZ: PxU32) -> void #cpp_method;

        getGridSizeZ: (this: *PxPBDParticleSystem) -> PxU32 #cpp_method;
    }

    PxPBDParticleSystem_setSolverIterationCounts :: inline (this: *PxPBDParticleSystem, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) { this.pxpbdparticlesystem_vtable.setSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxPBDParticleSystem_getSolverIterationCounts :: inline (this: *PxPBDParticleSystem, minPositionIters: *PxU32, minVelocityIters: *PxU32) { this.pxpbdparticlesystem_vtable.getSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxPBDParticleSystem_getSimulationFilterData :: inline (this: *PxPBDParticleSystem) -> PxFilterData { return this.pxpbdparticlesystem_vtable.getSimulationFilterData(this); }

    PxPBDParticleSystem_setSimulationFilterData :: inline (this: *PxPBDParticleSystem, data: *PxFilterData) { this.pxpbdparticlesystem_vtable.setSimulationFilterData(this, data); }

    PxPBDParticleSystem_setParticleFlag :: inline (this: *PxPBDParticleSystem, flag: PxParticleFlag.Enum, val: bool) { this.pxpbdparticlesystem_vtable.setParticleFlag(this, flag, val); }

    PxPBDParticleSystem_setParticleFlags :: inline (this: *PxPBDParticleSystem, flags: PxParticleFlags) { this.pxpbdparticlesystem_vtable.setParticleFlags(this, flags); }

    PxPBDParticleSystem_getParticleFlags :: inline (this: *PxPBDParticleSystem) -> PxParticleFlags { return this.pxpbdparticlesystem_vtable.getParticleFlags(this); }

    PxPBDParticleSystem_setMaxDepenetrationVelocity :: inline (this: *PxPBDParticleSystem, maxDepenetrationVelocity: PxReal) { this.pxpbdparticlesystem_vtable.setMaxDepenetrationVelocity(this, maxDepenetrationVelocity); }

    PxPBDParticleSystem_getMaxDepenetrationVelocity :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getMaxDepenetrationVelocity(this); }

    PxPBDParticleSystem_setMaxVelocity :: inline (this: *PxPBDParticleSystem, maxVelocity: PxReal) { this.pxpbdparticlesystem_vtable.setMaxVelocity(this, maxVelocity); }

    PxPBDParticleSystem_getMaxVelocity :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getMaxVelocity(this); }

    PxPBDParticleSystem_getCudaContextManager :: inline (this: *PxPBDParticleSystem) -> *PxCudaContextManager { return this.pxpbdparticlesystem_vtable.getCudaContextManager(this); }

    PxPBDParticleSystem_setRestOffset :: inline (this: *PxPBDParticleSystem, restOffset: PxReal) { this.pxpbdparticlesystem_vtable.setRestOffset(this, restOffset); }

    PxPBDParticleSystem_getRestOffset :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getRestOffset(this); }

    PxPBDParticleSystem_setContactOffset :: inline (this: *PxPBDParticleSystem, contactOffset: PxReal) { this.pxpbdparticlesystem_vtable.setContactOffset(this, contactOffset); }

    PxPBDParticleSystem_getContactOffset :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getContactOffset(this); }

    PxPBDParticleSystem_setParticleContactOffset :: inline (this: *PxPBDParticleSystem, particleContactOffset: PxReal) { this.pxpbdparticlesystem_vtable.setParticleContactOffset(this, particleContactOffset); }

    PxPBDParticleSystem_getParticleContactOffset :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getParticleContactOffset(this); }

    PxPBDParticleSystem_setSolidRestOffset :: inline (this: *PxPBDParticleSystem, solidRestOffset: PxReal) { this.pxpbdparticlesystem_vtable.setSolidRestOffset(this, solidRestOffset); }

    PxPBDParticleSystem_getSolidRestOffset :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getSolidRestOffset(this); }

    PxPBDParticleSystem_addRigidAttachment :: inline (this: *PxPBDParticleSystem, actor: *PxRigidActor) { this.pxpbdparticlesystem_vtable.addRigidAttachment(this, actor); }

    PxPBDParticleSystem_removeRigidAttachment :: inline (this: *PxPBDParticleSystem, actor: *PxRigidActor) { this.pxpbdparticlesystem_vtable.removeRigidAttachment(this, actor); }

    PxPBDParticleSystem_enableCCD :: inline (this: *PxPBDParticleSystem, enable: bool) { this.pxpbdparticlesystem_vtable.enableCCD(this, enable); }

    PxPBDParticleSystem_getParticleLockFlags :: inline (this: *PxPBDParticleSystem) -> PxParticleLockFlags { return this.pxpbdparticlesystem_vtable.getParticleLockFlags(this); }

    PxPBDParticleSystem_setParticleLockFlag :: inline (this: *PxPBDParticleSystem, flag: PxParticleLockFlag.Enum, value: bool) { this.pxpbdparticlesystem_vtable.setParticleLockFlag(this, flag, value); }

    PxPBDParticleSystem_setParticleLockFlags :: inline (this: *PxPBDParticleSystem, flags: PxParticleLockFlags) { this.pxpbdparticlesystem_vtable.setParticleLockFlags(this, flags); }

    PxPBDParticleSystem_createPhase :: inline (this: *PxPBDParticleSystem, material: *PxPBDMaterial, flags: PxParticlePhaseFlags) -> PxU32 { return this.pxpbdparticlesystem_vtable.createPhase(this, material, flags); }

    PxPBDParticleSystem_getNbParticleMaterials :: inline (this: *PxPBDParticleSystem) -> PxU32 { return this.pxpbdparticlesystem_vtable.getNbParticleMaterials(this); }

    PxPBDParticleSystem_getParticleMaterials :: inline (this: *PxPBDParticleSystem, userBuffer: **PxPBDMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxpbdparticlesystem_vtable.getParticleMaterials(this, userBuffer, bufferSize, startIndex); }

    PxPBDParticleSystem_setParticleSystemCallback :: inline (this: *PxPBDParticleSystem, callback: *PxParticleSystemCallback) { this.pxpbdparticlesystem_vtable.setParticleSystemCallback(this, callback); }

    PxPBDParticleSystem_getParticleSystemCallback :: inline (this: *PxPBDParticleSystem) -> *PxParticleSystemCallback { return this.pxpbdparticlesystem_vtable.getParticleSystemCallback(this); }

    PxPBDParticleSystem_addParticleBuffer :: inline (this: *PxPBDParticleSystem, particleBuffer: *PxParticleBuffer) { this.pxpbdparticlesystem_vtable.addParticleBuffer(this, particleBuffer); }

    PxPBDParticleSystem_removeParticleBuffer :: inline (this: *PxPBDParticleSystem, particleBuffer: *PxParticleBuffer) { this.pxpbdparticlesystem_vtable.removeParticleBuffer(this, particleBuffer); }

    PxPBDParticleSystem_getGpuParticleSystemIndex :: inline (this: *PxPBDParticleSystem) -> PxU32 { return this.pxpbdparticlesystem_vtable.getGpuParticleSystemIndex(this); }

    PxPBDParticleSystem_setWind :: inline (this: *PxPBDParticleSystem, wind: *PxVec3) { this.pxpbdparticlesystem_vtable.setWind(this, wind); }

    PxPBDParticleSystem_getWind :: inline (this: *PxPBDParticleSystem) -> PxVec3 { return this.pxpbdparticlesystem_vtable.getWind(this); }

    PxPBDParticleSystem_setFluidBoundaryDensityScale :: inline (this: *PxPBDParticleSystem, fluidBoundaryDensityScale: PxReal) { this.pxpbdparticlesystem_vtable.setFluidBoundaryDensityScale(this, fluidBoundaryDensityScale); }

    PxPBDParticleSystem_getFluidBoundaryDensityScale :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getFluidBoundaryDensityScale(this); }

    PxPBDParticleSystem_setFluidRestOffset :: inline (this: *PxPBDParticleSystem, fluidRestOffset: PxReal) { this.pxpbdparticlesystem_vtable.setFluidRestOffset(this, fluidRestOffset); }

    PxPBDParticleSystem_getFluidRestOffset :: inline (this: *PxPBDParticleSystem) -> PxReal { return this.pxpbdparticlesystem_vtable.getFluidRestOffset(this); }

    PxPBDParticleSystem_setGridSizeX :: inline (this: *PxPBDParticleSystem, gridSizeX: PxU32) { this.pxpbdparticlesystem_vtable.setGridSizeX(this, gridSizeX); }

    PxPBDParticleSystem_getGridSizeX :: inline (this: *PxPBDParticleSystem) -> PxU32 { return this.pxpbdparticlesystem_vtable.getGridSizeX(this); }

    PxPBDParticleSystem_setGridSizeY :: inline (this: *PxPBDParticleSystem, gridSizeY: PxU32) { this.pxpbdparticlesystem_vtable.setGridSizeY(this, gridSizeY); }

    PxPBDParticleSystem_getGridSizeY :: inline (this: *PxPBDParticleSystem) -> PxU32 { return this.pxpbdparticlesystem_vtable.getGridSizeY(this); }

    PxPBDParticleSystem_setGridSizeZ :: inline (this: *PxPBDParticleSystem, gridSizeZ: PxU32) { this.pxpbdparticlesystem_vtable.setGridSizeZ(this, gridSizeZ); }

    PxPBDParticleSystem_getGridSizeZ :: inline (this: *PxPBDParticleSystem) -> PxU32 { return this.pxpbdparticlesystem_vtable.getGridSizeZ(this); }

    vtable :: (obj: *PxPBDParticleSystem) -> *PxPBDParticleSystem_VTable { return obj.pxpbdparticlesystem_vtable; }


    /*
    \deprecated This typedef only serves for deprecation and will be removed in a future version.
    */
    PxParticleSystem :: PxPBDParticleSystem;

    /*
    \deprecated The solver type will be removed in a future version without replacement.
    \brief Identifies the solver to use for a particle system.
    */
    PxParticleSolverType :: struct {
        Enum :: enum s32 {
            ePBD :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Particle system geometry class.
    
    */
    PxParticleSystemGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Default constructor.
        
        Creates an empty object with no particles.
        */
        Constructor :: (this: *PxParticleSystemGeometry) -> void #cpp_method #foreign physx_static "??0PxParticleSystemGeometry@physx@@QEAA@XZ";

        /*
        \brief Returns true if the geometry is valid.
        
        \return  True if the current settings are valid for shape creation.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxParticleSystemGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxParticleSystemGeometry@physx@@QEBA_NXZ";

        mSolverType: PxParticleSolverType.Enum;
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxParticleSystemGeometry, that: *physx.PxParticleSystemGeometry) -> void #cpp_method #foreign physx_static "??4PxParticleSystemGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxParticleSystemGeometry, that: physx.PxParticleSystemGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Hair system geometry class.
    
    */
    PxHairSystemGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Default constructor.
        */
        Constructor :: (this: *PxHairSystemGeometry) -> void #cpp_method #foreign physx_static "??0PxHairSystemGeometry@physx@@QEAA@XZ";

        /*
        \brief Returns true if the geometry is valid.
        
        \return  True if the current settings are valid for shape creation.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxHairSystemGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxHairSystemGeometry@physx@@QEBA_NXZ";
    }

    /*
    \brief Tetrahedron mesh geometry class.
    
    This class wraps a tetrahedron mesh such that it can be used in contexts where a PxGeometry type is needed.
    */
    PxTetrahedronMeshGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief Returns true if the geometry is valid.
        
        \return  True if the current settings are valid for shape creation.
        
        \note A valid tetrahedron mesh has a positive scale value in each direction (scale.scale.x > 0, scale.scale.y > 0, scale.scale.z > 0).
        It is illegal to call PxRigidActor::createShape and PxPhysics::createShape with a tetrahedron mesh that has zero extents in any direction.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxTetrahedronMeshGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxTetrahedronMeshGeometry@physx@@QEBA_NXZ";

        tetrahedronMesh: *PxTetrahedronMesh; //!< A reference to the mesh object.
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxTetrahedronMeshGeometry, that: *physx.PxTetrahedronMeshGeometry) -> void #cpp_method #foreign physx_static "??4PxTetrahedronMeshGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxTetrahedronMeshGeometry, that: physx.PxTetrahedronMeshGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Scene query and geometry query behavior flags.
    
    PxHitFlags are used for 3 different purposes:
    
    1) To request hit fields to be filled in by scene queries (such as hit position, normal, face index or UVs).
    2) Once query is completed, to indicate which fields are valid (note that a query may produce more valid fields than requested).
    3) To specify additional options for the narrow phase and mid-phase intersection routines.
    
    All these flags apply to both scene queries and geometry queries (PxGeometryQuery).
    
    \see PxRaycastHit PxSweepHit PxOverlapHit PxScene.raycast PxScene.sweep PxScene.overlap PxGeometryQuery PxFindFaceIndex
    */
    PxHitFlag :: struct {
        Enum :: enum s32 {
            POSITION                  :: 1;
            NORMAL                    :: 2;
            UV                        :: 8;
            ASSUME_NO_INITIAL_OVERLAP :: 16;

            ANY_HIT                   :: 32;

            MESH_MULTIPLE             :: 64;
            MESH_ANY                  :: 32;
            MESH_BOTH_SIDES           :: 128;

            PRECISE_SWEEP             :: 256;

            MTD                       :: 512;
            FACE_INDEX                :: 1024;

            DEFAULT                   :: 1027;

            MODIFIABLE_FLAGS          :: 464;

            ePOSITION                  :: POSITION;
            eNORMAL                    :: NORMAL;
            eUV                        :: UV;
            eASSUME_NO_INITIAL_OVERLAP :: ASSUME_NO_INITIAL_OVERLAP;

            eANY_HIT                   :: ANY_HIT;

            eMESH_MULTIPLE             :: MESH_MULTIPLE;
            eMESH_ANY                  :: MESH_ANY;
            eMESH_BOTH_SIDES           :: MESH_BOTH_SIDES;

            ePRECISE_SWEEP             :: PRECISE_SWEEP;

            eMTD                       :: MTD;
            eFACE_INDEX                :: FACE_INDEX;

            eDEFAULT                   :: DEFAULT;

            eMODIFIABLE_FLAGS          :: MODIFIABLE_FLAGS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxHitFlags :: PxFlags(PxHitFlag.Enum, PxU16);
    operator| :: (a: PxHitFlag.Enum, b: PxHitFlag.Enum) -> PxFlags(PxHitFlag.Enum, PxU16) #foreign physxcommon_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxHitFlag@physx@@G@0@W4Enum@PxHitFlag@0@0@Z";
    operator~ :: (a: PxHitFlag.Enum) -> PxFlags(PxHitFlag.Enum, PxU16) #foreign physxcommon_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxHitFlag@physx@@G@0@W4Enum@PxHitFlag@0@@Z";

    /*
    \brief Scene query hit information.
    */
    PxQueryHit :: struct {
        Constructor :: (this: *PxQueryHit) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxQueryHit@physx@@QEAA@XZ";

        /*
        Face index of touched triangle, for triangle meshes, convex meshes and height fields.
        
        \note This index will default to 0xFFFFffff value for overlap queries.
        \note Please refer to the user guide for more details for sweep queries.
        \note This index is remapped by mesh cooking. Use #PxTriangleMesh::getTrianglesRemap() to convert to original mesh index.
        \note For convex meshes use #PxConvexMesh::getPolygonData() to retrieve touched polygon data.
        */
        faceIndex: PxU32;
    }

    /*
    \brief Scene query hit information for raycasts and sweeps returning hit position and normal information.
    
    ::PxHitFlag flags can be passed to scene query functions, as an optimization, to cause the SDK to
    only generate specific members of this structure.
    */
    PxLocationHit :: struct {
        #as using pxqueryhit: PxQueryHit;

        Constructor :: (this: *PxLocationHit) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxLocationHit@physx@@QEAA@XZ";

        flags:    PxHitFlags; //!< Hit flags specifying which members contain valid values.
        position: PxVec3; //!< World-space hit position (flag: #PxHitFlag::ePOSITION)
        normal:   PxVec3; //!< World-space hit normal (flag: #PxHitFlag::eNORMAL)

        /*
        \brief	Distance to hit.
        \note	If the eMTD flag is used, distance will be a negative value if shapes are overlapping indicating the penetration depth.
        \note	Otherwise, this value will be >= 0 */
        distance: PxF32;
    }

    /*
    \brief Stores results of raycast queries.
    
    ::PxHitFlag flags can be passed to raycast function, as an optimization, to cause the SDK to only compute specified members of this
    structure.
    
    Some members like barycentric coordinates are currently only computed for triangle meshes and height fields, but next versions
    might provide them in other cases. The client code should check #flags to make sure returned values are valid.
    
    \see PxScene.raycast
    */
    PxGeomRaycastHit :: struct {
        #as using pxlocationhit: PxLocationHit;

        Constructor :: (this: *PxGeomRaycastHit) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxGeomRaycastHit@physx@@QEAA@XZ";

        u: PxReal; //!< barycentric coordinates of hit point, for triangle mesh and height field (flag: #PxHitFlag::eUV)
        v: PxReal; //!< barycentric coordinates of hit point, for triangle mesh and height field (flag: #PxHitFlag::eUV)
    }

    /*
    \brief Stores results of overlap queries.
    
    \see PxScene.overlap
    */
    PxGeomOverlapHit :: struct {
        #as using pxqueryhit: PxQueryHit;

        Constructor :: (this: *PxGeomOverlapHit) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxGeomOverlapHit@physx@@QEAA@XZ";
    }

    /*
    \brief Stores results of sweep queries.
    
    \see PxScene.sweep
    */
    PxGeomSweepHit :: struct {
        #as using pxlocationhit: PxLocationHit;

        Constructor :: (this: *PxGeomSweepHit) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxGeomSweepHit@physx@@QEAA@XZ";
    }

    /*
    \brief Pair of indices, typically either object or triangle indices.
    */
    PxGeomIndexPair :: struct {
        Constructor :: (this: *PxGeomIndexPair) -> void #cpp_method #foreign physxcommon_static "??0PxGeomIndexPair@physx@@QEAA@XZ";

        id0: PxU32;
        id1: PxU32;
    }

    /*
    \brief A per-thread context passed to low-level query functions.
    
    This is a user-defined optional parameter that gets passed down to low-level query functions (raycast / overlap / sweep).
    
    This is not used directly in PhysX, although the context in this case is the PxHitCallback used in the query. This allows
    user-defined query functions, such as the ones from PxCustomGeometry, to get some additional data about the query. In this
    case this is a 'per-query' context rather than 'per-thread', but the initial goal of this parameter is to give custom
    query callbacks access to per-thread data structures (e.g. caches) that could be needed to implement the callbacks.
    
    In any case this is mostly for user-controlled query systems.
    */
    PxQueryThreadContext :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief A per-thread context passed to low-level raycast functions.
    */
    PxRaycastThreadContext :: PxQueryThreadContext;

    /*
    \brief A per-thread context passed to low-level overlap functions.
    */
    PxOverlapThreadContext :: PxQueryThreadContext;

    /*
    \brief A per-thread context passed to low-level sweep functions.
    */
    PxSweepThreadContext :: PxQueryThreadContext;

    PxContactBuffer :: struct {}
    PxRenderOutput :: struct {}

    /*
    \brief Custom geometry class. This class allows user to create custom geometries by providing a set of virtual callback functions.
    */
    PxCustomGeometry :: struct {
        #as using pxgeometry: PxGeometry;

        /*
        \brief For internal use
        */
        getUniqueID :: () -> PxU32 #foreign physxcommon_static "?getUniqueID@PxCustomGeometry@physx@@SAIXZ";

        /*
        \brief The type of a custom geometry. Allows to identify a particular kind of it.
        */
        Type :: struct {
            mID: PxU32;
        }

        /*
        \brief Custom geometry callbacks structure. User should inherit this and implement all pure virtual functions.
        */
        Callbacks :: struct {
            vtable: *Callbacks_VTable;
        }
        Callbacks_VTable :: struct #type_info_none {
            getCustomType: (this: *Callbacks) -> Type #cpp_method #cpp_return_type_is_non_pod;

            getLocalBounds: (this: *Callbacks, geometry: *PxGeometry) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

            generateContacts: (this: *Callbacks, geom0: *PxGeometry, geom1: *PxGeometry, pose0: *PxTransform, pose1: *PxTransform, contactDistance: PxReal, meshContactMargin: PxReal, toleranceLength: PxReal, contactBuffer: *PxContactBuffer) -> bool #cpp_method;

            raycast: (this: *Callbacks, origin: *PxVec3, unitDir: *PxVec3, geom: *PxGeometry, pose: *PxTransform, maxDist: PxReal, hitFlags: PxHitFlags, maxHits: PxU32, rayHits: *PxGeomRaycastHit, stride: PxU32, threadContext: *PxRaycastThreadContext) -> PxU32 #cpp_method;

            overlap: (this: *Callbacks, geom0: *PxGeometry, pose0: *PxTransform, geom1: *PxGeometry, pose1: *PxTransform, threadContext: *PxOverlapThreadContext) -> bool #cpp_method;

            sweep: (this: *Callbacks, unitDir: *PxVec3, maxDist: PxReal, geom0: *PxGeometry, pose0: *PxTransform, geom1: *PxGeometry, pose1: *PxTransform, sweepHit: *PxGeomSweepHit, hitFlags: PxHitFlags, inflation: PxReal, threadContext: *PxSweepThreadContext) -> bool #cpp_method;

            visualize: (this: *Callbacks, geometry: *PxGeometry, out: *PxRenderOutput, absPose: *PxTransform, cullbox: *PxBounds3) -> void #cpp_method;

            computeMassProperties: (this: *Callbacks, geometry: *PxGeometry, massProperties: *PxMassProperties) -> void #cpp_method;

            usePersistentContactManifold: (this: *Callbacks, geometry: *PxGeometry, breakingThreshold: *PxReal) -> bool #cpp_method;

            Destructor: (this: *Callbacks, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
        }

        Callbacks_getCustomType :: inline (this: *Callbacks) -> Type { return this.vtable.getCustomType(this); }

        Callbacks_getLocalBounds :: inline (this: *Callbacks, geometry: *PxGeometry) -> PxBounds3 { return this.vtable.getLocalBounds(this, geometry); }

        Callbacks_generateContacts :: inline (this: *Callbacks, geom0: *PxGeometry, geom1: *PxGeometry, pose0: *PxTransform, pose1: *PxTransform, contactDistance: PxReal, meshContactMargin: PxReal, toleranceLength: PxReal, contactBuffer: *PxContactBuffer) -> bool { return this.vtable.generateContacts(this, geom0, geom1, pose0, pose1, contactDistance, meshContactMargin, toleranceLength, contactBuffer); }

        Callbacks_raycast :: inline (this: *Callbacks, origin: *PxVec3, unitDir: *PxVec3, geom: *PxGeometry, pose: *PxTransform, maxDist: PxReal, hitFlags: PxHitFlags, maxHits: PxU32, rayHits: *PxGeomRaycastHit, stride: PxU32, threadContext: *PxRaycastThreadContext) -> PxU32 { return this.vtable.raycast(this, origin, unitDir, geom, pose, maxDist, hitFlags, maxHits, rayHits, stride, threadContext); }

        Callbacks_overlap :: inline (this: *Callbacks, geom0: *PxGeometry, pose0: *PxTransform, geom1: *PxGeometry, pose1: *PxTransform, threadContext: *PxOverlapThreadContext) -> bool { return this.vtable.overlap(this, geom0, pose0, geom1, pose1, threadContext); }

        Callbacks_sweep :: inline (this: *Callbacks, unitDir: *PxVec3, maxDist: PxReal, geom0: *PxGeometry, pose0: *PxTransform, geom1: *PxGeometry, pose1: *PxTransform, sweepHit: *PxGeomSweepHit, hitFlags: PxHitFlags, inflation: PxReal, threadContext: *PxSweepThreadContext) -> bool { return this.vtable.sweep(this, unitDir, maxDist, geom0, pose0, geom1, pose1, sweepHit, hitFlags, inflation, threadContext); }

        Callbacks_visualize :: inline (this: *Callbacks, geometry: *PxGeometry, out: *PxRenderOutput, absPose: *PxTransform, cullbox: *PxBounds3) { this.vtable.visualize(this, geometry, out, absPose, cullbox); }

        Callbacks_computeMassProperties :: inline (this: *Callbacks, geometry: *PxGeometry, massProperties: *PxMassProperties) { this.vtable.computeMassProperties(this, geometry, massProperties); }

        Callbacks_usePersistentContactManifold :: inline (this: *Callbacks, geometry: *PxGeometry, breakingThreshold: *PxReal) -> bool { return this.vtable.usePersistentContactManifold(this, geometry, breakingThreshold); }

        Callbacks_Destructor :: inline (this: *Callbacks, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

        vtable :: (obj: *Callbacks) -> *Callbacks_VTable { return obj.vtable; }


        /*
        \brief Constructor.
        */
        Constructor :: (this: *PxCustomGeometry, _callbacks: *Callbacks) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxCustomGeometry@physx@@QEAA@AEAUCallbacks@01@@Z";

        /*
        \brief Returns true if the geometry is valid.
        
        \return  True if the current settings are valid for shape creation.
        
        \see PxRigidActor::createShape, PxPhysics::createShape
        */
        isValid :: (this: *PxCustomGeometry) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxCustomGeometry@physx@@QEBA_NXZ";

        callbacks: *Callbacks; //!< A reference to the callbacks object.
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxCustomGeometry, that: *physx.PxCustomGeometry) -> void #cpp_method #foreign physx_static "??4PxCustomGeometry@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxCustomGeometry, that: physx.PxCustomGeometry) #no_context {
        operator_assign(this, *that);
    }

    /*
    \brief Geometry holder class
    
    This class contains enough space to hold a value of any PxGeometry subtype.
    
    Its principal use is as a convenience class to allow geometries to be returned polymorphically from functions.
    */
    PxGeometryHolder :: struct {
        PxInvalidGeometry :: struct {
            #as using pxgeometry: PxGeometry;

            Constructor :: (this: *PxInvalidGeometry) -> void #cpp_method #foreign physx_static "??0PxInvalidGeometry@PxGeometryHolder@physx@@QEAA@XZ";
        }

        any :: (this: *PxGeometryHolder) -> *PxGeometry #cpp_method #foreign physx_static "?any@PxGeometryHolder@physx@@QEAAAEAVPxGeometry@2@XZ";

        //! \endcond
        storeAny :: (this: *PxGeometryHolder, geometry: *PxGeometry) -> void #cpp_method #foreign physx_static "?storeAny@PxGeometryHolder@physx@@QEAAXAEBVPxGeometry@2@@Z";
        storeAny :: (this: *PxGeometryHolder, geometry: PxGeometry) #no_context {
            storeAny(this, *geometry);
        }

        Constructor :: (this: *PxGeometryHolder) -> void #cpp_method #foreign physx_static "??0PxGeometryHolder@physx@@QEAA@XZ";
        Constructor :: (this: *PxGeometryHolder, geometry: *PxGeometry) -> void #cpp_method #foreign physx_static "??0PxGeometryHolder@physx@@QEAA@AEBVPxGeometry@1@@Z";
        Constructor :: (this: *PxGeometryHolder, geometry: PxGeometry) #no_context {
            Constructor(this, *geometry);
        }

        bytes: union {
            geometry:       [8] PxU8;
            box:            [20] PxU8;
            sphere:         [12] PxU8;
            capsule:        [16] PxU8;
            plane:          [8] PxU8;
            convex:         [56] PxU8;
            tetMesh:        [16] PxU8;
            mesh:           [48] PxU8;
            heightfield:    [32] PxU8;
            particleSystem: [12] PxU8;
            hairSystem:     [8] PxU8;
            custom:         [16] PxU8;
        };
    }

    /*
    \brief Collection of geometry object queries (sweeps, raycasts, overlaps, ...).
    */
    PxGeometryQuery :: struct {
        /*
        \brief Raycast test against a geometry object.
        
        All geometry types are supported except PxParticleSystemGeometry, PxTetrahedronMeshGeometry and PxHairSystemGeometry.
        
        \param[in] origin			The origin of the ray to test the geometry object against
        \param[in] unitDir			Normalized direction of the ray to test the geometry object against
        \param[in] geom				The geometry object to test the ray against
        \param[in] pose				Pose of the geometry object
        \param[in] maxDist			Maximum ray length, has to be in the [0, inf) range
        \param[in] hitFlags			Specification of the kind of information to retrieve on hit. Combination of #PxHitFlag flags
        \param[in] maxHits			max number of returned hits = size of 'rayHits' buffer
        \param[out] rayHits			Raycast hits information
        \param[in] stride			Stride value (in number of bytes) for rayHits array. Typically sizeof(PxGeomRaycastHit) for packed arrays.
        \param[in] queryFlags		Optional flags controlling the query.
        \param[in] threadContext	Optional user-defined per-thread context.
        
        \return Number of hits between the ray and the geometry object
        
        \see PxGeomRaycastHit PxGeometry PxTransform
        */
        raycast :: (origin: *PxVec3, unitDir: *PxVec3, geom: *PxGeometry, pose: *PxTransform, maxDist: PxReal, hitFlags: PxHitFlags, maxHits: PxU32, rayHits: *PxGeomRaycastHit, stride: PxU32 = 44, queryFlags: PxGeometryQueryFlags, threadContext: *PxRaycastThreadContext = null) -> PxU32 #foreign physxcommon_static "?raycast@PxGeometryQuery@physx@@SAIAEBV?$PxVec3T@M@2@0AEBVPxGeometry@2@AEBV?$PxTransformT@M@2@MV?$PxFlags@W4Enum@PxHitFlag@physx@@G@2@IPEIAUPxGeomRaycastHit@2@IV?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@PEAUPxQueryThreadContext@2@@Z";
        raycast :: (origin: PxVec3, unitDir: PxVec3, geom: PxGeometry, pose: PxTransform, maxDist: PxReal, hitFlags: PxHitFlags, maxHits: PxU32, rayHits: *PxGeomRaycastHit, stride: PxU32 = 44, queryFlags: PxGeometryQueryFlags, threadContext: *PxRaycastThreadContext = null) -> PxU32 #no_context {
            return raycast(*origin, *unitDir, *geom, *pose, maxDist, hitFlags, maxHits, rayHits, stride, queryFlags, threadContext);
        }

        /*
        \brief Overlap test for two geometry objects.
        
        All combinations are supported except:
        \li PxPlaneGeometry vs. {PxPlaneGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}
        \li PxTriangleMeshGeometry vs. PxHeightFieldGeometry
        \li PxHeightFieldGeometry vs. PxHeightFieldGeometry
        \li Anything involving PxParticleSystemGeometry, PxTetrahedronMeshGeometry or PxHairSystemGeometry.
        
        \param[in] geom0			The first geometry object
        \param[in] pose0			Pose of the first geometry object
        \param[in] geom1			The second geometry object
        \param[in] pose1			Pose of the second geometry object
        \param[in] queryFlags		Optional flags controlling the query.
        \param[in] threadContext	Optional user-defined per-thread context.
        
        \return True if the two geometry objects overlap
        
        \see PxGeometry PxTransform
        */
        overlap :: (geom0: *PxGeometry, pose0: *PxTransform, geom1: *PxGeometry, pose1: *PxTransform, queryFlags: PxGeometryQueryFlags, threadContext: *PxOverlapThreadContext = null) -> bool #foreign physxcommon_static "?overlap@PxGeometryQuery@physx@@SA_NAEBVPxGeometry@2@AEBV?$PxTransformT@M@2@01V?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@PEAUPxQueryThreadContext@2@@Z";
        overlap :: (geom0: PxGeometry, pose0: PxTransform, geom1: PxGeometry, pose1: PxTransform, queryFlags: PxGeometryQueryFlags, threadContext: *PxOverlapThreadContext = null) -> bool #no_context {
            return overlap(*geom0, *pose0, *geom1, *pose1, queryFlags, threadContext);
        }

        /*
        \brief Sweep a specified geometry object in space and test for collision with a given object.
        
        The following combinations are supported.
        
        \li PxSphereGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}
        \li PxCapsuleGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}
        \li PxBoxGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}
        \li PxConvexMeshGeometry vs. {PxSphereGeometry, PxPlaneGeometry, PxCapsuleGeometry, PxBoxGeometry, PxConvexMeshGeometry, PxTriangleMeshGeometry, PxHeightFieldGeometry}
        
        \param[in] unitDir			Normalized direction along which object geom0 should be swept
        \param[in] maxDist			Maximum sweep distance, has to be in the [0, inf) range
        \param[in] geom0			The geometry object to sweep. Supported geometries are #PxSphereGeometry, #PxCapsuleGeometry, #PxBoxGeometry and #PxConvexMeshGeometry
        \param[in] pose0			Pose of the geometry object to sweep
        \param[in] geom1			The geometry object to test the sweep against
        \param[in] pose1			Pose of the geometry object to sweep against
        \param[out] sweepHit		The sweep hit information. Only valid if this method returns true.
        \param[in] hitFlags			Specify which properties per hit should be computed and written to result hit array. Combination of #PxHitFlag flags
        \param[in] inflation		Surface of the swept shape is additively extruded in the normal direction, rounding corners and edges.
        \param[in] queryFlags		Optional flags controlling the query.
        \param[in] threadContext	Optional user-defined per-thread context.
        
        \return True if the swept geometry object geom0 hits the object geom1
        
        \see PxGeomSweepHit PxGeometry PxTransform
        */
        sweep :: (unitDir: *PxVec3, maxDist: PxReal, geom0: *PxGeometry, pose0: *PxTransform, geom1: *PxGeometry, pose1: *PxTransform, sweepHit: *PxGeomSweepHit, hitFlags: PxHitFlags, inflation: PxReal = 0.0, queryFlags: PxGeometryQueryFlags, threadContext: *PxSweepThreadContext = null) -> bool #foreign physxcommon_static "?sweep@PxGeometryQuery@physx@@SA_NAEBV?$PxVec3T@M@2@MAEBVPxGeometry@2@AEBV?$PxTransformT@M@2@12AEAUPxGeomSweepHit@2@V?$PxFlags@W4Enum@PxHitFlag@physx@@G@2@MV?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@PEAUPxQueryThreadContext@2@@Z";
        sweep :: (unitDir: PxVec3, maxDist: PxReal, geom0: PxGeometry, pose0: PxTransform, geom1: PxGeometry, pose1: PxTransform, sweepHit: *PxGeomSweepHit, hitFlags: PxHitFlags, inflation: PxReal = 0.0, queryFlags: PxGeometryQueryFlags, threadContext: *PxSweepThreadContext = null) -> bool #no_context {
            return sweep(*unitDir, maxDist, *geom0, *pose0, *geom1, *pose1, sweepHit, hitFlags, inflation, queryFlags, threadContext);
        }

        /*
        \brief Compute minimum translational distance (MTD) between two geometry objects.
        
        All combinations of geom objects are supported except:
        - plane/plane
        - plane/mesh
        - plane/heightfield
        - mesh/mesh
        - mesh/heightfield
        - heightfield/heightfield
        - anything involving PxParticleSystemGeometry, PxTetrahedronMeshGeometry or PxHairSystemGeometry
        
        The function returns a unit vector ('direction') and a penetration depth ('depth').
        
        The depenetration vector D = direction * depth should be applied to the first object, to
        get out of the second object.
        
        Returned depth should always be positive or null.
        
        If objects do not overlap, the function can not compute the MTD and returns false.
        
        \param[out] direction	Computed MTD unit direction
        \param[out] depth		Penetration depth. Always positive or null.
        \param[in] geom0		The first geometry object
        \param[in] pose0		Pose of the first geometry object
        \param[in] geom1		The second geometry object
        \param[in] pose1		Pose of the second geometry object
        \param[in] queryFlags	Optional flags controlling the query.
        \return True if the MTD has successfully been computed, i.e. if objects do overlap.
        
        \see PxGeometry PxTransform
        */
        computePenetration :: (direction: *PxVec3, depth: *PxF32, geom0: *PxGeometry, pose0: *PxTransform, geom1: *PxGeometry, pose1: *PxTransform, queryFlags: PxGeometryQueryFlags) -> bool #foreign physxcommon_static "?computePenetration@PxGeometryQuery@physx@@SA_NAEAV?$PxVec3T@M@2@AEAMAEBVPxGeometry@2@AEBV?$PxTransformT@M@2@23V?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@@Z";
        computePenetration :: (direction: *PxVec3, depth: *PxF32, geom0: PxGeometry, pose0: PxTransform, geom1: PxGeometry, pose1: PxTransform, queryFlags: PxGeometryQueryFlags) -> bool #no_context {
            return computePenetration(direction, depth, *geom0, *pose0, *geom1, *pose1, queryFlags);
        }

        /*
        \brief Computes distance between a point and a geometry object.
        
        Currently supported geometry objects: box, sphere, capsule, convex, mesh.
        
        \note For meshes, only the BVH34 midphase data-structure is supported.
        
        \param[in] point			The point P
        \param[in] geom				The geometry object
        \param[in] pose				Pose of the geometry object
        \param[out] closestPoint	Optionally returned closest point to P on the geom object. Only valid when returned distance is strictly positive.
        \param[out] closestIndex	Optionally returned closest (triangle) index. Only valid for triangle meshes.
        \param[in] queryFlags		Optional flags controlling the query.
        \return Square distance between the point and the geom object, or 0.0 if the point is inside the object, or -1.0 if an error occured (geometry type is not supported, or invalid pose)
        
        \see PxGeometry PxTransform
        */
        pointDistance :: (point: *PxVec3, geom: *PxGeometry, pose: *PxTransform, closestPoint: *PxVec3 = null, closestIndex: *PxU32 = null, queryFlags: PxGeometryQueryFlags) -> PxReal #foreign physxcommon_static "?pointDistance@PxGeometryQuery@physx@@SAMAEBV?$PxVec3T@M@2@AEBVPxGeometry@2@AEBV?$PxTransformT@M@2@PEAV32@PEAIV?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@@Z";
        pointDistance :: (point: PxVec3, geom: PxGeometry, pose: PxTransform, closestPoint: *PxVec3 = null, closestIndex: *PxU32 = null, queryFlags: PxGeometryQueryFlags) -> PxReal #no_context {
            return pointDistance(*point, *geom, *pose, closestPoint, closestIndex, queryFlags);
        }

        /*
        \brief computes the bounds for a geometry object
        
        \param[out] bounds		Returned computed bounds
        \param[in] geom			The geometry object
        \param[in] pose			Pose of the geometry object
        \param[in] offset		Offset for computed bounds. This value is added to the geom's extents.
        \param[in] inflation	Scale factor for computed bounds. The geom's extents are multiplied by this value.
        \param[in] queryFlags	Optional flags controlling the query.
        
        \see PxGeometry PxTransform
        */
        computeGeomBounds :: (bounds: *PxBounds3, geom: *PxGeometry, pose: *PxTransform, offset: float = 0.0, inflation: float = 1.0, queryFlags: PxGeometryQueryFlags) -> void #foreign physxcommon_static "?computeGeomBounds@PxGeometryQuery@physx@@SAXAEAVPxBounds3@2@AEBVPxGeometry@2@AEBV?$PxTransformT@M@2@MMV?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@@Z";
        computeGeomBounds :: (bounds: *PxBounds3, geom: PxGeometry, pose: PxTransform, offset: float = 0.0, inflation: float = 1.0, queryFlags: PxGeometryQueryFlags) #no_context {
            computeGeomBounds(bounds, *geom, *pose, offset, inflation, queryFlags);
        }

        /*
        \brief Generate collision contacts between a convex geometry and a single triangle
        
        \param[in] geom					The geometry object. Can be a capsule, a box or a convex mesh
        \param[in] pose					Pose of the geometry object
        \param[in] triangleVertices		Triangle vertices in local space
        \param[in] triangleIndex		Triangle index
        \param[in] contactDistance		The distance at which contacts begin to be generated between the pairs
        \param[in] meshContactMargin	The mesh contact margin.
        \param[in] toleranceLength		The toleranceLength. Used for scaling distance-based thresholds internally to produce appropriate results given simulations in different units
        \param[out] contactBuffer		A buffer to write contacts to.
        
        \return True if there was collision
        */
        generateTriangleContacts :: (geom: *PxGeometry, pose: *PxTransform, triangleVertices: *[3] PxVec3, triangleIndex: PxU32, contactDistance: PxReal, meshContactMargin: PxReal, toleranceLength: PxReal, contactBuffer: *PxContactBuffer) -> bool #foreign physxcommon_static "?generateTriangleContacts@PxGeometryQuery@physx@@SA_NAEBVPxGeometry@2@AEBV?$PxTransformT@M@2@QEBV?$PxVec3T@M@2@IMMMAEAVPxContactBuffer@2@@Z";
        generateTriangleContacts :: (geom: PxGeometry, pose: PxTransform, triangleVertices: *[3] PxVec3, triangleIndex: PxU32, contactDistance: PxReal, meshContactMargin: PxReal, toleranceLength: PxReal, contactBuffer: *PxContactBuffer) -> bool #no_context {
            return generateTriangleContacts(*geom, *pose, triangleVertices, triangleIndex, contactDistance, meshContactMargin, toleranceLength, contactBuffer);
        }

        /*
        \brief Checks if provided geometry is valid.
        
        \param[in] geom	The geometry object.
        \return True if geometry is valid.
        
        \see PxGeometry
        */
        isValid :: (geom: *PxGeometry) -> bool #foreign physxcommon_static "?isValid@PxGeometryQuery@physx@@SA_NAEBVPxGeometry@2@@Z";
        isValid :: (geom: PxGeometry) -> bool #no_context {
            return isValid(*geom);
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Describes the format of height field samples.
    \see PxHeightFieldDesc.format PxHeightFieldDesc.samples
    */
    PxHeightFieldFormat :: struct {
        Enum :: enum s32 {
            eS16_TM :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Determines the tessellation of height field cells.
    \see PxHeightFieldDesc.format PxHeightFieldDesc.samples
    */
    PxHeightFieldTessFlag :: struct {
        Enum :: enum s32 {
            e0TH_VERTEX_SHARED :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Enum with flag values to be used in PxHeightFieldDesc.flags.
    */
    PxHeightFieldFlag :: struct {
        Enum :: enum s32 {
            eNO_BOUNDARY_EDGES :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxHeightFieldFlag.
    
    \see PxHeightFieldFlag
    */
    PxHeightFieldFlags :: PxFlags(PxHeightFieldFlag.Enum, PxU16);

    /*
    \brief Special material index values for height field samples.
    
    \see PxHeightFieldSample.materialIndex0 PxHeightFieldSample.materialIndex1
    */
    PxHeightFieldMaterial :: struct {
        Enum :: enum s32 {
            eHOLE :: 127;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Heightfield sample format.
    
    This format corresponds to the #PxHeightFieldFormat member PxHeightFieldFormat::eS16_TM.
    
    An array of heightfield samples are used when creating a PxHeightField to specify
    the elevation of the heightfield points. In addition the material and tessellation of the adjacent
    triangles are specified.
    
    \see PxHeightField PxHeightFieldDesc PxHeightFieldDesc.samples
    */
    PxHeightFieldSample :: struct {
        /*
        \brief The height of the heightfield sample
        
        This value is scaled by PxHeightFieldGeometry::heightScale.
        
        \see PxHeightFieldGeometry
        */
        height:         PxI16;

        /*
        \brief The triangle material index of the quad's lower triangle + tesselation flag
        
        An index pointing into the material table of the shape which instantiates the heightfield.
        This index determines the material of the lower of the quad's two triangles (i.e. the quad whose
        upper-left corner is this sample, see the Guide for illustrations).
        
        Special values of the 7 data bits are defined by PxHeightFieldMaterial
        
        The tesselation flag specifies which way the quad is split whose upper left corner is this sample.
        If the flag is set, the diagonal of the quad will run from this sample to the opposite vertex; if not,
        it will run between the other two vertices (see the Guide for illustrations).
        
        \see PxHeightFieldGeometry materialIndex1 PxShape.setmaterials() PxShape.getMaterials()
        */
        materialIndex0: PxBitAndByte;

        tessFlag :: (this: *PxHeightFieldSample) -> PxU8 #cpp_method #foreign physxcommon_static "?tessFlag@PxHeightFieldSample@physx@@QEBAEXZ";

        /*
        \brief The triangle material index of the quad's upper triangle + reserved flag
        
        An index pointing into the material table of the shape which instantiates the heightfield.
        This index determines the material of the upper of the quad's two triangles (i.e. the quad whose
        upper-left corner is this sample, see the Guide for illustrations).
        
        \see PxHeightFieldGeometry materialIndex0 PxShape.setmaterials() PxShape.getMaterials()
        */
        materialIndex1: PxBitAndByte;
    }

    /*
    \brief A height field class.
    
    Height fields work in a similar way as triangle meshes specified to act as
    height fields, with some important differences:
    
    Triangle meshes can be made of nonuniform geometry, while height fields are
    regular, rectangular grids.  This means that with PxHeightField, you sacrifice
    flexibility in return for improved performance and decreased memory consumption.
    
    In local space rows extend in X direction, columns in Z direction and height in Y direction.
    
    Like Convexes and TriangleMeshes, HeightFields are referenced by shape instances
    (see #PxHeightFieldGeometry, #PxShape).
    
    To avoid duplicating data when you have several instances of a particular
    height field differently, you do not use this class to represent a
    height field object directly. Instead, you create an instance of this height field
    via the PxHeightFieldGeometry and PxShape classes.
    
    <h3>Creation</h3>
    
    To create an instance of this class call PxPhysics::createHeightField() or
    PxCooking::createHeightField(const PxHeightFieldDesc&, PxInsertionCallback&).
    To delete it call release(). This is only possible
    once you have released all of its PxHeightFiedShape instances.
    
    <h3>Visualizations:</h3>
    \li #PxVisualizationParameter::eCOLLISION_AABBS
    \li #PxVisualizationParameter::eCOLLISION_SHAPES
    \li #PxVisualizationParameter::eCOLLISION_AXES
    \li #PxVisualizationParameter::eCOLLISION_FNORMALS
    \li #PxVisualizationParameter::eCOLLISION_EDGES
    
    \see PxHeightFieldDesc PxHeightFieldGeometry PxShape PxPhysics.createHeightField() PxCooking.createHeightField()
    */
    PxHeightField :: struct {
        #as using pxrefcounted: PxRefCounted;

        Constructor :: (this: *PxHeightField, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxHeightField@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxHeightField, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxHeightField@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrefcounted; pxheightfield_vtable: *PxHeightField_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxHeightField) -> *u8 #cpp_method #foreign physxcommon_static "?getConcreteTypeName@PxHeightField@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxHeightField, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxHeightField@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxHeightField, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxHeightField@physx@@MEBA_NPEBD@Z";
    }
    PxHeightField_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        saveCells: (this: *PxHeightField, destBuffer: *void, destBufferSize: PxU32) -> PxU32 #cpp_method;

        modifySamples: (this: *PxHeightField, startCol: PxI32, startRow: PxI32, subfieldDesc: *PxHeightFieldDesc, shrinkBounds := false) -> bool #cpp_method;

        getNbRows: (this: *PxHeightField) -> PxU32 #cpp_method;

        getNbColumns: (this: *PxHeightField) -> PxU32 #cpp_method;

        getFormat: (this: *PxHeightField) -> PxHeightFieldFormat.Enum #cpp_method;

        getSampleStride: (this: *PxHeightField) -> PxU32 #cpp_method;

        getConvexEdgeThreshold: (this: *PxHeightField) -> PxReal #cpp_method;

        getFlags: (this: *PxHeightField) -> PxHeightFieldFlags #cpp_method;

        getHeight: (this: *PxHeightField, x: PxReal, z: PxReal) -> PxReal #cpp_method;

        getTriangleMaterialIndex: (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxMaterialTableIndex #cpp_method;

        getTriangleNormal: (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxVec3 #cpp_method;

        getSample: (this: *PxHeightField, row: PxU32, column: PxU32) -> *PxHeightFieldSample #cpp_method;

        getTimestamp: (this: *PxHeightField) -> PxU32 #cpp_method;
    }

    PxHeightField_saveCells :: inline (this: *PxHeightField, destBuffer: *void, destBufferSize: PxU32) -> PxU32 { return this.pxheightfield_vtable.saveCells(this, destBuffer, destBufferSize); }

    PxHeightField_modifySamples :: inline (this: *PxHeightField, startCol: PxI32, startRow: PxI32, subfieldDesc: *PxHeightFieldDesc, shrinkBounds := false) -> bool { return this.pxheightfield_vtable.modifySamples(this, startCol, startRow, subfieldDesc, shrinkBounds); }

    PxHeightField_getNbRows :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getNbRows(this); }

    PxHeightField_getNbColumns :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getNbColumns(this); }

    PxHeightField_getFormat :: inline (this: *PxHeightField) -> PxHeightFieldFormat.Enum { return this.pxheightfield_vtable.getFormat(this); }

    PxHeightField_getSampleStride :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getSampleStride(this); }

    PxHeightField_getConvexEdgeThreshold :: inline (this: *PxHeightField) -> PxReal { return this.pxheightfield_vtable.getConvexEdgeThreshold(this); }

    PxHeightField_getFlags :: inline (this: *PxHeightField) -> PxHeightFieldFlags { return this.pxheightfield_vtable.getFlags(this); }

    PxHeightField_getHeight :: inline (this: *PxHeightField, x: PxReal, z: PxReal) -> PxReal { return this.pxheightfield_vtable.getHeight(this, x, z); }

    PxHeightField_getTriangleMaterialIndex :: inline (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxMaterialTableIndex { return this.pxheightfield_vtable.getTriangleMaterialIndex(this, triangleIndex); }

    PxHeightField_getTriangleNormal :: inline (this: *PxHeightField, triangleIndex: PxTriangleID) -> PxVec3 { return this.pxheightfield_vtable.getTriangleNormal(this, triangleIndex); }

    PxHeightField_getSample :: inline (this: *PxHeightField, row: PxU32, column: PxU32) -> *PxHeightFieldSample { return this.pxheightfield_vtable.getSample(this, row, column); }

    PxHeightField_getTimestamp :: inline (this: *PxHeightField) -> PxU32 { return this.pxheightfield_vtable.getTimestamp(this); }

    vtable :: (obj: *PxHeightField) -> *PxHeightField_VTable { return obj.pxheightfield_vtable; }


    /*
    \brief Descriptor class for #PxHeightField.
    
    \note The heightfield data is *copied* when a PxHeightField object is created from this descriptor. After the call the
    user may discard the height data.
    
    \see PxHeightField PxHeightFieldGeometry PxShape PxPhysics.createHeightField() PxCooking.createHeightField()
    */
    PxHeightFieldDesc :: struct {
        /*
        \brief Number of sample rows in the height field samples array.
        
        \note Local space X-axis corresponds to rows.
        
        <b>Range:</b> &gt;1<br>
        <b>Default:</b> 0
        */
        nbRows:              PxU32;

        /*
        \brief Number of sample columns in the height field samples array.
        
        \note Local space Z-axis corresponds to columns.
        
        <b>Range:</b> &gt;1<br>
        <b>Default:</b> 0
        */
        nbColumns:           PxU32;

        /*
        \brief Format of the sample data.
        
        Currently the only supported format is PxHeightFieldFormat::eS16_TM:
        
        <b>Default:</b> PxHeightFieldFormat::eS16_TM
        
        \see PxHeightFormat PxHeightFieldDesc.samples
        */
        format:              PxHeightFieldFormat.Enum;

        /*
        \brief The samples array.
        
        It is copied to the SDK's storage at creation time.
        
        There are nbRows * nbColumn samples in the array,
        which define nbRows * nbColumn vertices and cells,
        of which (nbRows - 1) * (nbColumns - 1) cells are actually used.
        
        The array index of sample(row, column) = row * nbColumns + column.
        The byte offset of sample(row, column) = sampleStride * (row * nbColumns + column).
        The sample data follows at the offset and spans the number of bytes defined by the format.
        Then there are zero or more unused bytes depending on sampleStride before the next sample.
        
        <b>Default:</b> NULL
        
        \see PxHeightFormat
        */
        samples:             PxStridedData;

        /*
        This threshold is used by the collision detection to determine if a height field edge is convex
        and can generate contact points.
        Usually the convexity of an edge is determined from the angle (or cosine of the angle) between
        the normals of the faces sharing that edge.
        The height field allows a more efficient approach by comparing height values of neighboring vertices.
        This parameter offsets the comparison. Smaller changes than 0.5 will not alter the set of convex edges.
        The rule of thumb is that larger values will result in fewer edge contacts.
        
        This parameter is ignored in contact generation with sphere and capsule primitives.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0
        */
        convexEdgeThreshold: PxReal;

        /*
        \brief Flags bits, combined from values of the enum ::PxHeightFieldFlag.
        
        <b>Default:</b> 0
        
        \see PxHeightFieldFlag PxHeightFieldFlags
        */
        flags:               PxHeightFieldFlags;

        /*
        \brief Returns true if the descriptor is valid.
        \return True if the current settings are valid.
        */
        isValid :: (this: *PxHeightFieldDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxHeightFieldDesc@physx@@QEBA_NXZ";
    }

    PxMeshMeshQueryFlag :: struct {
        Enum :: enum s32 {
            DEFAULT          :: 0;
            DISCARD_COPLANAR :: 1;
            RESERVED         :: 2;
            RESERVED1        :: 2;
            RESERVED2        :: 4;
            RESERVED3        :: 8;

            eDEFAULT          :: DEFAULT;
            eDISCARD_COPLANAR :: DISCARD_COPLANAR;
            eRESERVED         :: RESERVED;
            eRESERVED1        :: RESERVED1;
            eRESERVED2        :: RESERVED2;
            eRESERVED3        :: RESERVED3;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxMeshMeshQueryFlags :: PxFlags(PxMeshMeshQueryFlag.Enum, PxU32);

    PxMeshQuery :: struct {
        /*
        \brief Retrieves triangle data from a triangle ID.
        
        This function can be used together with #findOverlapTriangleMesh() to retrieve triangle properties.
        
        \param[in] triGeom				Geometry of the triangle mesh to extract the triangle from.
        \param[in] transform			Transform for the triangle mesh
        \param[in] triangleIndex		The index of the triangle to retrieve.
        \param[out] triangle			Triangle points in world space.
        \param[out] vertexIndices		Returned vertex indices for given triangle
        \param[out] adjacencyIndices	Returned 3 triangle adjacency internal face indices (0xFFFFFFFF if no adjacency). The mesh must be cooked with cooking param buildTriangleAdjacencies enabled.
        
        \note This function will flip the triangle normal whenever triGeom.scale.hasNegativeDeterminant() is true.
        
        \see PxTriangle PxTriangleFlags PxTriangleID findOverlapTriangleMesh()
        */
        getTriangle :: (triGeom: *PxTriangleMeshGeometry, transform: *PxTransform, triangleIndex: PxTriangleID, triangle: *PxTriangle, vertexIndices: *PxU32 = null, adjacencyIndices: *PxU32 = null) -> void #foreign physxcommon_static "?getTriangle@PxMeshQuery@physx@@SAXAEBVPxTriangleMeshGeometry@2@AEBV?$PxTransformT@M@2@IAEAVPxTriangle@2@PEAI3@Z";
        getTriangle :: (triGeom: PxTriangleMeshGeometry, transform: PxTransform, triangleIndex: PxTriangleID, triangle: *PxTriangle, vertexIndices: *PxU32 = null, adjacencyIndices: *PxU32 = null) #no_context {
            getTriangle(*triGeom, *transform, triangleIndex, triangle, vertexIndices, adjacencyIndices);
        }

        /*
        \brief Retrieves triangle data from a triangle ID.
        
        This function can be used together with #findOverlapHeightField() to retrieve triangle properties.
        
        \param[in] hfGeom				Geometry of the height field to extract the triangle from.
        \param[in] transform			Transform for the height field.
        \param[in] triangleIndex		The index of the triangle to retrieve.
        \param[out] triangle			Triangle points in world space.
        \param[out] vertexIndices		Returned vertex indices for given triangle
        \param[out] adjacencyIndices	Returned 3 triangle adjacency triangle indices (0xFFFFFFFF if no adjacency).
        
        \note This function will flip the triangle normal whenever triGeom.scale.hasNegativeDeterminant() is true.
        \note TriangleIndex is an index used in internal format, which does have an index out of the bounds in last row.
        To traverse all tri indices in the HF, the following code can be applied:
        for (PxU32 row = 0; row < (nbRows - 1); row++)
        {
        for (PxU32 col = 0; col < (nbCols - 1); col++)
        {
        for (PxU32 k = 0; k < 2; k++)
        {
        const PxU32 triIndex = 2 * (row*nbCols + col) + k;
        ....
        }
        }
        }
        \see PxTriangle PxTriangleFlags PxTriangleID findOverlapHeightField()
        */
        getTriangle :: (hfGeom: *PxHeightFieldGeometry, transform: *PxTransform, triangleIndex: PxTriangleID, triangle: *PxTriangle, vertexIndices: *PxU32 = null, adjacencyIndices: *PxU32 = null) -> void #foreign physxcommon_static "?getTriangle@PxMeshQuery@physx@@SAXAEBVPxHeightFieldGeometry@2@AEBV?$PxTransformT@M@2@IAEAVPxTriangle@2@PEAI3@Z";
        getTriangle :: (hfGeom: PxHeightFieldGeometry, transform: PxTransform, triangleIndex: PxTriangleID, triangle: *PxTriangle, vertexIndices: *PxU32 = null, adjacencyIndices: *PxU32 = null) #no_context {
            getTriangle(*hfGeom, *transform, triangleIndex, triangle, vertexIndices, adjacencyIndices);
        }

        /*
        \brief Find the mesh triangles which touch the specified geometry object.
        
        For mesh-vs-mesh overlap tests, please use the specialized function below.
        
        Returned triangle indices can be used with #getTriangle() to retrieve the triangle properties.
        
        \param[in] geom			The geometry object to test for mesh triangle overlaps. Supported geometries are #PxSphereGeometry, #PxCapsuleGeometry and #PxBoxGeometry
        \param[in] geomPose		Pose of the geometry object
        \param[in] meshGeom		The triangle mesh geometry to check overlap against
        \param[in] meshPose		Pose of the triangle mesh
        \param[out] results		Indices of overlapping triangles
        \param[in] maxResults	Size of 'results' buffer
        \param[in] startIndex	Index of first result to be retrieved. Previous indices are skipped.
        \param[out] overflow	True if a buffer overflow occurred
        \param[in] queryFlags	Optional flags controlling the query.
        \return Number of overlaps found, i.e. number of elements written to the results buffer
        
        \see PxTriangleMeshGeometry getTriangle() PxGeometryQueryFlags
        */
        findOverlapTriangleMesh :: (geom: *PxGeometry, geomPose: *PxTransform, meshGeom: *PxTriangleMeshGeometry, meshPose: *PxTransform, results: *PxU32, maxResults: PxU32, startIndex: PxU32, overflow: *bool, queryFlags: PxGeometryQueryFlags) -> PxU32 #foreign physxcommon_static "?findOverlapTriangleMesh@PxMeshQuery@physx@@SAIAEBVPxGeometry@2@AEBV?$PxTransformT@M@2@AEBVPxTriangleMeshGeometry@2@1PEAIIIAEA_NV?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@@Z";
        findOverlapTriangleMesh :: (geom: PxGeometry, geomPose: PxTransform, meshGeom: PxTriangleMeshGeometry, meshPose: PxTransform, results: *PxU32, maxResults: PxU32, startIndex: PxU32, overflow: *bool, queryFlags: PxGeometryQueryFlags) -> PxU32 #no_context {
            return findOverlapTriangleMesh(*geom, *geomPose, *meshGeom, *meshPose, results, maxResults, startIndex, overflow, queryFlags);
        }

        /*
        \brief Mesh-vs-mesh overlap test
        
        A specialized findOverlapTriangleMesh function for mesh-vs-mesh. The other findOverlapTriangleMesh() function above cannot be used
        directly since it only returns a single set of triangle indices that belongs to one of the meshes only. This function returns pairs
        of triangle indices that belong to both the first & second input meshes.
        
        Returned triangle indices can be used with #getTriangle() to retrieve the triangle properties.
        
        \note	This is only implemented for the PxMeshMidPhase::eBVH34 data structure.
        
        \param[in] callback			The callback object used to report results
        \param[in] meshGeom0		First triangle mesh geometry
        \param[in] meshPose0		Pose of first triangle mesh geometry
        \param[in] meshGeom1		Second triangle mesh geometry
        \param[in] meshPose1		Pose of second triangle mesh geometry
        \param[in] queryFlags		Optional flags controlling the query.
        \param[in] meshMeshFlags	Optional flags controlling the query.
        \param[in] tolerance		Optional tolerance distance
        \return true if an overlap has been detected, false if the meshes are disjoint
        
        \see PxTriangleMeshGeometry getTriangle() PxReportCallback PxGeometryQueryFlags PxMeshMeshQueryFlags
        */
        findOverlapTriangleMesh :: (callback: *PxReportCallback(PxGeomIndexPair), meshGeom0: *PxTriangleMeshGeometry, meshPose0: *PxTransform, meshGeom1: *PxTriangleMeshGeometry, meshPose1: *PxTransform, queryFlags: PxGeometryQueryFlags, meshMeshFlags: PxMeshMeshQueryFlags, tolerance: float = 0.0) -> bool #foreign physxcommon_static "?findOverlapTriangleMesh@PxMeshQuery@physx@@SA_NAEAV?$PxReportCallback@UPxGeomIndexPair@physx@@@2@AEBVPxTriangleMeshGeometry@2@AEBV?$PxTransformT@M@2@12V?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@V?$PxFlags@W4Enum@PxMeshMeshQueryFlag@physx@@I@2@M@Z";
        findOverlapTriangleMesh :: (callback: *PxReportCallback(PxGeomIndexPair), meshGeom0: PxTriangleMeshGeometry, meshPose0: PxTransform, meshGeom1: PxTriangleMeshGeometry, meshPose1: PxTransform, queryFlags: PxGeometryQueryFlags, meshMeshFlags: PxMeshMeshQueryFlags, tolerance: float = 0.0) -> bool #no_context {
            return findOverlapTriangleMesh(callback, *meshGeom0, *meshPose0, *meshGeom1, *meshPose1, queryFlags, meshMeshFlags, tolerance);
        }

        /*
        \brief Find the height field triangles which touch the specified geometry object.
        
        Returned triangle indices can be used with #getTriangle() to retrieve the triangle properties.
        
        \param[in] geom			The geometry object to test for height field overlaps. Supported geometries are #PxSphereGeometry, #PxCapsuleGeometry and #PxBoxGeometry. The sphere and capsule queries are currently conservative estimates.
        \param[in] geomPose		Pose of the geometry object
        \param[in] hfGeom		The height field geometry to check overlap against
        \param[in] hfPose		Pose of the height field
        \param[out] results		Indices of overlapping triangles
        \param[in] maxResults	Size of 'results' buffer
        \param[in] startIndex	Index of first result to be retrieved. Previous indices are skipped.
        \param[out] overflow	True if a buffer overflow occurred
        \param[in] queryFlags	Optional flags controlling the query.
        \return Number of overlaps found, i.e. number of elements written to the results buffer
        
        \see PxHeightFieldGeometry getTriangle() PxGeometryQueryFlags
        */
        findOverlapHeightField :: (geom: *PxGeometry, geomPose: *PxTransform, hfGeom: *PxHeightFieldGeometry, hfPose: *PxTransform, results: *PxU32, maxResults: PxU32, startIndex: PxU32, overflow: *bool, queryFlags: PxGeometryQueryFlags) -> PxU32 #foreign physxcommon_static "?findOverlapHeightField@PxMeshQuery@physx@@SAIAEBVPxGeometry@2@AEBV?$PxTransformT@M@2@AEBVPxHeightFieldGeometry@2@1PEAIIIAEA_NV?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@@Z";
        findOverlapHeightField :: (geom: PxGeometry, geomPose: PxTransform, hfGeom: PxHeightFieldGeometry, hfPose: PxTransform, results: *PxU32, maxResults: PxU32, startIndex: PxU32, overflow: *bool, queryFlags: PxGeometryQueryFlags) -> PxU32 #no_context {
            return findOverlapHeightField(*geom, *geomPose, *hfGeom, *hfPose, results, maxResults, startIndex, overflow, queryFlags);
        }

        /*
        \brief Sweep a specified geometry object in space and test for collision with a set of given triangles.
        
        This function simply sweeps input geometry against each input triangle, in the order they are given.
        This is an O(N) operation with N = number of input triangles. It does not use any particular acceleration structure.
        
        \param[in] unitDir			Normalized direction of the sweep.
        \param[in] distance			Sweep distance. Needs to be larger than 0. Clamped to PX_MAX_SWEEP_DISTANCE.
        \param[in] geom				The geometry object to sweep. Supported geometries are #PxSphereGeometry, #PxCapsuleGeometry and #PxBoxGeometry
        \param[in] pose				Pose of the geometry object to sweep.
        \param[in] triangleCount	Number of specified triangles
        \param[in] triangles		Array of triangles to sweep against
        \param[out] sweepHit		The sweep hit information. See the notes below for limitations about returned results.
        \param[in] hitFlags			Specification of the kind of information to retrieve on hit. Combination of #PxHitFlag flags. See the notes below for limitations about supported flags.
        \param[in] cachedIndex		Cached triangle index for subsequent calls. Cached triangle is tested first. Optional parameter.
        \param[in] inflation		This parameter creates a skin around the swept geometry which increases its extents for sweeping. The sweep will register a hit as soon as the skin touches a shape, and will return the corresponding distance and normal.
        \param[in] doubleSided		Counterpart of PxMeshGeometryFlag::eDOUBLE_SIDED for input triangles.
        \param[in] queryFlags		Optional flags controlling the query.
        \return True if the swept geometry object hits the specified triangles
        
        \note Only the following geometry types are currently supported: PxSphereGeometry, PxCapsuleGeometry, PxBoxGeometry
        \note If a shape from the scene is already overlapping with the query shape in its starting position, the hit is returned unless eASSUME_NO_INITIAL_OVERLAP was specified.
        \note This function returns a single closest hit across all the input triangles. Multiple hits are not supported.
        \note Supported hitFlags are PxHitFlag::eDEFAULT, PxHitFlag::eASSUME_NO_INITIAL_OVERLAP, PxHitFlag::ePRECISE_SWEEP, PxHitFlag::eMESH_BOTH_SIDES, PxHitFlag::eMESH_ANY.
        \note ePOSITION is only defined when there is no initial overlap (sweepHit.hadInitialOverlap() == false)
        \note The returned normal for initially overlapping sweeps is set to -unitDir.
        \note Otherwise the returned normal is the front normal of the triangle even if PxHitFlag::eMESH_BOTH_SIDES is set.
        \note The returned PxGeomSweepHit::faceIndex parameter will hold the index of the hit triangle in input array, i.e. the range is [0; triangleCount). For initially overlapping sweeps, this is the index of overlapping triangle.
        \note The inflation parameter is not compatible with PxHitFlag::ePRECISE_SWEEP.
        
        \see PxTriangle PxSweepHit PxGeometry PxTransform PxGeometryQueryFlags
        */
        sweep :: (unitDir: *PxVec3, distance: PxReal, geom: *PxGeometry, pose: *PxTransform, triangleCount: PxU32, triangles: *PxTriangle, sweepHit: *PxGeomSweepHit, hitFlags: PxHitFlags, cachedIndex: *PxU32 = null, inflation: PxReal = 0.0, doubleSided := false, queryFlags: PxGeometryQueryFlags) -> bool #foreign physxcommon_static "?sweep@PxMeshQuery@physx@@SA_NAEBV?$PxVec3T@M@2@MAEBVPxGeometry@2@AEBV?$PxTransformT@M@2@IPEBVPxTriangle@2@AEAUPxGeomSweepHit@2@V?$PxFlags@W4Enum@PxHitFlag@physx@@G@2@PEBIM_NV?$PxFlags@W4Enum@PxGeometryQueryFlag@physx@@I@2@@Z";
        sweep :: (unitDir: PxVec3, distance: PxReal, geom: PxGeometry, pose: PxTransform, triangleCount: PxU32, triangles: *PxTriangle, sweepHit: *PxGeomSweepHit, hitFlags: PxHitFlags, cachedIndex: *PxU32 = null, inflation: PxReal = 0.0, doubleSided := false, queryFlags: PxGeometryQueryFlags) -> bool #no_context {
            return sweep(*unitDir, distance, *geom, *pose, triangleCount, triangles, sweepHit, hitFlags, cachedIndex, inflation, doubleSided, queryFlags);
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Enum with flag values to be used in PxSimpleTriangleMesh::flags.
    */
    PxMeshFlag :: struct {
        Enum :: enum s32 {
            FLIPNORMALS     :: 1;
            _16_BIT_INDICES :: 2;

            eFLIPNORMALS    :: FLIPNORMALS;
            e16_BIT_INDICES :: _16_BIT_INDICES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxMeshFlag.
    
    \see PxMeshFlag
    */
    PxMeshFlags :: PxFlags(PxMeshFlag.Enum, PxU16);
    operator~ :: (a: PxMeshFlag.Enum) -> PxFlags(PxMeshFlag.Enum, PxU16) #foreign physxcommon_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxMeshFlag@physx@@G@0@W4Enum@PxMeshFlag@0@@Z";

    /*
    \brief A structure describing a triangle mesh.
    */
    PxSimpleTriangleMesh :: struct {
        /*
        \brief Pointer to first vertex point.
        */
        points:    PxBoundedData;

        /*
        \brief Pointer to first triangle.
        
        Caller may add triangleStrideBytes bytes to the pointer to access the next triangle.
        
        These are triplets of 0 based indices:
        vert0 vert1 vert2
        vert0 vert1 vert2
        vert0 vert1 vert2
        ...
        
        where vertex is either a 32 or 16 bit unsigned integer. There are numTriangles*3 indices.
        
        This is declared as a void pointer because it is actually either an PxU16 or a PxU32 pointer.
        */
        triangles: PxBoundedData;

        /*
        \brief Flags bits, combined from values of the enum ::PxMeshFlag
        */
        flags:     PxMeshFlags;

        /*
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxSimpleTriangleMesh) -> void #cpp_method #foreign physxcommon_static "??0PxSimpleTriangleMesh@physx@@QEAA@XZ";

        /*
        \brief (re)sets the structure to the default.
        */
        setToDefault :: (this: *PxSimpleTriangleMesh) -> void #cpp_method #foreign physxcommon_static "?setToDefault@PxSimpleTriangleMesh@physx@@QEAAXXZ";

        /*
        \brief returns true if the current settings are valid
        */
        isValid :: (this: *PxSimpleTriangleMesh) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxSimpleTriangleMesh@physx@@QEBA_NXZ";
    }

    /*
    \brief Triangle class.
    */
    PxTriangle :: struct {
        /*
        \brief Constructor
        */
        Constructor :: (this: *PxTriangle) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxTriangle@physx@@QEAA@XZ";

        /*
        \brief Constructor
        
        \param[in] p0 Point 0
        \param[in] p1 Point 1
        \param[in] p2 Point 2
        */
        Constructor :: (this: *PxTriangle, p0: *PxVec3, p1: *PxVec3, p2: *PxVec3) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxTriangle@physx@@QEAA@AEBV?$PxVec3T@M@1@00@Z";
        Constructor :: (this: *PxTriangle, p0: PxVec3, p1: PxVec3, p2: PxVec3) #no_context {
            Constructor(this, *p0, *p1, *p2);
        }

        /*
        \brief Copy constructor
        
        \param[in] triangle Tri to copy
        */
        CopyConstructor :: (this: *PxTriangle, triangle: *PxTriangle) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxTriangle@physx@@QEAA@AEBV01@@Z";
        CopyConstructor :: (this: *PxTriangle, triangle: PxTriangle) #no_context {
            CopyConstructor(this, *triangle);
        }

        /*
        \brief Destructor
        */
        Destructor :: (this: *PxTriangle) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxTriangle@physx@@QEAA@XZ";

        /*
        \brief Compute the normal of the Triangle.
        
        \param[out] _normal Triangle normal.
        */
        normal :: (this: *PxTriangle, _normal: *PxVec3) -> void #cpp_method #foreign physxcharacterkinematic_static "?normal@PxTriangle@physx@@QEBAXAEAV?$PxVec3T@M@2@@Z";

        /*
        \brief Compute the unnormalized normal of the triangle.
        
        \param[out] _normal Triangle normal (not normalized).
        */
        denormalizedNormal :: (this: *PxTriangle, _normal: *PxVec3) -> void #cpp_method #foreign physxcommon_static "?denormalizedNormal@PxTriangle@physx@@QEBAXAEAV?$PxVec3T@M@2@@Z";

        /*
        \brief Array of Vertices.
        */
        verts: [3] PxVec3;
    }

    /*
    \brief Assignment operator
    */
    operator_assign :: (this: *physx.PxTriangle, triangle: *physx.PxTriangle) -> void #cpp_method #foreign physxcommon_static "??4PxTriangle@physx@@QEAAXAEBV01@@Z";
    operator_assign :: (this: *physx.PxTriangle, triangle: physx.PxTriangle) #no_context {
        operator_assign(this, *triangle);
    }

    //! A padded version of PxTriangle, to safely load its data using SIMD
    PxTrianglePadded :: struct {
        #as using pxtriangle: PxTriangle;

        Constructor :: (this: *PxTrianglePadded) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxTrianglePadded@physx@@QEAA@XZ";
        Destructor :: (this: *PxTrianglePadded) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxTrianglePadded@physx@@QEAA@XZ";
        padding: PxU32;
    }

    /*
    \brief Mesh midphase structure. This enum is used to select the desired acceleration structure for midphase queries
    (i.e. raycasts, overlaps, sweeps vs triangle meshes).
    
    The PxMeshMidPhase::eBVH33 structure is the one used in recent PhysX versions (up to PhysX 3.3). It has great performance and is
    supported on all platforms. It is deprecated since PhysX 5.x.
    
    The PxMeshMidPhase::eBVH34 structure is a revisited implementation introduced in PhysX 3.4. It can be significantly faster both
    in terms of cooking performance and runtime performance.
    */
    PxMeshMidPhase :: struct {
        Enum :: enum s32 {
            BVH33 :: 0;
            BVH34 :: 1;

            LAST  :: 2;

            eBVH33 :: BVH33;
            eBVH34 :: BVH34;

            eLAST  :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Flags for the mesh geometry properties.
    
    Used in ::PxTriangleMeshFlags.
    */
    PxTriangleMeshFlag :: struct {
        Enum :: enum s32 {
            _16_BIT_INDICES    :: 2;
            ADJACENCY_INFO     :: 4;
            PREFER_NO_SDF_PROJ :: 8;

            e16_BIT_INDICES     :: _16_BIT_INDICES;
            eADJACENCY_INFO     :: ADJACENCY_INFO;
            ePREFER_NO_SDF_PROJ :: PREFER_NO_SDF_PROJ;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxTriangleMeshFlag.
    
    \see PxTriangleMeshFlag
    */
    PxTriangleMeshFlags :: PxFlags(PxTriangleMeshFlag.Enum, PxU8);
    operator~ :: (a: PxTriangleMeshFlag.Enum) -> PxFlags(PxTriangleMeshFlag.Enum, PxU8) #foreign physxcommon_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxTriangleMeshFlag@physx@@E@0@W4Enum@PxTriangleMeshFlag@0@@Z";

    /*
    
    \brief A triangle mesh, also called a 'polygon soup'.
    
    It is represented as an indexed triangle list. There are no restrictions on the
    triangle data.
    
    To avoid duplicating data when you have several instances of a particular
    mesh positioned differently, you do not use this class to represent a
    mesh object directly. Instead, you create an instance of this mesh via
    the PxTriangleMeshGeometry and PxShape classes.
    
    <h3>Creation</h3>
    
    To create an instance of this class call PxPhysics::createTriangleMesh(),
    and release() to delete it. This is only possible
    once you have released all of its PxShape instances.
    
    
    <h3>Visualizations:</h3>
    \li #PxVisualizationParameter::eCOLLISION_AABBS
    \li #PxVisualizationParameter::eCOLLISION_SHAPES
    \li #PxVisualizationParameter::eCOLLISION_AXES
    \li #PxVisualizationParameter::eCOLLISION_FNORMALS
    \li #PxVisualizationParameter::eCOLLISION_EDGES
    
    \see PxTriangleMeshDesc PxTriangleMeshGeometry PxShape PxPhysics.createTriangleMesh()
    */
    PxTriangleMesh :: struct {
        #as using pxrefcounted: PxRefCounted;

        Constructor :: (this: *PxTriangleMesh, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxTriangleMesh@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxTriangleMesh, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxTriangleMesh@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrefcounted; pxtrianglemesh_vtable: *PxTriangleMesh_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxTriangleMesh, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxTriangleMesh@physx@@MEAA@XZ";

        virtual_isKindOf :: (this: *PxTriangleMesh, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxTriangleMesh@physx@@MEBA_NPEBD@Z";
    }
    PxTriangleMesh_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        getNbVertices: (this: *PxTriangleMesh) -> PxU32 #cpp_method;

        getVertices: (this: *PxTriangleMesh) -> *PxVec3 #cpp_method;

        getVerticesForModification: (this: *PxTriangleMesh) -> *PxVec3 #cpp_method;

        refitBVH: (this: *PxTriangleMesh) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getNbTriangles: (this: *PxTriangleMesh) -> PxU32 #cpp_method;

        getTriangles: (this: *PxTriangleMesh) -> *void #cpp_method;

        getTriangleMeshFlags: (this: *PxTriangleMesh) -> PxTriangleMeshFlags #cpp_method;

        getTrianglesRemap: (this: *PxTriangleMesh) -> *PxU32 #cpp_method;

        getTriangleMaterialIndex: (this: *PxTriangleMesh, triangleIndex: PxTriangleID) -> PxMaterialTableIndex #cpp_method;

        getLocalBounds: (this: *PxTriangleMesh) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getSDF: (this: *PxTriangleMesh) -> *PxReal #cpp_method;

        getSDFDimensions: (this: *PxTriangleMesh, numX: *PxU32, numY: *PxU32, numZ: *PxU32) -> void #cpp_method;

        setPreferSDFProjection: (this: *PxTriangleMesh, preferProjection: bool) -> void #cpp_method;

        getPreferSDFProjection: (this: *PxTriangleMesh) -> bool #cpp_method;

        getMassInformation: (this: *PxTriangleMesh, mass: *PxReal, localInertia: *PxMat33, localCenterOfMass: *PxVec3) -> void #cpp_method;
    }

    PxTriangleMesh_getNbVertices :: inline (this: *PxTriangleMesh) -> PxU32 { return this.pxtrianglemesh_vtable.getNbVertices(this); }

    PxTriangleMesh_getVertices :: inline (this: *PxTriangleMesh) -> *PxVec3 { return this.pxtrianglemesh_vtable.getVertices(this); }

    PxTriangleMesh_getVerticesForModification :: inline (this: *PxTriangleMesh) -> *PxVec3 { return this.pxtrianglemesh_vtable.getVerticesForModification(this); }

    PxTriangleMesh_refitBVH :: inline (this: *PxTriangleMesh) -> PxBounds3 { return this.pxtrianglemesh_vtable.refitBVH(this); }

    PxTriangleMesh_getNbTriangles :: inline (this: *PxTriangleMesh) -> PxU32 { return this.pxtrianglemesh_vtable.getNbTriangles(this); }

    PxTriangleMesh_getTriangles :: inline (this: *PxTriangleMesh) -> *void { return this.pxtrianglemesh_vtable.getTriangles(this); }

    PxTriangleMesh_getTriangleMeshFlags :: inline (this: *PxTriangleMesh) -> PxTriangleMeshFlags { return this.pxtrianglemesh_vtable.getTriangleMeshFlags(this); }

    PxTriangleMesh_getTrianglesRemap :: inline (this: *PxTriangleMesh) -> *PxU32 { return this.pxtrianglemesh_vtable.getTrianglesRemap(this); }

    PxTriangleMesh_getTriangleMaterialIndex :: inline (this: *PxTriangleMesh, triangleIndex: PxTriangleID) -> PxMaterialTableIndex { return this.pxtrianglemesh_vtable.getTriangleMaterialIndex(this, triangleIndex); }

    PxTriangleMesh_getLocalBounds :: inline (this: *PxTriangleMesh) -> PxBounds3 { return this.pxtrianglemesh_vtable.getLocalBounds(this); }

    PxTriangleMesh_getSDF :: inline (this: *PxTriangleMesh) -> *PxReal { return this.pxtrianglemesh_vtable.getSDF(this); }

    PxTriangleMesh_getSDFDimensions :: inline (this: *PxTriangleMesh, numX: *PxU32, numY: *PxU32, numZ: *PxU32) { this.pxtrianglemesh_vtable.getSDFDimensions(this, numX, numY, numZ); }

    PxTriangleMesh_setPreferSDFProjection :: inline (this: *PxTriangleMesh, preferProjection: bool) { this.pxtrianglemesh_vtable.setPreferSDFProjection(this, preferProjection); }

    PxTriangleMesh_getPreferSDFProjection :: inline (this: *PxTriangleMesh) -> bool { return this.pxtrianglemesh_vtable.getPreferSDFProjection(this); }

    PxTriangleMesh_getMassInformation :: inline (this: *PxTriangleMesh, mass: *PxReal, localInertia: *PxMat33, localCenterOfMass: *PxVec3) { this.pxtrianglemesh_vtable.getMassInformation(this, mass, localInertia, localCenterOfMass); }

    vtable :: (obj: *PxTriangleMesh) -> *PxTriangleMesh_VTable { return obj.pxtrianglemesh_vtable; }


    /*
    \deprecated Use PxBVH34TriangleMesh instead.
    
    \brief A triangle mesh containing the PxMeshMidPhase::eBVH33 structure.
    
    \see PxMeshMidPhase
    */
    PxBVH33TriangleMesh :: struct {
        #as using pxtrianglemesh: PxTriangleMesh;
    }

    /*
    
    \brief A triangle mesh containing the PxMeshMidPhase::eBVH34 structure.
    
    \see PxMeshMidPhase
    */
    PxBVH34TriangleMesh :: struct {
        #as using pxtrianglemesh: PxTriangleMesh;
    }

    /*
    \brief Tetrahedron class.
    */
    PxTetrahedron :: struct {
        /*
        \brief Array of Vertices.
        */
        verts: [4] PxVec3;
    }

    PxTetrahedronMeshFlag :: struct {
        Enum :: enum s32 {
            e16_BIT_INDICES :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxTetrahedronMeshFlag.
    
    \see PxTetrahedronMeshFlag
    */
    PxTetrahedronMeshFlags :: PxFlags(PxTetrahedronMeshFlag.Enum, PxU8);

    /*
    \brief A data container providing mass, rest pose and other information required for softbody simulation
    
    Stores properties of softbody like inverse mass per node, rest pose matrix per tetrahedral element etc.
    Mainly used internally to store runtime data.
    
    */
    PxSoftBodyAuxData :: struct {
        #as using pxrefcounted: PxRefCounted;

        Constructor :: (this: *PxSoftBodyAuxData, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxSoftBodyAuxData@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrefcounted; pxsoftbodyauxdata_vtable: *PxSoftBodyAuxData_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxSoftBodyAuxData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxSoftBodyAuxData@physx@@MEAA@XZ";

        virtual_isKindOf :: (this: *PxSoftBodyAuxData, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxSoftBodyAuxData@physx@@MEBA_NPEBD@Z";
    }
    PxSoftBodyAuxData_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        getGridModelInvMass: (this: *PxSoftBodyAuxData) -> *PxReal #cpp_method;
    }
    PxSoftBodyAuxData_getGridModelInvMass :: inline (this: *PxSoftBodyAuxData) -> *PxReal { return this.pxsoftbodyauxdata_vtable.getGridModelInvMass(this); }

    vtable :: (obj: *PxSoftBodyAuxData) -> *PxSoftBodyAuxData_VTable { return obj.pxsoftbodyauxdata_vtable; }


    /*
    \brief A tetramedron mesh, also called a 'tetrahedron soup'.
    
    It is represented as an indexed tetrahedron list. There are no restrictions on the
    tetrahedron data.
    
    To avoid duplicating data when you have several instances of a particular
    mesh positioned differently, you do not use this class to represent a
    mesh object directly. Instead, you create an instance of this mesh via
    the PxTetrahedronMeshGeometry and PxShape classes.
    
    <h3>Creation</h3>
    
    To create an instance of this class call PxPhysics::createTetrahedronMesh(),
    and release() to delete it. This is only possible
    once you have released all of its PxShape instances.
    
    
    <h3>Visualizations:</h3>
    \li #PxVisualizationParameter::eCOLLISION_AABBS
    \li #PxVisualizationParameter::eCOLLISION_SHAPES
    \li #PxVisualizationParameter::eCOLLISION_AXES
    \li #PxVisualizationParameter::eCOLLISION_FNORMALS
    \li #PxVisualizationParameter::eCOLLISION_EDGES
    
    \see PxTetrahedronMeshDesc PxTetrahedronMeshGeometry PxShape PxPhysics.createTetrahedronMesh()
    */
    PxTetrahedronMesh :: struct {
        #as using pxrefcounted: PxRefCounted;

        Constructor :: (this: *PxTetrahedronMesh, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxTetrahedronMesh@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrefcounted; pxtetrahedronmesh_vtable: *PxTetrahedronMesh_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxTetrahedronMesh, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxTetrahedronMesh@physx@@MEAA@XZ";

        virtual_isKindOf :: (this: *PxTetrahedronMesh, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxTetrahedronMesh@physx@@MEBA_NPEBD@Z";
    }
    PxTetrahedronMesh_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        getNbVertices: (this: *PxTetrahedronMesh) -> PxU32 #cpp_method;

        getVertices: (this: *PxTetrahedronMesh) -> *PxVec3 #cpp_method;

        getNbTetrahedrons: (this: *PxTetrahedronMesh) -> PxU32 #cpp_method;

        getTetrahedrons: (this: *PxTetrahedronMesh) -> *void #cpp_method;

        getTetrahedronMeshFlags: (this: *PxTetrahedronMesh) -> PxTetrahedronMeshFlags #cpp_method;

        getTetrahedraRemap: (this: *PxTetrahedronMesh) -> *PxU32 #cpp_method;

        getLocalBounds: (this: *PxTetrahedronMesh) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;
    }

    PxTetrahedronMesh_getNbVertices :: inline (this: *PxTetrahedronMesh) -> PxU32 { return this.pxtetrahedronmesh_vtable.getNbVertices(this); }

    PxTetrahedronMesh_getVertices :: inline (this: *PxTetrahedronMesh) -> *PxVec3 { return this.pxtetrahedronmesh_vtable.getVertices(this); }

    PxTetrahedronMesh_getNbTetrahedrons :: inline (this: *PxTetrahedronMesh) -> PxU32 { return this.pxtetrahedronmesh_vtable.getNbTetrahedrons(this); }

    PxTetrahedronMesh_getTetrahedrons :: inline (this: *PxTetrahedronMesh) -> *void { return this.pxtetrahedronmesh_vtable.getTetrahedrons(this); }

    PxTetrahedronMesh_getTetrahedronMeshFlags :: inline (this: *PxTetrahedronMesh) -> PxTetrahedronMeshFlags { return this.pxtetrahedronmesh_vtable.getTetrahedronMeshFlags(this); }

    PxTetrahedronMesh_getTetrahedraRemap :: inline (this: *PxTetrahedronMesh) -> *PxU32 { return this.pxtetrahedronmesh_vtable.getTetrahedraRemap(this); }

    PxTetrahedronMesh_getLocalBounds :: inline (this: *PxTetrahedronMesh) -> PxBounds3 { return this.pxtetrahedronmesh_vtable.getLocalBounds(this); }

    vtable :: (obj: *PxTetrahedronMesh) -> *PxTetrahedronMesh_VTable { return obj.pxtetrahedronmesh_vtable; }


    /*
    \brief A softbody mesh, containing structures to store collision shape, simulation shape and deformation state
    
    The class bundles shapes and deformation state of a softbody that is simulated using FEM. The meshes used for
    collision detection and for the FEM calculations are both tetrahedral meshes. While collision detection requires
    a mesh that matches the surface of the simulated body as exactly as possible, the simulation mesh has more freedom
    such that it can be optimized for tetrahedra without small angles and nodes that aren't shared by too many elements.
    
    <h3>Creation</h3>
    
    To create an instance of this class call PxPhysics::createSoftBodyMesh(),
    and release() to delete it. This is only possible
    once you have released all of its PxShape instances.
    
    */
    PxSoftBodyMesh :: struct {
        #as using pxrefcounted: PxRefCounted;

        Constructor :: (this: *PxSoftBodyMesh, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physxcommon_static "??0PxSoftBodyMesh@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrefcounted; pxsoftbodymesh_vtable: *PxSoftBodyMesh_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxSoftBodyMesh, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxSoftBodyMesh@physx@@MEAA@XZ";

        virtual_isKindOf :: (this: *PxSoftBodyMesh, name: *u8) -> bool #cpp_method #foreign physxcommon_static "?isKindOf@PxSoftBodyMesh@physx@@MEBA_NPEBD@Z";
    }
    PxSoftBodyMesh_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        getCollisionMesh_1: (this: *PxSoftBodyMesh) -> *PxTetrahedronMesh #cpp_method;

        getCollisionMesh: (this: /*const*/ *PxSoftBodyMesh) -> *PxTetrahedronMesh #cpp_method;

        getSimulationMesh_1: (this: *PxSoftBodyMesh) -> *PxTetrahedronMesh #cpp_method;

        getSimulationMesh: (this: /*const*/ *PxSoftBodyMesh) -> *PxTetrahedronMesh #cpp_method;

        getSoftBodyAuxData_1: (this: *PxSoftBodyMesh) -> *PxSoftBodyAuxData #cpp_method;

        getSoftBodyAuxData: (this: /*const*/ *PxSoftBodyMesh) -> *PxSoftBodyAuxData #cpp_method;
    }

    PxSoftBodyMesh_getCollisionMesh_1 :: inline (this: *PxSoftBodyMesh) -> *PxTetrahedronMesh { return this.pxsoftbodymesh_vtable.getCollisionMesh_1(this); }

    PxSoftBodyMesh_getCollisionMesh :: inline (this: /*const*/ *PxSoftBodyMesh) -> *PxTetrahedronMesh { return this.pxsoftbodymesh_vtable.getCollisionMesh(this); }

    PxSoftBodyMesh_getSimulationMesh_1 :: inline (this: *PxSoftBodyMesh) -> *PxTetrahedronMesh { return this.pxsoftbodymesh_vtable.getSimulationMesh_1(this); }

    PxSoftBodyMesh_getSimulationMesh :: inline (this: /*const*/ *PxSoftBodyMesh) -> *PxTetrahedronMesh { return this.pxsoftbodymesh_vtable.getSimulationMesh(this); }

    PxSoftBodyMesh_getSoftBodyAuxData_1 :: inline (this: *PxSoftBodyMesh) -> *PxSoftBodyAuxData { return this.pxsoftbodymesh_vtable.getSoftBodyAuxData_1(this); }

    PxSoftBodyMesh_getSoftBodyAuxData :: inline (this: /*const*/ *PxSoftBodyMesh) -> *PxSoftBodyAuxData { return this.pxsoftbodymesh_vtable.getSoftBodyAuxData(this); }

    vtable :: (obj: *PxSoftBodyMesh) -> *PxSoftBodyMesh_VTable { return obj.pxsoftbodymesh_vtable; }


    /*
    
    \brief Contains information about how to update the collision mesh's vertices given a deformed simulation tetmesh.
    
    \see PxTetrahedronMeshData
    */
    PxCollisionMeshMappingData :: struct {
        #as using pxuserallocated: PxUserAllocated;
        vtable: *PxCollisionMeshMappingData_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxCollisionMeshMappingData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxCollisionMeshMappingData@physx@@UEAA@XZ";
    }
    PxCollisionMeshMappingData_VTable :: struct #type_info_none {
        release: (this: *PxCollisionMeshMappingData) -> void #cpp_method;

        Destructor: (this: *PxCollisionMeshMappingData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCollisionMeshMappingData_release :: inline (this: *PxCollisionMeshMappingData) { this.vtable.release(this); }

    PxCollisionMeshMappingData_Destructor :: inline (this: *PxCollisionMeshMappingData, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCollisionMeshMappingData) -> *PxCollisionMeshMappingData_VTable { return obj.vtable; }


    /*
    
    \brief Stores data to accelerate collision detection of a tetrahedral mesh
    
    \see PxTetrahedronMeshData
    */
    PxSoftBodyCollisionData :: struct {
        #as using pxuserallocated: PxUserAllocated;
    }

    /*
    
    \brief Contains raw geometry information describing the tetmesh's vertices and its elements (tetrahedra)
    
    \see PxTetrahedronMeshData
    */
    PxTetrahedronMeshData :: struct {
        #as using pxuserallocated: PxUserAllocated;
    }

    /*
    
    \brief Stores data to compute and store the state of a deformed tetrahedral mesh
    
    \see PxTetrahedronMeshData
    */
    PxSoftBodySimulationData :: struct {
        #as using pxuserallocated: PxUserAllocated;
    }

    /*
    
    \brief Conbines PxTetrahedronMeshData and PxSoftBodyCollisionData
    
    \see PxTetrahedronMeshData PxSoftBodyCollisionData
    */
    PxCollisionTetrahedronMeshData :: struct {
        #as using pxuserallocated: PxUserAllocated;
        vtable: *PxCollisionTetrahedronMeshData_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxCollisionTetrahedronMeshData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxCollisionTetrahedronMeshData@physx@@UEAA@XZ";
    }
    PxCollisionTetrahedronMeshData_VTable :: struct #type_info_none {
        getMesh_1: (this: *PxCollisionTetrahedronMeshData) -> *PxTetrahedronMeshData #cpp_method;

        getMesh: (this: /*const*/ *PxCollisionTetrahedronMeshData) -> *PxTetrahedronMeshData #cpp_method;

        getData_1: (this: *PxCollisionTetrahedronMeshData) -> *PxSoftBodyCollisionData #cpp_method;

        getData: (this: /*const*/ *PxCollisionTetrahedronMeshData) -> *PxSoftBodyCollisionData #cpp_method;

        release: (this: *PxCollisionTetrahedronMeshData) -> void #cpp_method;

        Destructor: (this: *PxCollisionTetrahedronMeshData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCollisionTetrahedronMeshData_getMesh_1 :: inline (this: *PxCollisionTetrahedronMeshData) -> *PxTetrahedronMeshData { return this.vtable.getMesh_1(this); }

    PxCollisionTetrahedronMeshData_getMesh :: inline (this: /*const*/ *PxCollisionTetrahedronMeshData) -> *PxTetrahedronMeshData { return this.vtable.getMesh(this); }

    PxCollisionTetrahedronMeshData_getData_1 :: inline (this: *PxCollisionTetrahedronMeshData) -> *PxSoftBodyCollisionData { return this.vtable.getData_1(this); }

    PxCollisionTetrahedronMeshData_getData :: inline (this: /*const*/ *PxCollisionTetrahedronMeshData) -> *PxSoftBodyCollisionData { return this.vtable.getData(this); }

    PxCollisionTetrahedronMeshData_release :: inline (this: *PxCollisionTetrahedronMeshData) { this.vtable.release(this); }

    PxCollisionTetrahedronMeshData_Destructor :: inline (this: *PxCollisionTetrahedronMeshData, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCollisionTetrahedronMeshData) -> *PxCollisionTetrahedronMeshData_VTable { return obj.vtable; }


    /*
    
    \brief Conbines PxTetrahedronMeshData and PxSoftBodyCollisionData
    
    \see PxTetrahedronMeshData PxSoftBodySimulationData
    */
    PxSimulationTetrahedronMeshData :: struct {
        #as using pxuserallocated: PxUserAllocated;
        vtable: *PxSimulationTetrahedronMeshData_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxSimulationTetrahedronMeshData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcommon_static "??1PxSimulationTetrahedronMeshData@physx@@UEAA@XZ";
    }
    PxSimulationTetrahedronMeshData_VTable :: struct #type_info_none {
        getMesh: (this: *PxSimulationTetrahedronMeshData) -> *PxTetrahedronMeshData #cpp_method;
        getData: (this: *PxSimulationTetrahedronMeshData) -> *PxSoftBodySimulationData #cpp_method;
        release: (this: *PxSimulationTetrahedronMeshData) -> void #cpp_method;

        Destructor: (this: *PxSimulationTetrahedronMeshData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSimulationTetrahedronMeshData_getMesh :: inline (this: *PxSimulationTetrahedronMeshData) -> *PxTetrahedronMeshData { return this.vtable.getMesh(this); }
    PxSimulationTetrahedronMeshData_getData :: inline (this: *PxSimulationTetrahedronMeshData) -> *PxSoftBodySimulationData { return this.vtable.getData(this); }
    PxSimulationTetrahedronMeshData_release :: inline (this: *PxSimulationTetrahedronMeshData) { this.vtable.release(this); }

    PxSimulationTetrahedronMeshData_Destructor :: inline (this: *PxSimulationTetrahedronMeshData, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSimulationTetrahedronMeshData) -> *PxSimulationTetrahedronMeshData_VTable { return obj.vtable; }


    PxAggregateType :: struct {
        Enum :: enum s32 {
            GENERIC   :: 0;
            STATIC    :: 1;
            KINEMATIC :: 2;

            eGENERIC   :: GENERIC;
            eSTATIC    :: STATIC;
            eKINEMATIC :: KINEMATIC;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    // PxAggregateFilterHint is used for more efficient filtering of aggregates outside of the broadphase.
    // It is a combination of a PxAggregateType and a self-collision bit.
    PxAggregateFilterHint :: PxU32;

    PxGetAggregateSelfCollisionBit :: (hint: PxAggregateFilterHint) -> PxU32 #foreign physx_static "?PxGetAggregateSelfCollisionBit@physx@@YAII@Z";

    PxGetAggregateType :: (hint: PxAggregateFilterHint) -> PxAggregateType.Enum #foreign physx_static "?PxGetAggregateType@physx@@YA?AW4Enum@PxAggregateType@1@I@Z";

    /*
    \brief Class to aggregate actors into a single broad-phase entry.
    
    A PxAggregate object is a collection of PxActors, which will exist as a single entry in the
    broad-phase structures. This has 3 main benefits:
    
    1) it reduces "broad phase pollution" by allowing a collection of spatially coherent broad-phase
    entries to be replaced by a single aggregated entry (e.g. a ragdoll or a single actor with a
    large number of attached shapes).
    
    2) it reduces broad-phase memory usage
    
    3) filtering can be optimized a lot if self-collisions within an aggregate are not needed. For
    example if you don't need collisions between ragdoll bones, it's faster to simply disable
    filtering once and for all, for the aggregate containing the ragdoll, rather than filtering
    out each bone-bone collision in the filter shader.
    
    \see PxActor, PxPhysics.createAggregate
    */
    PxAggregate :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxAggregate, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxAggregate@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxAggregate, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxAggregate@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxaggregate_vtable: *PxAggregate_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxAggregate) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxAggregate@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxAggregate, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxAggregate@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxAggregate, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxAggregate@physx@@MEBA_NPEBD@Z";
    }
    PxAggregate_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        addActor: (this: *PxAggregate, actor: *PxActor, bvh: *PxBVH = null) -> bool #cpp_method;

        removeActor: (this: *PxAggregate, actor: *PxActor) -> bool #cpp_method;

        addArticulation: (this: *PxAggregate, articulation: *PxArticulationReducedCoordinate) -> bool #cpp_method;

        removeArticulation: (this: *PxAggregate, articulation: *PxArticulationReducedCoordinate) -> bool #cpp_method;

        getNbActors: (this: *PxAggregate) -> PxU32 #cpp_method;

        getMaxNbActors: (this: *PxAggregate) -> PxU32 #cpp_method;

        getMaxNbShapes: (this: *PxAggregate) -> PxU32 #cpp_method;

        getActors: (this: *PxAggregate, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getScene: (this: *PxAggregate) -> *PxScene #cpp_method;

        getSelfCollision: (this: *PxAggregate) -> bool #cpp_method;
    }

    PxAggregate_addActor :: inline (this: *PxAggregate, actor: *PxActor, bvh: *PxBVH = null) -> bool { return this.pxaggregate_vtable.addActor(this, actor, bvh); }

    PxAggregate_removeActor :: inline (this: *PxAggregate, actor: *PxActor) -> bool { return this.pxaggregate_vtable.removeActor(this, actor); }

    PxAggregate_addArticulation :: inline (this: *PxAggregate, articulation: *PxArticulationReducedCoordinate) -> bool { return this.pxaggregate_vtable.addArticulation(this, articulation); }

    PxAggregate_removeArticulation :: inline (this: *PxAggregate, articulation: *PxArticulationReducedCoordinate) -> bool { return this.pxaggregate_vtable.removeArticulation(this, articulation); }

    PxAggregate_getNbActors :: inline (this: *PxAggregate) -> PxU32 { return this.pxaggregate_vtable.getNbActors(this); }

    PxAggregate_getMaxNbActors :: inline (this: *PxAggregate) -> PxU32 { return this.pxaggregate_vtable.getMaxNbActors(this); }

    PxAggregate_getMaxNbShapes :: inline (this: *PxAggregate) -> PxU32 { return this.pxaggregate_vtable.getMaxNbShapes(this); }

    PxAggregate_getActors :: inline (this: *PxAggregate, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxaggregate_vtable.getActors(this, userBuffer, bufferSize, startIndex); }

    PxAggregate_getScene :: inline (this: *PxAggregate) -> *PxScene { return this.pxaggregate_vtable.getScene(this); }

    PxAggregate_getSelfCollision :: inline (this: *PxAggregate) -> bool { return this.pxaggregate_vtable.getSelfCollision(this); }

    vtable :: (obj: *PxAggregate) -> *PxAggregate_VTable { return obj.pxaggregate_vtable; }


    pvdsdk :: struct {
        PvdDataStream :: struct {}

        PvdClient :: struct {}
    }

    /*
    \brief Constraint row flags
    
    These flags configure the post-processing of constraint rows and the behavior of the solver while solving constraints
    */
    Px1DConstraintFlag :: struct {
        Type :: enum s32 {
            SPRING               :: 1;
            ACCELERATION_SPRING  :: 2;
            RESTITUTION          :: 4;
            KEEPBIAS             :: 8;
            OUTPUT_FORCE         :: 16;
            HAS_DRIVE_LIMIT      :: 32;
            ANGULAR_CONSTRAINT   :: 64;
            DEPRECATED_DRIVE_ROW :: 128;

            eSPRING               :: SPRING;
            eACCELERATION_SPRING  :: ACCELERATION_SPRING;
            eRESTITUTION          :: RESTITUTION;
            eKEEPBIAS             :: KEEPBIAS;
            eOUTPUT_FORCE         :: OUTPUT_FORCE;
            eHAS_DRIVE_LIMIT      :: HAS_DRIVE_LIMIT;
            eANGULAR_CONSTRAINT   :: ANGULAR_CONSTRAINT;
            eDEPRECATED_DRIVE_ROW :: DEPRECATED_DRIVE_ROW;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    Px1DConstraintFlags :: PxFlags(Px1DConstraintFlag.Type, PxU16);

    /*
    \brief Constraint type hints which the solver uses to optimize constraint handling
    */
    PxConstraintSolveHint :: struct {
        Enum :: enum s32 {
            NONE                  :: 0;
            ACCELERATION1         :: 256;
            SLERP_SPRING          :: 258;
            ACCELERATION2         :: 512;
            ACCELERATION3         :: 768;
            ROTATIONAL_EQUALITY   :: 1024;
            ROTATIONAL_INEQUALITY :: 1025;

            EQUALITY              :: 2048;

            INEQUALITY            :: 2049;

            eNONE                  :: NONE;
            eACCELERATION1         :: ACCELERATION1;
            eSLERP_SPRING          :: SLERP_SPRING;
            eACCELERATION2         :: ACCELERATION2;
            eACCELERATION3         :: ACCELERATION3;
            eROTATIONAL_EQUALITY   :: ROTATIONAL_EQUALITY;
            eROTATIONAL_INEQUALITY :: ROTATIONAL_INEQUALITY;

            eEQUALITY              :: EQUALITY;

            eINEQUALITY            :: INEQUALITY;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief A one-dimensional constraint that constrains the relative motion of two rigid bodies.
    
    A constraint is expressed as a set of 1-dimensional constraint rows which define the required constraint
    on the objects' velocities.
    
    The constraint Jacobian J is specified by the parameters linear0, angular0, linear1, angular1 as follows
    
    J = {linear0, angular0, -linear1, -angular1}
    
    The velocity target of the constraint is specified by Px1DConstraint::velocityTarget and the geometric error of the constraint
    is specified by Px1DConstraint::geometricError.
    
    The output of the constraint is a velocity state (sdot = ds/dt with s denoting the constraint state) expressed in the world frame:
    
    sdot = {linearVelocity0, angularVelocity0, linearVelocity1, angularVelocity1}
    
    with linearVelocity0 and angularVelocity0 denoting the linear and angular velocity of body0 of the constraint;
    and linearVelocity1 and angularVelocity1 denoting the linear and angular velocity of body1 of the constraint.
    
    The constraint seeks an updated sdot that obeys a simple constraint rule:
    
    J*sdot + BaumgarteTerm*geometricError/dt - velocityTarget = 0
    
    where BaumgarteTerm is a multiplier in range (0, 1). The Baumgarte term is not exposed but is instead internally
    set according to a simple metric chosen to enhance numerical stability. If the PGS solver is employed then dt is
    taken from the scene timestep.
    
    Another way of expressing the constraint rule is as follows:
    
    linear0.dot(linearVelocity0) + angular0.dot(angularVelocity0)
    - linear1.dot(linearVelocity1) - angular1.dot(angularVelocity1)
    + BaumgarteTerm*geometricError/dt - velocityTarget = 0
    
    The PhysX solver runs two phases: position iterations followed by velocity iterations. Position iterations derive
    the velocity that is used to integrate the transform of a rigid body. Velocity iterations on the other hand derive
    the final velocity of a rigid body. The constraint rule presented above only gets applied during position iterations,
    during velocity iterations the geometricError term is usually ignored and the applied constraint rule is:
    
    J*sdot - velocityTarget = 0
    
    The flag Px1DConstraintFlag::eKEEPBIAS can be used to have velocity iterations apply the same constraint rule as
    position iterations.
    
    A 1d constraint may be either a restitution constraint or a hard constraint or a spring constraint.
    
    Restitution constraints have two modes of operation, depending on the speed of the constraint. These two modes are:
    a) a bounce mode that employs a restitution value specified by RestitutionModifiers::restitution
    b) a non-bounce mode that employs zero restitution and ignores RestitutionModifiers::restitution.
    The constraint speed immediately before the solver begins is computed as follows:
    constraintPreSolverSpeed = J * sdotPreSolver
    with sdotPreSolver denoting the rigid body velocities recorded after applying external forces and torques to the rigid bodies
    but before the solver begins.
    If the bounce mode is active, the pre solver velocity is expected to flip direction and have restitution applied:
    bounceSpeed = -restitution * constraintPreSolverSpeed
    Restitution will kick in if the following conditions are met:
    \li -constraintPreSolverSpeed exceeds the bounce threshold (RestitutionModifiers::velocityThreshold)
    \li (bounceSpeed * Px1DConstraint::geometricError) <= 0 (bounceSpeed points in the
    opposite direction of the geometric error)
    If these hold, then the provided Px1DConstraint::geometricError and Px1DConstraint::velocityTarget parameter will get overriden
    internally. The former will get set to zero, the latter will get set to bounceSpeed. If restitution does not activate because
    the listed conditions are not met, then the target velocity will be taken from the value stored in velocityTarget and the
    geometric error will be taken from the value stored in geometricError.
    RestitutionModifiers::restitution may be greater than 1 and may be less than 0 ie it is not limited to 0 <= restitution <= 1.
    
    Hard constraints attempt to find sdot that satisfies the constraint equation:
    
    J*sdot + BaumgarteTerm*geometricError/dt - velocityTarget = 0
    
    Spring constraints are quite different from restitution and hard constraints in that they attempt to compute and apply a spring force as follows:
    
    F = stiffness * -geometricError + damping * (velocityTarget - J*sdot)
    
    where F is the constraint force or acceleration and J*sdot is the instantaneous constraint speed. Springs are
    implemented with a fully implicit time-stepping scheme: that is, the force or acceleration is a function of the position
    and velocity after the solve. Note that F gets applied to the first rigid body and -F to the second rigid body.
    
    All constraints support limits on the minimum or maximum impulse applied.
    */
    Px1DConstraint :: struct {
        linear0:        PxVec3; //!< linear component of velocity jacobian in world space
        geometricError: PxReal; //!< geometric error of the constraint along this axis
        angular0:       PxVec3; //!< angular component of velocity jacobian in world space
        velocityTarget: PxReal; //!< velocity target for the constraint along this axis

        linear1:        PxVec3; //!< linear component of velocity jacobian in world space
        minImpulse:     PxReal; //!< minimum impulse the solver may apply to enforce this constraint
        angular1:       PxVec3; //!< angular component of velocity jacobian in world space
        maxImpulse:     PxReal; //!< maximum impulse the solver may apply to enforce this constraint

        mods:           union {
            SpringModifiers :: struct {
                stiffness: PxReal; //!< spring parameter, for spring constraints
                damping:   PxReal; //!< damping parameter, for spring constraints
            }

            spring: SpringModifiers;
            RestitutionModifiers :: struct {
                restitution:       PxReal; //!< restitution parameter for determining additional "bounce"
                velocityThreshold: PxReal; //!< minimum impact velocity for bounce
            }

            bounce: RestitutionModifiers;
        };

        flags:          PxU16; //!< a set of Px1DConstraintFlags
        solveHint:      PxU16; //!< constraint optimization hint, should be an element of PxConstraintSolveHint

        pad:            PxU32; // for padding only
    }

    /*
    \brief Flags for determining which components of the constraint should be visualized.
    
    \see PxConstraintVisualize
    */
    PxConstraintVisualizationFlag :: struct {
        Enum :: enum s32 {
            OCAL_FRAMES :: 1;
            IMITS       :: 2;

            eLOCAL_FRAMES :: OCAL_FRAMES;
            eLIMITS       :: IMITS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Struct for specifying mass scaling for a pair of rigids
    */
    PxConstraintInvMassScale :: struct {
        linear0:  PxReal; //!< multiplier for inverse mass of body0
        angular0: PxReal; //!< multiplier for inverse MoI of body0
        linear1:  PxReal; //!< multiplier for inverse mass of body1
        angular1: PxReal; //!< multiplier for inverse MoI of body1

        Constructor :: (this: *PxConstraintInvMassScale) -> void #cpp_method #foreign physx_static "??0PxConstraintInvMassScale@physx@@QEAA@XZ";
    }

    /*
    \brief Solver constraint generation shader
    
    This function is called by the constraint solver framework. The function must be reentrant, since it may be called simultaneously
    from multiple threads, and should access only the arguments passed into it.
    
    Developers writing custom constraints are encouraged to read the documentation in the user guide and the implementation code in PhysXExtensions.
    
    \param[out] constraints			An array of solver constraint rows to be filled in
    \param[out] bodyAWorldOffset	The origin point (offset from the position vector of bodyA's center of mass) at which the constraint is resolved. This value does not affect how constraints are solved, only the constraint force reported.
    \param[in] maxConstraints		The size of the constraint buffer. At most this many constraints rows may be written
    \param[out] invMassScale		The inverse mass and inertia scales for the constraint
    \param[in] constantBlock		The constant data block
    \param[in] bodyAToWorld			The center of mass frame of the first constrained body (the identity transform if the first actor is static, or if a NULL actor pointer was provided for it)
    \param[in] bodyBToWorld			The center of mass frame of the second constrained body (the identity transform if the second actor is static, or if a NULL actor pointer was provided for it)
    \param[in] useExtendedLimits	Enables limit ranges outside of (-PI, PI)
    \param[out] cAtW				The world space location of body A's joint frame (position only)
    \param[out] cBtW				The world space location of body B's joint frame (position only)
    
    \return the number of constraint rows written.
    */
    PxConstraintSolverPrep :: #type (constraints: *Px1DConstraint, bodyAWorldOffset: *PxVec3p, maxConstraints: PxU32, invMassScale: *PxConstraintInvMassScale, constantBlock: *void, bodyAToWorld: *PxTransform, bodyBToWorld: *PxTransform, useExtendedLimits: bool, cAtW: *PxVec3p, cBtW: *PxVec3p) -> PxU32 #c_call;

    /*
    \brief API used to visualize details about a constraint.
    */
    PxConstraintVisualizer :: struct {
        vtable: *PxConstraintVisualizer_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxConstraintVisualizer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxConstraintVisualizer@physx@@MEAA@XZ";
    }
    PxConstraintVisualizer_VTable :: struct #type_info_none {
        Destructor: (this: *PxConstraintVisualizer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        visualizeJointFrames: (this: *PxConstraintVisualizer, parent: *PxTransform, child: *PxTransform) -> void #cpp_method;

        visualizeLinearLimit: (this: *PxConstraintVisualizer, t0: *PxTransform, t1: *PxTransform, value: PxReal) -> void #cpp_method;

        visualizeAngularLimit: (this: *PxConstraintVisualizer, t0: *PxTransform, lower: PxReal, upper: PxReal) -> void #cpp_method;

        visualizeLimitCone: (this: *PxConstraintVisualizer, t: *PxTransform, tanQSwingY: PxReal, tanQSwingZ: PxReal) -> void #cpp_method;

        visualizeDoubleCone: (this: *PxConstraintVisualizer, t: *PxTransform, angle: PxReal) -> void #cpp_method;

        visualizeLine: (this: *PxConstraintVisualizer, p0: *PxVec3, p1: *PxVec3, color: PxU32) -> void #cpp_method;
    }

    PxConstraintVisualizer_Destructor :: inline (this: *PxConstraintVisualizer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxConstraintVisualizer_visualizeJointFrames :: inline (this: *PxConstraintVisualizer, parent: *PxTransform, child: *PxTransform) { this.vtable.visualizeJointFrames(this, parent, child); }

    PxConstraintVisualizer_visualizeLinearLimit :: inline (this: *PxConstraintVisualizer, t0: *PxTransform, t1: *PxTransform, value: PxReal) { this.vtable.visualizeLinearLimit(this, t0, t1, value); }

    PxConstraintVisualizer_visualizeAngularLimit :: inline (this: *PxConstraintVisualizer, t0: *PxTransform, lower: PxReal, upper: PxReal) { this.vtable.visualizeAngularLimit(this, t0, lower, upper); }

    PxConstraintVisualizer_visualizeLimitCone :: inline (this: *PxConstraintVisualizer, t: *PxTransform, tanQSwingY: PxReal, tanQSwingZ: PxReal) { this.vtable.visualizeLimitCone(this, t, tanQSwingY, tanQSwingZ); }

    PxConstraintVisualizer_visualizeDoubleCone :: inline (this: *PxConstraintVisualizer, t: *PxTransform, angle: PxReal) { this.vtable.visualizeDoubleCone(this, t, angle); }

    PxConstraintVisualizer_visualizeLine :: inline (this: *PxConstraintVisualizer, p0: *PxVec3, p1: *PxVec3, color: PxU32) { this.vtable.visualizeLine(this, p0, p1, color); }

    vtable :: (obj: *PxConstraintVisualizer) -> *PxConstraintVisualizer_VTable { return obj.vtable; }


    /* \brief Solver constraint visualization function
    
    This function is called by the constraint post-solver framework to visualize the constraint
    
    \param[out] visualizer		The render buffer to render to
    \param[in] constantBlock	The constant data block
    \param[in] body0Transform	The center of mass frame of the first constrained body (the identity if the actor is static, or a NULL pointer was provided for it)
    \param[in] body1Transform	The center of mass frame of the second constrained body (the identity if the actor is static, or a NULL pointer was provided for it)
    \param[in] flags			The visualization flags (PxConstraintVisualizationFlag)
    
    \see PxRenderBuffer
    */
    PxConstraintVisualize :: #type (visualizer: *PxConstraintVisualizer, constantBlock: *void, body0Transform: *PxTransform, body1Transform: *PxTransform, flags: PxU32) -> void #c_call;

    /*
    \brief Flags for determining how PVD should serialize a constraint update
    
    \see PxConstraintConnector::updatePvdProperties, PvdSceneClient::updateConstraint
    */
    PxPvdUpdateType :: struct {
        Enum :: enum s32 {
            CREATE_INSTANCE       :: 0;
            RELEASE_INSTANCE      :: 1;
            UPDATE_ALL_PROPERTIES :: 2;
            UPDATE_SIM_PROPERTIES :: 3;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief This class connects a custom constraint to the SDK
    
    This class connects a custom constraint to the SDK, and functions are called by the SDK
    to query the custom implementation for specific information to pass on to the application
    or inform the constraint when the application makes calls into the SDK which will update
    the custom constraint's internal implementation
    */
    PxConstraintConnector :: struct {
        vtable: *PxConstraintConnector_VTable;
    }
    PxConstraintConnector_VTable :: struct #type_info_none {
        prepareData: (this: *PxConstraintConnector) -> *void #cpp_method;

        updatePvdProperties: (this: *PxConstraintConnector, pvdConnection: *pvdsdk.PvdDataStream, c: *PxConstraint, updateType: PxPvdUpdateType.Enum) -> bool #cpp_method;

        updateOmniPvdProperties: (this: *PxConstraintConnector) -> void #cpp_method;

        onConstraintRelease: (this: *PxConstraintConnector) -> void #cpp_method;

        onComShift: (this: *PxConstraintConnector, actor: PxU32) -> void #cpp_method;

        onOriginShift: (this: *PxConstraintConnector, shift: *PxVec3) -> void #cpp_method;

        getExternalReference: (this: *PxConstraintConnector, typeID: *PxU32) -> *void #cpp_method;

        getSerializable: (this: *PxConstraintConnector) -> *PxBase #cpp_method;

        getPrep: (this: *PxConstraintConnector) -> PxConstraintSolverPrep #cpp_method;

        getConstantBlock: (this: *PxConstraintConnector) -> *void #cpp_method;

        connectToConstraint: (this: *PxConstraintConnector, unknown0: *PxConstraint) -> void #cpp_method;

        Destructor: (this: *PxConstraintConnector, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxConstraintConnector_prepareData :: inline (this: *PxConstraintConnector) -> *void { return this.vtable.prepareData(this); }

    PxConstraintConnector_updatePvdProperties :: inline (this: *PxConstraintConnector, pvdConnection: *pvdsdk.PvdDataStream, c: *PxConstraint, updateType: PxPvdUpdateType.Enum) -> bool { return this.vtable.updatePvdProperties(this, pvdConnection, c, updateType); }

    PxConstraintConnector_updateOmniPvdProperties :: inline (this: *PxConstraintConnector) { this.vtable.updateOmniPvdProperties(this); }

    PxConstraintConnector_onConstraintRelease :: inline (this: *PxConstraintConnector) { this.vtable.onConstraintRelease(this); }

    PxConstraintConnector_onComShift :: inline (this: *PxConstraintConnector, actor: PxU32) { this.vtable.onComShift(this, actor); }

    PxConstraintConnector_onOriginShift :: inline (this: *PxConstraintConnector, shift: *PxVec3) { this.vtable.onOriginShift(this, shift); }

    PxConstraintConnector_getExternalReference :: inline (this: *PxConstraintConnector, typeID: *PxU32) -> *void { return this.vtable.getExternalReference(this, typeID); }

    PxConstraintConnector_getSerializable :: inline (this: *PxConstraintConnector) -> *PxBase { return this.vtable.getSerializable(this); }

    PxConstraintConnector_getPrep :: inline (this: *PxConstraintConnector) -> PxConstraintSolverPrep { return this.vtable.getPrep(this); }

    PxConstraintConnector_getConstantBlock :: inline (this: *PxConstraintConnector) -> *void { return this.vtable.getConstantBlock(this); }

    PxConstraintConnector_connectToConstraint :: inline (this: *PxConstraintConnector, unknown0: *PxConstraint) { this.vtable.connectToConstraint(this, unknown0); }

    PxConstraintConnector_Destructor :: inline (this: *PxConstraintConnector, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxConstraintConnector) -> *PxConstraintConnector_VTable { return obj.vtable; }


    PxContactPoint :: struct {
        normal:             PxVec3;

        /*
        \brief The separation of the shapes at the contact point. A negative separation denotes a penetration.
        */
        separation:         PxReal;

        point:              PxVec3;

        /*
        \brief The max impulse permitted at this point
        */
        maxImpulse:         PxReal;

        targetVel:          PxVec3;

        /*
        \brief The static friction coefficient
        */
        staticFriction:     PxReal;

        /*
        \brief Material flags for this contact (eDISABLE_FRICTION, eDISABLE_STRONG_FRICTION). \see PxMaterialFlag
        */
        materialFlags:      PxU8;

        /*
        \brief The surface index of shape 1 at the contact point. This is used to identify the surface material.
        
        \note This field is only supported by triangle meshes and heightfields, else it will be set to PXC_CONTACT_NO_FACE_INDEX.
        */
        internalFaceIndex1: PxU32;

        /*
        \brief The dynamic friction coefficient
        */
        dynamicFriction:    PxReal;

        /*
        \brief The restitution coefficient
        */
        restitution:        PxReal;

        /*
        \brief Damping coefficient (for compliant contacts)
        */
        damping:            PxReal;
    }

    /*
    \brief Struct that the solver uses to store velocity updates for a body
    */
    PxSolverBody :: struct {
        linearVelocity:            PxVec3; //!< Delta linear velocity computed by the solver
        maxSolverNormalProgress:   PxU16; //!< Progress counter used by constraint batching and parallel island solver. 
        maxSolverFrictionProgress: PxU16; //!< Progress counter used by constraint batching and parallel island solver.

        angularState:              PxVec3; //!< Delta angular velocity state computed by the solver.

        solverProgress:            PxU32; //!< Progress counter used by constraint batching and parallel island solver

        Constructor :: (this: *PxSolverBody) -> void #cpp_method #foreign physx_static "??0PxSolverBody@physx@@QEAA@XZ";
    }

    /*
    \brief Struct that the solver uses to store the state and other properties of a body
    */
    PxSolverBodyData :: struct {
        linearVelocity:    PxVec3;
        invMass:           PxReal; //!< 16 inverse mass
        angularVelocity:   PxVec3; //!< 28 Pre-solver angular velocity
        reportThreshold:   PxReal; //!< 32 contact force threshold
        sqrtInvInertia:    PxMat33; //!< 68 inverse inertia in world space
        penBiasClamp:      PxReal; //!< 72 the penetration bias clamp
        nodeIndex:         PxU32; //!< 76 the node idx of this solverBodyData. Used by solver to reference between solver bodies and island bodies. Not required by immediate mode
        maxContactImpulse: PxReal; //!< 80 the max contact impulse
        body2World:        PxTransform; //!< 108 the body's transform
        pad:               PxU16; //!< 112 pad

        projectVelocity :: (this: *PxSolverBodyData, lin: *PxVec3, ang: *PxVec3) -> PxReal #cpp_method #foreign physx_static "?projectVelocity@PxSolverBodyData@physx@@QEBAMAEBV?$PxVec3T@M@2@0@Z";
        projectVelocity :: (this: *PxSolverBodyData, lin: PxVec3, ang: PxVec3) -> PxReal #no_context {
            return projectVelocity(this, *lin, *ang);
        }
    }

    //----------------------------------
    /*
    \brief A header that defines the size of a specific batch of constraints (of same type and without dependencies)
    */
    PxConstraintBatchHeader :: struct {
        startIndex:     PxU32; //!< Start index for this batch
        stride:         PxU16; //!< Number of constraints in this batch (range: 1-4)
        constraintType: PxU16; //!< The type of constraint this batch references
    }

    /*
    \brief Constraint descriptor used inside the solver
    */
    PxSolverConstraintDesc :: struct {
        RIGID_BODY:        PxU16 : 65535;

        ConstraintType :: enum s32 {
            CONTACT_CONSTRAINT :: 0;
            JOINT_CONSTRAINT   :: 1;

            eCONTACT_CONSTRAINT :: CONTACT_CONSTRAINT;
            eJOINT_CONSTRAINT   :: JOINT_CONSTRAINT;
        }

        union {
            bodyA:         *PxSolverBody; //!< bodyA pointer
            tgsBodyA:      *PxTGSSolverBodyVel; //!< bodyA pointer
            articulationA: *void; //!< Articulation pointer for body A
        }

        union {
            bodyB:         *PxSolverBody; //!< BodyB pointer
            tgsBodyB:      *PxTGSSolverBodyVel; //!< BodyB pointer
            articulationB: *void; //!< Articulation pointer for body B
        }

        bodyADataIndex:    PxU32; //!< Body A's index into the SolverBodyData array
        bodyBDataIndex:    PxU32; //!< Body B's index into the SolverBodyData array

        linkIndexA:        PxU32; //!< Link index defining which link in Articulation A this constraint affects. If not an articulation, must be PxSolverConstraintDesc::RIGID_BODY
        linkIndexB:        PxU32; //!< Link index defining which link in Articulation B this constraint affects. If not an articulation, must be PxSolverConstraintDesc::RIGID_BODY
        constraint:        *PxU8; //!< Pointer to the constraint rows to be solved
        writeBack:         *void; //!< Pointer to the writeback structure results for this given constraint are to be written to
        writeBackFriction: *void; //!< Pointer to writeback contact friction impulses. Points to a PxVec3* buffer

        progressA:         PxU16; //!< Internal progress counter
        progressB:         PxU16; //!< Internal progress counter

        union {
            constraintType:         PxU16; //!< type of constraint. Union member active until constraint prepping, afterwards memory used for constraint length
            constraintLengthOver16: PxU16; //!< constraintLength/16, max constraint length is 1MB.
        }
    }

    /*
    \brief Data structure used for preparing constraints before solving them
    */
    PxSolverConstraintPrepDescBase :: struct {
        BodyState :: enum s32 {
            DYNAMIC_BODY   :: 1;
            STATIC_BODY    :: 2;
            KINEMATIC_BODY :: 4;
            ARTICULATION   :: 8;

            eDYNAMIC_BODY   :: DYNAMIC_BODY;
            eSTATIC_BODY    :: STATIC_BODY;
            eKINEMATIC_BODY :: KINEMATIC_BODY;
            eARTICULATION   :: ARTICULATION;
        }

        invMassScales: PxConstraintInvMassScale; //!< In: The local mass scaling for this pair.

        desc:          *PxSolverConstraintDesc; //!< Output: The PxSolverConstraintDesc filled in by contact prep

        body0:         *PxSolverBody; //!< In: The first body. Stores velocity information. Unused unless contact involves articulations.
        body1:         *PxSolverBody; //!< In: The second body. Stores velocity information. Unused unless contact involves articulations.

        data0:         *PxSolverBodyData; //!< In: The first PxSolverBodyData. Stores mass and miscellaneous information for the first body. 
        data1:         *PxSolverBodyData; //!< In: The second PxSolverBodyData. Stores mass and miscellaneous information for the second body

        bodyFrame0:    PxTransform; //!< In: The world-space transform of the first body.
        bodyFrame1:    PxTransform; //!< In: The world-space transform of the second body.

        bodyState0:    BodyState; //!< In: Defines what kind of actor the first body is
        bodyState1:    BodyState; //!< In: Defines what kind of actor the second body is

        // PT: the following pointers have been moved here from derived structures to fill padding bytes
        union {
            writeback:        *void; //!< Pointer to constraint writeback structure. Reports back joint breaking. If not required, set to NULL.

            shapeInteraction: *void; //!< Pointer to shape interaction. Used for force threshold reports in solver. Set to NULL if using immediate mode.
        }
    }

    /*
    \brief Data structure used for preparing constraints before solving them
    */
    PxSolverConstraintPrepDesc :: struct {
        #as using pxsolverconstraintprepdescbase: PxSolverConstraintPrepDescBase;

        rows:                 *Px1DConstraint;
        numRows:              PxU32; //!< The number of rows

        linBreakForce:        PxReal; //!< Break forces
        angBreakForce:        PxReal; //!< Break forces
        minResponseThreshold: PxReal; //!< The minimum response threshold
        disablePreprocessing: bool; //!< Disable joint pre-processing. Pre-processing can improve stability but under certain circumstances, e.g. when some invInertia rows are zero/almost zero, can cause instabilities.	
        improvedSlerp:        bool; //!< Use improved slerp model
        driveLimitsAreForces: bool; //!< Indicates whether drive limits are forces
        extendedLimits:       bool; //!< Indicates whether we want to use extended limits
        disableConstraint:    bool; //!< Disables constraint

        body0WorldOffset:     PxVec3p; //!< Body0 world offset
    }

    /*
    \brief Data structure used for preparing constraints before solving them
    */
    PxSolverContactDesc :: struct {
        #as using pxsolverconstraintprepdescbase: PxSolverConstraintPrepDescBase;

        frictionPtr:             *PxU8; //!< InOut: Friction patch correlation data. Set each frame by solver. Can be retained for improved behavior or discarded each frame.
        contacts:                *PxContactPoint; //!< The start of the contacts for this pair
        numContacts:             PxU32; //!< The total number of contacts this pair references.

        frictionCount:           PxU8; //!< The total number of friction patches in this pair
        hasMaxImpulse:           bool; //!< Defines whether this pairs has maxImpulses clamping enabled
        disableStrongFriction:   bool; //!< Defines whether this pair disables strong friction (sticky friction correlation)
        hasForceThresholds:      bool; //!< Defines whether this pair requires force thresholds	

        restDistance:            PxReal; //!< A distance at which the solver should aim to hold the bodies separated. Default is 0
        maxCCDSeparation:        PxReal; //!< A distance used to configure speculative CCD behavior. Default is PX_MAX_F32. Set internally in PhysX for bodies with eENABLE_SPECULATIVE_CCD on. Do not set directly!

        contactForces:           *PxReal; //!< Out: A buffer for the solver to write applied contact forces to.

        startFrictionPatchIndex: PxU32; //!< Start index of friction patch in the correlation buffer. Set by friction correlation
        numFrictionPatches:      PxU32; //!< Total number of friction patches in this pair. Set by friction correlation

        startContactPatchIndex:  PxU32; //!< The start index of this pair's contact patches in the correlation buffer. For internal use only
        numContactPatches:       PxU16; //!< Total number of contact patches.
        axisConstraintCount:     PxU16; //!< Axis constraint count. Defines how many constraint rows this pair has produced. Useful for statistical purposes.

        offsetSlop:              PxReal; //!< Slop value used to snap contact line of action back in-line with the COM.
    }

    PxConstraintAllocator :: struct {
        vtable: *PxConstraintAllocator_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxConstraintAllocator, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxConstraintAllocator@physx@@UEAA@XZ";
    }
    PxConstraintAllocator_VTable :: struct #type_info_none {
        reserveConstraintData: (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 #cpp_method;

        reserveFrictionData: (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 #cpp_method;

        Destructor: (this: *PxConstraintAllocator, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxConstraintAllocator_reserveConstraintData :: inline (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 { return this.vtable.reserveConstraintData(this, byteSize); }

    PxConstraintAllocator_reserveFrictionData :: inline (this: *PxConstraintAllocator, byteSize: PxU32) -> *PxU8 { return this.vtable.reserveFrictionData(this, byteSize); }

    PxConstraintAllocator_Destructor :: inline (this: *PxConstraintAllocator, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxConstraintAllocator) -> *PxConstraintAllocator_VTable { return obj.vtable; }


    PxArticulationAxis :: struct {
        Enum :: enum s32 {
            TWIST  :: 0;
            SWING1 :: 1;
            SWING2 :: 2;
            X      :: 3;
            Y      :: 4;
            Z      :: 5;
            COUNT  :: 6;

            eTWIST  :: TWIST;
            eSWING1 :: SWING1;
            eSWING2 :: SWING2;
            eX      :: X;
            eY      :: Y;
            eZ      :: Z;
            eCOUNT  :: COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxArticulationMotion :: struct {
        Enum :: enum s32 {
            LOCKED  :: 0;
            LIMITED :: 1;
            FREE    :: 2;

            eLOCKED  :: LOCKED;
            eLIMITED :: LIMITED;
            eFREE    :: FREE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxArticulationMotions :: PxFlags(PxArticulationMotion.Enum, PxU8);
    operator| :: (a: PxArticulationMotion.Enum, b: PxArticulationMotion.Enum) -> PxFlags(PxArticulationMotion.Enum, PxU8) #foreign physx_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxArticulationMotion@physx@@E@0@W4Enum@PxArticulationMotion@0@0@Z";

    PxArticulationJointType :: struct {
        Enum :: enum s32 {
            FIX                :: 0;
            PRISMATIC          :: 1;
            REVOLUTE           :: 2;
            REVOLUTE_UNWRAPPED :: 3;
            SPHERICAL          :: 4;
            UNDEFINED          :: 5;

            eFIX                :: FIX;
            ePRISMATIC          :: PRISMATIC;
            eREVOLUTE           :: REVOLUTE;
            eREVOLUTE_UNWRAPPED :: REVOLUTE_UNWRAPPED;
            eSPHERICAL          :: SPHERICAL;
            eUNDEFINED          :: UNDEFINED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxArticulationFlag :: struct {
        Enum :: enum s32 {
            FIX_BASE                :: 1;
            DRIVE_LIMITS_ARE_FORCES :: 2;
            DISABLE_SELF_COLLISION  :: 4;

            eFIX_BASE                :: FIX_BASE;
            eDRIVE_LIMITS_ARE_FORCES :: DRIVE_LIMITS_ARE_FORCES;
            eDISABLE_SELF_COLLISION  :: DISABLE_SELF_COLLISION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxArticulationFlags :: PxFlags(PxArticulationFlag.Enum, PxU8);
    operator~ :: (a: PxArticulationFlag.Enum) -> PxFlags(PxArticulationFlag.Enum, PxU8) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxArticulationFlag@physx@@E@0@W4Enum@PxArticulationFlag@0@@Z";

    PxArticulationDriveType :: struct {
        Enum :: enum s32 {
            FORCE        :: 0;
            ACCELERATION :: 1;
            TARGET       :: 2;
            VELOCITY     :: 3;
            NONE         :: 4;

            eFORCE        :: FORCE;
            eACCELERATION :: ACCELERATION;
            eTARGET       :: TARGET;
            eVELOCITY     :: VELOCITY;
            eNONE         :: NONE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Data structure to set articulation joint limits.
    
    - The lower limit should be strictly smaller than the higher limit. If the limits should be equal, use PxArticulationMotion::eLOCKED
    and an appropriate offset in the parent/child joint frames.
    - The limit units are linear units (equivalent to scene units) for a translational axis, or radians for a rotational axis.
    
    \see PxArticulationJointReducedCoordinate::setLimitParams, PxArticulationReducedCoordinate
    */
    PxArticulationLimit :: struct {
        Constructor :: (this: *PxArticulationLimit) -> void #cpp_method #foreign physx_static "??0PxArticulationLimit@physx@@QEAA@XZ";

        Constructor :: (this: *PxArticulationLimit, low_: PxReal, high_: PxReal) -> void #cpp_method #foreign physx_static "??0PxArticulationLimit@physx@@QEAA@MM@Z";

        /*
        \brief The lower limit on the joint axis position.
        
        <b>Range:</b> [-PX_MAX_F32, high)<br>
        <b>Default:</b> 0.0f<br>
        */
        low:  PxReal;

        /*
        \brief The higher limit on the joint axis position.
        
        <b>Range:</b> (low, PX_MAX_F32]<br>
        <b>Default:</b> 0.0f<br>
        */
        high: PxReal;
    }

    /*
    \brief Data structure for articulation joint drive configuration.
    
    \see PxArticulationJointReducedCoordinate::setDriveParams, PxArticulationReducedCoordinate
    */
    PxArticulationDrive :: struct {
        Constructor :: (this: *PxArticulationDrive) -> void #cpp_method #foreign physx_static "??0PxArticulationDrive@physx@@QEAA@XZ";

        Constructor :: (this: *PxArticulationDrive, stiffness_: PxReal, damping_: PxReal, maxForce_: PxReal, driveType_: PxArticulationDriveType.Enum = .FORCE) -> void #cpp_method #foreign physx_static "??0PxArticulationDrive@physx@@QEAA@MMMW4Enum@PxArticulationDriveType@1@@Z";

        /*
        \brief The drive stiffness, i.e. the proportional gain of the implicit PD controller.
        
        See manual for further information, and the drives' implicit spring-damper (i.e. PD control) implementation in particular.
        
        <b>Units:</b> (distance = linear scene units)<br>
        Rotational axis: torque/rad if driveType = PxArticulationDriveType::eFORCE; or (rad/s^2)/rad if driveType = PxArticulationDriveType::eACCELERATION<br>
        Translational axis: force/distance if driveType = PxArticulationDriveType::eFORCE; or (distance/s^2)/distance if driveType = PxArticulationDriveType::eACCELERATION<br>
        <b>Range:</b> [0, PX_MAX_F32]<br>
        <b>Default:</b> 0.0f<br>
        */
        stiffness: PxReal;

        /*
        \brief The drive damping, i.e. the derivative gain of the implicit PD controller.
        
        See manual for further information, and the drives' implicit spring-damper (i.e. PD control) implementation in particular.
        
        <b>Units:</b> (distance = linear scene units)<br>
        Rotational axis: torque/(rad/s) if driveType = PxArticulationDriveType::eFORCE; or (rad/s^2)/(rad/s) if driveType = PxArticulationDriveType::eACCELERATION<br>
        Translational axis: force/(distance/s) if driveType = PxArticulationDriveType::eFORCE; or (distance/s^2)/(distance/s) if driveType = PxArticulationDriveType::eACCELERATION<br>
        <b>Range:</b> [0, PX_MAX_F32]<br>
        <b>Default:</b> 0.0f<br>
        */
        damping:   PxReal;

        /*
        \brief The drive force limit.
        
        - The limit is enforced regardless of the drive type #PxArticulationDriveType.
        - The limit corresponds to a force (linear axis) or torque (rotational axis) if PxArticulationFlag::eDRIVE_LIMITS_ARE_FORCES is set, and to an impulse (force|torque * dt) otherwise.
        
        <b>Range:</b> [0, PX_MAX_F32]<br>
        <b>Default:</b> 0.0f<br>
        
        \see PxArticulationFlag::eDRIVE_LIMITS_ARE_FORCES
        */
        maxForce:  PxReal;

        /*
        \brief The drive type.
        
        \see PxArticulationDriveType
        */
        driveType: PxArticulationDriveType.Enum;
    }

    PxTGSSolverBodyVel :: struct {
        linearVelocity:       PxVec3; //12
        maxDynamicPartition:  PxU16; //14 Used to accumulate the max partition of dynamic interactions
        nbStaticInteractions: PxU16; //16 Used to accumulate the number of static interactions
        angularVelocity:      PxVec3; //28
        partitionMask:        PxU32; //32 Used in partitioning as a bit-field
        deltaAngDt:           PxVec3; //44
        maxAngVel:            PxReal; //48
        deltaLinDt:           PxVec3; //60
        lockFlags:            PxU16; //62
        isKinematic:          bool; //63
        pad:                  PxU8; //64
    }

    //Needed only by prep, integration and 1D constraints
    //Solver body state at time = simulationTime + simStepDt*posIter/nbPosIters
    PxTGSSolverBodyTxInertia :: struct {
        //Accumulated change to quaternion that has accumulated since solver started.
        deltaBody2WorldQ: PxQuat;

        //Absolute body position at t
        body2WorldP:      PxVec3;

        sqrtInvInertia:   PxMat33; //!< inverse inertia in world space
    }

    PxTGSSolverBodyData :: struct {
        originalLinearVelocity:  PxVec3; //!< Pre-solver linear velocity.
        maxContactImpulse:       PxReal; //!< The max contact impulse.
        originalAngularVelocity: PxVec3; //!< Pre-solver angular velocity
        penBiasClamp:            PxReal; //!< The penetration bias clamp.

        invMass:                 PxReal; //!< Inverse mass.
        nodeIndex:               PxU32; //!< The node idx of this solverBodyData. Used by solver to reference between solver bodies and island bodies. Not required by immediate mode.
        reportThreshold:         PxReal; //!< Contact force threshold.
        pad:                     PxU32;

        projectVelocity :: (this: *PxTGSSolverBodyData, linear: *PxVec3, angular: *PxVec3) -> PxReal #cpp_method #foreign physx_static "?projectVelocity@PxTGSSolverBodyData@physx@@QEBAMAEBV?$PxVec3T@M@2@0@Z";
        projectVelocity :: (this: *PxTGSSolverBodyData, linear: PxVec3, angular: PxVec3) -> PxReal #no_context {
            return projectVelocity(this, *linear, *angular);
        }
    }

    PxTGSSolverConstraintPrepDescBase :: struct {
        invMassScales: PxConstraintInvMassScale; //!< In: The local mass scaling for this pair.

        desc:          *PxSolverConstraintDesc; //!< Output: The PxSolverConstraintDesc filled in by contact prep

        body0:         *PxTGSSolverBodyVel; //!< In: The first body. Stores velocity information. Unused unless contact involves articulations.
        body1:         *PxTGSSolverBodyVel; //!< In: The second body. Stores velocity information. Unused unless contact involves articulations.

        body0TxI:      *PxTGSSolverBodyTxInertia; //!< In: The first PxTGSSolverBodyTxInertia. Stores the delta body to world transform and sqrtInvInertia for first body.
        body1TxI:      *PxTGSSolverBodyTxInertia; //!< In: The second PxTGSSolverBodyTxInertia. Stores the delta body to world transform and sqrtInvInertia for second body.

        bodyData0:     *PxTGSSolverBodyData; //!< In: The first PxTGSSolverBodyData. Stores mass and miscellaneous information for the first body. 
        bodyData1:     *PxTGSSolverBodyData; //!< In: The second PxTGSSolverBodyData. Stores mass and miscellaneous information for the second body.

        bodyFrame0:    PxTransform; //!< In: The world-space transform of the first body.
        bodyFrame1:    PxTransform; //!< In: The world-space transform of the second body.

        bodyState0:    PxSolverConstraintPrepDescBase.BodyState; //!< In: Defines what kind of actor the first body is
        bodyState1:    PxSolverConstraintPrepDescBase.BodyState; //!< In: Defines what kind of actor the second body is

        // PT: the following pointers have been moved here from derived structures to fill padding bytes
        union {
            writeback:        *void; //!< Pointer to constraint writeback structure. Reports back joint breaking. If not required, set to NULL.

            shapeInteraction: *void; //!< Pointer to shape interaction. Used for force threshold reports in solver. Set to NULL if using immediate mode.
        }
    }

    // PT: ensure that we can safely read 4 bytes after the bodyFrames
    // PX_COMPILE_TIME_ASSERT(PX_OFFSET_OF(PxTGSSolverConstraintPrepDescBase, bodyFrame0)+sizeof(PxTGSSolverConstraintPrepDescBase::bodyFrame0) + 4 <= sizeof(PxTGSSolverConstraintPrepDescBase));
    // PX_COMPILE_TIME_ASSERT(PX_OFFSET_OF(PxTGSSolverConstraintPrepDescBase, bodyFrame1)+sizeof(PxTGSSolverConstraintPrepDescBase::bodyFrame1) + 4 <= sizeof(PxTGSSolverConstraintPrepDescBase));
    PxTGSSolverConstraintPrepDesc :: struct {
        #as using pxtgssolverconstraintprepdescbase: PxTGSSolverConstraintPrepDescBase;

        rows:                 *Px1DConstraint; //!< The start of the constraint rows
        numRows:              PxU32; //!< The number of rows

        linBreakForce:        PxReal; //!< Break forces
        angBreakForce:        PxReal; //!< Break forces
        minResponseThreshold: PxReal; //!< The minimum response threshold
        disablePreprocessing: bool; //!< Disable joint pre-processing. Pre-processing can improve stability but under certain circumstances, e.g. when some invInertia rows are zero/almost zero, can cause instabilities.	
        improvedSlerp:        bool; //!< Use improved slerp model
        driveLimitsAreForces: bool; //!< Indicates whether drive limits are forces
        extendedLimits:       bool; //!< Indicates whether extended limits are used
        disableConstraint:    bool; //!< Disables constraint

        body0WorldOffset:     PxVec3p; //!< Body0 world offset
        cA2w:                 PxVec3p; //!< Location of anchor point A in world space
        cB2w:                 PxVec3p; //!< Location of anchor point B in world space
    }

    PxTGSSolverContactDesc :: struct {
        #as using pxtgssolverconstraintprepdescbase: PxTGSSolverConstraintPrepDescBase;

        frictionPtr:             *PxU8; //!< InOut: Friction patch correlation data. Set each frame by solver. Can be retained for improved behavior or discarded each frame.
        contacts:                *PxContactPoint; //!< The start of the contacts for this pair
        numContacts:             PxU32; //!< The total number of contacts this pair references.

        frictionCount:           PxU8; //!< The total number of friction patches in this pair
        hasMaxImpulse:           bool; //!< Defines whether this pairs has maxImpulses clamping enabled
        disableStrongFriction:   bool; //!< Defines whether this pair disables strong friction (sticky friction correlation)
        hasForceThresholds:      bool; //!< Defines whether this pair requires force thresholds	

        restDistance:            PxReal; //!< A distance at which the solver should aim to hold the bodies separated. Default is 0
        maxCCDSeparation:        PxReal; //!< A distance used to configure speculative CCD behavior. Default is PX_MAX_F32. Set internally in PhysX for bodies with eENABLE_SPECULATIVE_CCD on. Do not set directly!

        contactForces:           *PxReal; //!< Out: A buffer for the solver to write applied contact forces to.

        startFrictionPatchIndex: PxU32; //!< Start index of friction patch in the correlation buffer. Set by friction correlation
        numFrictionPatches:      PxU32; //!< Total number of friction patches in this pair. Set by friction correlation

        startContactPatchIndex:  PxU32; //!< The start index of this pair's contact patches in the correlation buffer. For internal use only
        numContactPatches:       PxU16; //!< Total number of contact patches.
        axisConstraintCount:     PxU16; //!< Axis constraint count. Defines how many constraint rows this pair has produced. Useful for statistical purposes.

        maxImpulse:              PxReal; //!< The maximum impulse the solver is allowed to introduce for this pair of bodies.

        torsionalPatchRadius:    PxReal; //!< This defines the radius of the contact patch used to apply torsional friction.
        minTorsionalPatchRadius: PxReal; //!< This defines the minimum radius of the contact patch used to apply torsional friction.
        offsetSlop:              PxReal; //!< Slop value used to snap contact line of action back in-line with the COM.
    }

    /*
    \brief A description of the types of articulation data that may be directly written to and read from the GPU using the functions
    PxScene::copyArticulationData() and PxScene::applyArticulationData(). Types that are read-only may only be used in conjunction with
    PxScene::copyArticulationData(). Types that are write-only may only be used in conjunction with PxScene::applyArticulationData().
    A subset of data types may be used in conjunction with both PxScene::applyArticulationData() and PxScene::applyArticulationData().
    
    \see PxArticulationCache, PxScene::copyArticulationData(), PxScene::applyArticulationData()
    
    \deprecated The replacements are PxArticulationGPUAPIReadType and PxArticulationGPUAPIWriteType in combination with
    PxDirectGPUAPI::getArticulationData and PxDirectGPUAPI::setArticulationData.
    
    */
    PxArticulationGpuDataType :: struct {
        Enum :: enum s32 {
            JOINT_POSITION            :: 0;
            JOINT_VELOCITY            :: 1;
            JOINT_ACCELERATION        :: 2;
            JOINT_FORCE               :: 3;
            JOINT_TARGET_VELOCITY     :: 4;
            JOINT_TARGET_POSITION     :: 5;
            ROOT_TRANSFORM            :: 6;
            ROOT_VELOCITY             :: 7;
            LINK_TRANSFORM            :: 8;
            LINK_VELOCITY             :: 9;
            LINK_ACCELERATION         :: 10;
            LINK_INCOMING_JOINT_FORCE :: 11;
            LINK_FORCE                :: 12;
            LINK_TORQUE               :: 13;
            FIXED_TENDON              :: 14;
            FIXED_TENDON_JOINT        :: 15;
            SPATIAL_TENDON            :: 16;
            SPATIAL_TENDON_ATTACHMENT :: 17;

            eJOINT_POSITION            :: JOINT_POSITION;
            eJOINT_VELOCITY            :: JOINT_VELOCITY;
            eJOINT_ACCELERATION        :: JOINT_ACCELERATION;
            eJOINT_FORCE               :: JOINT_FORCE;
            eJOINT_TARGET_VELOCITY     :: JOINT_TARGET_VELOCITY;
            eJOINT_TARGET_POSITION     :: JOINT_TARGET_POSITION;
            eROOT_TRANSFORM            :: ROOT_TRANSFORM;
            eROOT_VELOCITY             :: ROOT_VELOCITY;
            eLINK_TRANSFORM            :: LINK_TRANSFORM;
            eLINK_VELOCITY             :: LINK_VELOCITY;
            eLINK_ACCELERATION         :: LINK_ACCELERATION;
            eLINK_INCOMING_JOINT_FORCE :: LINK_INCOMING_JOINT_FORCE;
            eLINK_FORCE                :: LINK_FORCE;
            eLINK_TORQUE               :: LINK_TORQUE;
            eFIXED_TENDON              :: FIXED_TENDON;
            eFIXED_TENDON_JOINT        :: FIXED_TENDON_JOINT;
            eSPATIAL_TENDON            :: SPATIAL_TENDON;
            eSPATIAL_TENDON_ATTACHMENT :: SPATIAL_TENDON_ATTACHMENT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief These flags determine what data is read or written to the internal articulation data via cache.
    
    \see PxArticulationCache PxArticulationReducedCoordinate::copyInternalStateToCache PxArticulationReducedCoordinate::applyCache
    */
    PxArticulationCacheFlag :: struct {
        Enum :: enum s32 {
            VELOCITY                  :: 1;
            ACCELERATION              :: 2;
            POSITION                  :: 4;
            FORCE                     :: 8;
            LINK_VELOCITY             :: 16;
            LINK_ACCELERATION         :: 32;
            ROOT_TRANSFORM            :: 64;
            ROOT_VELOCITIES           :: 128;
            LINK_INCOMING_JOINT_FORCE :: 1024;
            JOINT_TARGET_POSITIONS    :: 2048;
            JOINT_TARGET_VELOCITIES   :: 4096;
            ALL                       :: 247;

            eVELOCITY                  :: VELOCITY;
            eACCELERATION              :: ACCELERATION;
            ePOSITION                  :: POSITION;
            eFORCE                     :: FORCE;
            eLINK_VELOCITY             :: LINK_VELOCITY;
            eLINK_ACCELERATION         :: LINK_ACCELERATION;
            eROOT_TRANSFORM            :: ROOT_TRANSFORM;
            eROOT_VELOCITIES           :: ROOT_VELOCITIES;
            eLINK_INCOMING_JOINT_FORCE :: LINK_INCOMING_JOINT_FORCE;
            eJOINT_TARGET_POSITIONS    :: JOINT_TARGET_POSITIONS;
            eJOINT_TARGET_VELOCITIES   :: JOINT_TARGET_VELOCITIES;
            eALL                       :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxArticulationCacheFlags :: PxFlags(PxArticulationCacheFlag.Enum, PxU32);
    operator| :: (a: PxArticulationCacheFlag.Enum, b: PxArticulationCacheFlag.Enum) -> PxFlags(PxArticulationCacheFlag.Enum, PxU32) #foreign physx_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxArticulationCacheFlag@physx@@I@0@W4Enum@PxArticulationCacheFlag@0@0@Z";

    /*
    \brief Defines the low/high limits of the length of a tendon.
    */
    PxArticulationTendonLimit :: struct {
        lowLimit:  PxReal;
        highLimit: PxReal;
    }

    /*
    \brief Defines a spatial tendon attachment point on a link.
    */
    PxArticulationAttachment :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.	

        Constructor :: (this: *PxArticulationAttachment, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationAttachment@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationAttachment, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationAttachment@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxarticulationattachment_vtable: *PxArticulationAttachment_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxArticulationAttachment, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationAttachment@physx@@UEAA@XZ";

        /*
        \brief Returns the string name of the dynamic type.
        
        \return The string name.
        */
        virtual_getConcreteTypeName :: (this: *PxArticulationAttachment) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxArticulationAttachment@physx@@UEBAPEBDXZ";
    }
    PxArticulationAttachment_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        setRestLength: (this: *PxArticulationAttachment, restLength: PxReal) -> void #cpp_method;

        getRestLength: (this: *PxArticulationAttachment) -> PxReal #cpp_method;

        setLimitParameters: (this: *PxArticulationAttachment, parameters: *PxArticulationTendonLimit) -> void #cpp_method;

        getLimitParameters: (this: *PxArticulationAttachment) -> PxArticulationTendonLimit #cpp_method;

        setRelativeOffset: (this: *PxArticulationAttachment, offset: *PxVec3) -> void #cpp_method;

        getRelativeOffset: (this: *PxArticulationAttachment) -> PxVec3 #cpp_method;

        setCoefficient: (this: *PxArticulationAttachment, coefficient: PxReal) -> void #cpp_method;

        getCoefficient: (this: *PxArticulationAttachment) -> PxReal #cpp_method;

        getLink: (this: *PxArticulationAttachment) -> *PxArticulationLink #cpp_method;

        getParent: (this: *PxArticulationAttachment) -> *PxArticulationAttachment #cpp_method;

        isLeaf: (this: *PxArticulationAttachment) -> bool #cpp_method;

        getTendon: (this: *PxArticulationAttachment) -> *PxArticulationSpatialTendon #cpp_method;
    }

    PxArticulationAttachment_setRestLength :: inline (this: *PxArticulationAttachment, restLength: PxReal) { this.pxarticulationattachment_vtable.setRestLength(this, restLength); }

    PxArticulationAttachment_getRestLength :: inline (this: *PxArticulationAttachment) -> PxReal { return this.pxarticulationattachment_vtable.getRestLength(this); }

    PxArticulationAttachment_setLimitParameters :: inline (this: *PxArticulationAttachment, parameters: *PxArticulationTendonLimit) { this.pxarticulationattachment_vtable.setLimitParameters(this, parameters); }

    PxArticulationAttachment_getLimitParameters :: inline (this: *PxArticulationAttachment) -> PxArticulationTendonLimit { return this.pxarticulationattachment_vtable.getLimitParameters(this); }

    PxArticulationAttachment_setRelativeOffset :: inline (this: *PxArticulationAttachment, offset: *PxVec3) { this.pxarticulationattachment_vtable.setRelativeOffset(this, offset); }

    PxArticulationAttachment_getRelativeOffset :: inline (this: *PxArticulationAttachment) -> PxVec3 { return this.pxarticulationattachment_vtable.getRelativeOffset(this); }

    PxArticulationAttachment_setCoefficient :: inline (this: *PxArticulationAttachment, coefficient: PxReal) { this.pxarticulationattachment_vtable.setCoefficient(this, coefficient); }

    PxArticulationAttachment_getCoefficient :: inline (this: *PxArticulationAttachment) -> PxReal { return this.pxarticulationattachment_vtable.getCoefficient(this); }

    PxArticulationAttachment_getLink :: inline (this: *PxArticulationAttachment) -> *PxArticulationLink { return this.pxarticulationattachment_vtable.getLink(this); }

    PxArticulationAttachment_getParent :: inline (this: *PxArticulationAttachment) -> *PxArticulationAttachment { return this.pxarticulationattachment_vtable.getParent(this); }

    PxArticulationAttachment_isLeaf :: inline (this: *PxArticulationAttachment) -> bool { return this.pxarticulationattachment_vtable.isLeaf(this); }

    PxArticulationAttachment_getTendon :: inline (this: *PxArticulationAttachment) -> *PxArticulationSpatialTendon { return this.pxarticulationattachment_vtable.getTendon(this); }

    vtable :: (obj: *PxArticulationAttachment) -> *PxArticulationAttachment_VTable { return obj.pxarticulationattachment_vtable; }


    /*
    \brief Defines a fixed-tendon joint on an articulation joint degree of freedom.
    */
    PxArticulationTendonJoint :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxArticulationTendonJoint, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationTendonJoint@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationTendonJoint, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationTendonJoint@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxarticulationtendonjoint_vtable: *PxArticulationTendonJoint_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxArticulationTendonJoint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationTendonJoint@physx@@UEAA@XZ";

        /*
        \brief Returns the string name of the dynamic type.
        
        \return The string name.
        */
        virtual_getConcreteTypeName :: (this: *PxArticulationTendonJoint) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxArticulationTendonJoint@physx@@UEBAPEBDXZ";
    }
    PxArticulationTendonJoint_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        setCoefficient: (this: *PxArticulationTendonJoint, axis: PxArticulationAxis.Enum, coefficient: PxReal, recipCoefficient: PxReal) -> void #cpp_method;

        getCoefficient: (this: *PxArticulationTendonJoint, axis: *PxArticulationAxis.Enum, coefficient: *PxReal, recipCoefficient: *PxReal) -> void #cpp_method;

        getLink: (this: *PxArticulationTendonJoint) -> *PxArticulationLink #cpp_method;

        getParent: (this: *PxArticulationTendonJoint) -> *PxArticulationTendonJoint #cpp_method;

        getTendon: (this: *PxArticulationTendonJoint) -> *PxArticulationFixedTendon #cpp_method;
    }

    PxArticulationTendonJoint_setCoefficient :: inline (this: *PxArticulationTendonJoint, axis: PxArticulationAxis.Enum, coefficient: PxReal, recipCoefficient: PxReal) { this.pxarticulationtendonjoint_vtable.setCoefficient(this, axis, coefficient, recipCoefficient); }

    PxArticulationTendonJoint_getCoefficient :: inline (this: *PxArticulationTendonJoint, axis: *PxArticulationAxis.Enum, coefficient: *PxReal, recipCoefficient: *PxReal) { this.pxarticulationtendonjoint_vtable.getCoefficient(this, axis, coefficient, recipCoefficient); }

    PxArticulationTendonJoint_getLink :: inline (this: *PxArticulationTendonJoint) -> *PxArticulationLink { return this.pxarticulationtendonjoint_vtable.getLink(this); }

    PxArticulationTendonJoint_getParent :: inline (this: *PxArticulationTendonJoint) -> *PxArticulationTendonJoint { return this.pxarticulationtendonjoint_vtable.getParent(this); }

    PxArticulationTendonJoint_getTendon :: inline (this: *PxArticulationTendonJoint) -> *PxArticulationFixedTendon { return this.pxarticulationtendonjoint_vtable.getTendon(this); }

    vtable :: (obj: *PxArticulationTendonJoint) -> *PxArticulationTendonJoint_VTable { return obj.pxarticulationtendonjoint_vtable; }


    /*
    \brief Common API base class shared by PxArticulationSpatialTendon and PxArticulationFixedTendon.
    */
    PxArticulationTendon :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxArticulationTendon, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationTendon@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationTendon, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationTendon@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxarticulationtendon_vtable: *PxArticulationTendon_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxArticulationTendon, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationTendon@physx@@UEAA@XZ";
    }
    PxArticulationTendon_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        setStiffness: (this: *PxArticulationTendon, stiffness: PxReal) -> void #cpp_method;

        getStiffness: (this: *PxArticulationTendon) -> PxReal #cpp_method;

        setDamping: (this: *PxArticulationTendon, damping: PxReal) -> void #cpp_method;

        getDamping: (this: *PxArticulationTendon) -> PxReal #cpp_method;

        setLimitStiffness: (this: *PxArticulationTendon, stiffness: PxReal) -> void #cpp_method;

        getLimitStiffness: (this: *PxArticulationTendon) -> PxReal #cpp_method;

        setOffset: (this: *PxArticulationTendon, offset: PxReal, autowake := true) -> void #cpp_method;

        getOffset: (this: *PxArticulationTendon) -> PxReal #cpp_method;

        getArticulation: (this: *PxArticulationTendon) -> *PxArticulationReducedCoordinate #cpp_method;
    }

    PxArticulationTendon_setStiffness :: inline (this: *PxArticulationTendon, stiffness: PxReal) { this.pxarticulationtendon_vtable.setStiffness(this, stiffness); }

    PxArticulationTendon_getStiffness :: inline (this: *PxArticulationTendon) -> PxReal { return this.pxarticulationtendon_vtable.getStiffness(this); }

    PxArticulationTendon_setDamping :: inline (this: *PxArticulationTendon, damping: PxReal) { this.pxarticulationtendon_vtable.setDamping(this, damping); }

    PxArticulationTendon_getDamping :: inline (this: *PxArticulationTendon) -> PxReal { return this.pxarticulationtendon_vtable.getDamping(this); }

    PxArticulationTendon_setLimitStiffness :: inline (this: *PxArticulationTendon, stiffness: PxReal) { this.pxarticulationtendon_vtable.setLimitStiffness(this, stiffness); }

    PxArticulationTendon_getLimitStiffness :: inline (this: *PxArticulationTendon) -> PxReal { return this.pxarticulationtendon_vtable.getLimitStiffness(this); }

    PxArticulationTendon_setOffset :: inline (this: *PxArticulationTendon, offset: PxReal, autowake := true) { this.pxarticulationtendon_vtable.setOffset(this, offset, autowake); }

    PxArticulationTendon_getOffset :: inline (this: *PxArticulationTendon) -> PxReal { return this.pxarticulationtendon_vtable.getOffset(this); }

    PxArticulationTendon_getArticulation :: inline (this: *PxArticulationTendon) -> *PxArticulationReducedCoordinate { return this.pxarticulationtendon_vtable.getArticulation(this); }

    vtable :: (obj: *PxArticulationTendon) -> *PxArticulationTendon_VTable { return obj.pxarticulationtendon_vtable; }


    /*
    \brief A spatial tendon that attaches to an articulation.
    
    A spatial tendon attaches to multiple links in an articulation using a set of PxArticulationAttachments.
    The tendon is defined as a tree of attachment points, where each attachment can have an arbitrary number of children.
    Each leaf of the attachment tree defines a subtendon between itself and the root attachment. The subtendon then
    applies forces at the leaf, and an equal but opposing force at the root, in order to satisfy the spring-damper and limit
    constraints that the user sets up. Attachments in between the root and leaf do not exert any force on the articulation,
    but define the geometry of the tendon from which the length is computed together with the attachment coefficients.
    */
    PxArticulationSpatialTendon :: struct {
        #as using pxarticulationtendon: PxArticulationTendon;

        Constructor :: (this: *PxArticulationSpatialTendon, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationSpatialTendon@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationSpatialTendon, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationSpatialTendon@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxarticulationtendon; pxarticulationspatialtendon_vtable: *PxArticulationSpatialTendon_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief Returns the string name of the dynamic type.
        
        \return The string name.
        */
        virtual_getConcreteTypeName :: (this: *PxArticulationSpatialTendon) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxArticulationSpatialTendon@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxArticulationSpatialTendon, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationSpatialTendon@physx@@UEAA@XZ";
    }
    PxArticulationSpatialTendon_VTable :: struct #type_info_none {
        using pxarticulationtendon: PxArticulationTendon_VTable;
        createAttachment: (this: *PxArticulationSpatialTendon, parent: *PxArticulationAttachment, coefficient: PxReal, relativeOffset: PxVec3, link: *PxArticulationLink) -> *PxArticulationAttachment #cpp_method;

        getAttachments: (this: *PxArticulationSpatialTendon, userBuffer: **PxArticulationAttachment, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbAttachments: (this: *PxArticulationSpatialTendon) -> PxU32 #cpp_method;
    }

    PxArticulationSpatialTendon_createAttachment :: inline (this: *PxArticulationSpatialTendon, parent: *PxArticulationAttachment, coefficient: PxReal, relativeOffset: PxVec3, link: *PxArticulationLink) -> *PxArticulationAttachment { return this.pxarticulationspatialtendon_vtable.createAttachment(this, parent, coefficient, relativeOffset, link); }

    PxArticulationSpatialTendon_getAttachments :: inline (this: *PxArticulationSpatialTendon, userBuffer: **PxArticulationAttachment, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationspatialtendon_vtable.getAttachments(this, userBuffer, bufferSize, startIndex); }

    PxArticulationSpatialTendon_getNbAttachments :: inline (this: *PxArticulationSpatialTendon) -> PxU32 { return this.pxarticulationspatialtendon_vtable.getNbAttachments(this); }

    vtable :: (obj: *PxArticulationSpatialTendon) -> *PxArticulationSpatialTendon_VTable { return obj.pxarticulationspatialtendon_vtable; }


    /*
    \brief A fixed tendon that can be used to link multiple degrees of freedom of multiple articulation joints via length and limit constraints.
    
    Fixed tendons allow the simulation of coupled relationships between joint degrees of freedom in an articulation. Fixed tendons do not allow
    linking arbitrary joint axes of the articulation: The respective joints must all be directly connected to each other in the articulation structure,
    i.e. each of the joints in the tendon must be connected by a single articulation link to another joint in the same tendon. This implies both that
    1) fixed tendons can branch along a branching articulation; and 2) they cannot be used to create relationships between axes in a spherical joint with
    more than one degree of freedom. Locked joint axes or fixed joints are currently not supported.
    */
    PxArticulationFixedTendon :: struct {
        #as using pxarticulationtendon: PxArticulationTendon;

        Constructor :: (this: *PxArticulationFixedTendon, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationFixedTendon@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationFixedTendon, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationFixedTendon@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxarticulationtendon; pxarticulationfixedtendon_vtable: *PxArticulationFixedTendon_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief Returns the string name of the dynamic type.
        
        \return The string name.
        */
        virtual_getConcreteTypeName :: (this: *PxArticulationFixedTendon) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxArticulationFixedTendon@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxArticulationFixedTendon, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationFixedTendon@physx@@UEAA@XZ";
    }
    PxArticulationFixedTendon_VTable :: struct #type_info_none {
        using pxarticulationtendon: PxArticulationTendon_VTable;
        createTendonJoint: (this: *PxArticulationFixedTendon, parent: *PxArticulationTendonJoint, axis: PxArticulationAxis.Enum, coefficient: PxReal, recipCoefficient: PxReal, link: *PxArticulationLink) -> *PxArticulationTendonJoint #cpp_method;

        getTendonJoints: (this: *PxArticulationFixedTendon, userBuffer: **PxArticulationTendonJoint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbTendonJoints: (this: *PxArticulationFixedTendon) -> PxU32 #cpp_method;

        setRestLength: (this: *PxArticulationFixedTendon, restLength: PxReal) -> void #cpp_method;

        getRestLength: (this: *PxArticulationFixedTendon) -> PxReal #cpp_method;

        setLimitParameters: (this: *PxArticulationFixedTendon, parameter: *PxArticulationTendonLimit) -> void #cpp_method;

        getLimitParameters: (this: *PxArticulationFixedTendon) -> PxArticulationTendonLimit #cpp_method;
    }

    PxArticulationFixedTendon_createTendonJoint :: inline (this: *PxArticulationFixedTendon, parent: *PxArticulationTendonJoint, axis: PxArticulationAxis.Enum, coefficient: PxReal, recipCoefficient: PxReal, link: *PxArticulationLink) -> *PxArticulationTendonJoint { return this.pxarticulationfixedtendon_vtable.createTendonJoint(this, parent, axis, coefficient, recipCoefficient, link); }

    PxArticulationFixedTendon_getTendonJoints :: inline (this: *PxArticulationFixedTendon, userBuffer: **PxArticulationTendonJoint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationfixedtendon_vtable.getTendonJoints(this, userBuffer, bufferSize, startIndex); }

    PxArticulationFixedTendon_getNbTendonJoints :: inline (this: *PxArticulationFixedTendon) -> PxU32 { return this.pxarticulationfixedtendon_vtable.getNbTendonJoints(this); }

    PxArticulationFixedTendon_setRestLength :: inline (this: *PxArticulationFixedTendon, restLength: PxReal) { this.pxarticulationfixedtendon_vtable.setRestLength(this, restLength); }

    PxArticulationFixedTendon_getRestLength :: inline (this: *PxArticulationFixedTendon) -> PxReal { return this.pxarticulationfixedtendon_vtable.getRestLength(this); }

    PxArticulationFixedTendon_setLimitParameters :: inline (this: *PxArticulationFixedTendon, parameter: *PxArticulationTendonLimit) { this.pxarticulationfixedtendon_vtable.setLimitParameters(this, parameter); }

    PxArticulationFixedTendon_getLimitParameters :: inline (this: *PxArticulationFixedTendon) -> PxArticulationTendonLimit { return this.pxarticulationfixedtendon_vtable.getLimitParameters(this); }

    vtable :: (obj: *PxArticulationFixedTendon) -> *PxArticulationFixedTendon_VTable { return obj.pxarticulationfixedtendon_vtable; }


    /*
    \brief Structure representing residual values.
    
    This struct holds residual values, typically used in physics simulations to measure error or discrepancy.
    */
    PxResidual :: struct {
        rmsResidual: PxReal; //!< Root mean square residual value.
        maxResidual: PxReal; //!< Maximum residual value.

        Constructor :: (this: *PxResidual) -> void #cpp_method #foreign physx_static "??0PxResidual@physx@@QEAA@XZ";
    }

    /*
    \brief Structure representing residual values
    
    This struct holds residual values for both position and velocity iterations.
    */
    PxResiduals :: struct {
        positionIterationResidual: PxResidual; //!< Residual values for position iteration.
        velocityIterationResidual: PxResidual; //!< Residual values for velocity iteration.
    }

    PxArticulationResidual :: PxResiduals;
    PxSceneResidual :: PxResiduals;

    /*
    \brief Structure representing residual values for a constraint.
    
    This struct holds residual values for both position and velocity iterations specific to a constraint.
    */
    PxConstraintResidual :: struct {
        positionIterationResidual: PxReal; //!< Residual value for position iteration.
        velocityIterationResidual: PxReal; //!< Residual value for velocity iteration.

        Constructor :: (this: *PxConstraintResidual) -> void #cpp_method #foreign physx_static "??0PxConstraintResidual@physx@@QEAA@XZ";
    }

    /*
    * \brief A mimic joint enforces a linear relationship between the positions of two joints of the same articulation instance.
    \see PxArticulationReducedCoodinate::createMimicJoint()
    */
    PxArticulationMimicJoint :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxArticulationMimicJoint, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationMimicJoint@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationMimicJoint, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationMimicJoint@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxarticulationmimicjoint_vtable: *PxArticulationMimicJoint_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief Returns the string name of the dynamic type.
        
        \return The string name.
        */
        virtual_getConcreteTypeName :: (this: *PxArticulationMimicJoint) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxArticulationMimicJoint@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxArticulationMimicJoint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationMimicJoint@physx@@UEAA@XZ";
    }
    PxArticulationMimicJoint_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getArticulation: (this: *PxArticulationMimicJoint) -> *PxArticulationReducedCoordinate #cpp_method;

        getGearRatio: (this: *PxArticulationMimicJoint) -> PxReal #cpp_method;

        setGearRatio: (this: *PxArticulationMimicJoint, gearRatio: PxReal) -> void #cpp_method;

        getOffset: (this: *PxArticulationMimicJoint) -> PxReal #cpp_method;

        setOffset: (this: *PxArticulationMimicJoint, offset: PxReal) -> void #cpp_method;

        getJointA: (this: *PxArticulationMimicJoint) -> *PxArticulationJointReducedCoordinate #cpp_method;

        getJointB: (this: *PxArticulationMimicJoint) -> *PxArticulationJointReducedCoordinate #cpp_method;

        getAxisA: (this: *PxArticulationMimicJoint) -> PxArticulationAxis.Enum #cpp_method;

        getAxisB: (this: *PxArticulationMimicJoint) -> PxArticulationAxis.Enum #cpp_method;
    }

    PxArticulationMimicJoint_getArticulation :: inline (this: *PxArticulationMimicJoint) -> *PxArticulationReducedCoordinate { return this.pxarticulationmimicjoint_vtable.getArticulation(this); }

    PxArticulationMimicJoint_getGearRatio :: inline (this: *PxArticulationMimicJoint) -> PxReal { return this.pxarticulationmimicjoint_vtable.getGearRatio(this); }

    PxArticulationMimicJoint_setGearRatio :: inline (this: *PxArticulationMimicJoint, gearRatio: PxReal) { this.pxarticulationmimicjoint_vtable.setGearRatio(this, gearRatio); }

    PxArticulationMimicJoint_getOffset :: inline (this: *PxArticulationMimicJoint) -> PxReal { return this.pxarticulationmimicjoint_vtable.getOffset(this); }

    PxArticulationMimicJoint_setOffset :: inline (this: *PxArticulationMimicJoint, offset: PxReal) { this.pxarticulationmimicjoint_vtable.setOffset(this, offset); }

    PxArticulationMimicJoint_getJointA :: inline (this: *PxArticulationMimicJoint) -> *PxArticulationJointReducedCoordinate { return this.pxarticulationmimicjoint_vtable.getJointA(this); }

    PxArticulationMimicJoint_getJointB :: inline (this: *PxArticulationMimicJoint) -> *PxArticulationJointReducedCoordinate { return this.pxarticulationmimicjoint_vtable.getJointB(this); }

    PxArticulationMimicJoint_getAxisA :: inline (this: *PxArticulationMimicJoint) -> PxArticulationAxis.Enum { return this.pxarticulationmimicjoint_vtable.getAxisA(this); }

    PxArticulationMimicJoint_getAxisB :: inline (this: *PxArticulationMimicJoint) -> PxArticulationAxis.Enum { return this.pxarticulationmimicjoint_vtable.getAxisB(this); }

    vtable :: (obj: *PxArticulationMimicJoint) -> *PxArticulationMimicJoint_VTable { return obj.pxarticulationmimicjoint_vtable; }


    /*
    \brief Data structure to represent spatial forces.
    */
    PxSpatialForce :: struct {
        force:  PxVec3;
        pad0:   PxReal;
        torque: PxVec3;
        pad1:   PxReal;
    }

    /*
    \brief Data structure to represent spatial velocities.
    */
    PxSpatialVelocity :: struct {
        linear:  PxVec3;
        pad0:    PxReal;
        angular: PxVec3;
        pad1:    PxReal;
    }

    /*
    \brief Data structure used to access the root link state and acceleration.
    
    \see PxArticulationCache
    */
    PxArticulationRootLinkData :: struct {
        transform:     PxTransform; //!< Actor transform

        worldLinVel:   PxVec3; //!< Link linear velocity
        worldAngVel:   PxVec3; //!< Link angular velocity
        worldLinAccel: PxVec3; //!< Link classical linear acceleration
        worldAngAccel: PxVec3; //!< Link angular acceleration
    }

    /*
    \brief Data structure used to read and write internal articulation data.
    
    \see PxArticulationCacheFlag, PxArticulationReducedCoordinate::createCache, PxArticulationReducedCoordinate::applyCache,
    PxArticulationReducedCoordinate::copyInternalStateToCache
    */
    PxArticulationCache :: struct {
        /*
        \brief Releases an articulation cache.
        
        \see PxArticulationReducedCoordinate::createCache, PxArticulationReducedCoordinate::applyCache,
        PxArticulationReducedCoordinate::copyInternalStateToCache
        */
        release :: (this: *PxArticulationCache) -> void #cpp_method #foreign physx_static "?release@PxArticulationCache@physx@@QEAAXXZ";

        /*
        \brief External forces acting on the articulation links for inverse dynamics computation.
        
        - N = getNbLinks().
        - Indexing follows the low-level link indices, see PxArticulationLink::getLinkIndex.
        - The forces are with respect to the center of mass of the link.
        - This field cannot be used to apply forces to links during the next PxScene::simulate() call. Use PxRigidBody::addForce and related functions instead.
        
        \see PxArticulationReducedCoordinate::computeGeneralizedExternalForce
        */
        externalForces:         *PxSpatialForce;

        /*
        \brief Dense Jacobian data.
        
        - N = nbRows * nbCols = (6 * getNbLinks()) * (6 + getDofs()) -> size includes possible floating-base DOFs regardless of PxArticulationFlag::eFIX_BASE flag.
        - The links, i.e. rows are in order of the low-level link indices (minus one if PxArticulationFlag::eFIX_BASE is true), see PxArticulationLink::getLinkIndex.
        The corresponding spatial velocities are stacked [vx; vy; vz; wx; wy; wz], where vx and wx refer to the linear and rotational velocity in world X.
        - The DOFs, i.e. column indices correspond to the low-level DOF indices, see PxArticulationCache::jointVelocity.
        
        \see PxArticulationReducedCoordinate::computeDenseJacobian
        */
        denseJacobian:          *PxReal;

        /*
        \brief The generalized mass matrix that maps joint accelerations to joint forces.
        
        - N = getDofs() * getDofs().
        - The indexing follows the internal DOF index order, see PxArticulationCache::jointVelocity.
        
        \see PxArticulationReducedCoordinate::computeGeneralizedMassMatrix
        */
        massMatrix:             *PxReal;

        /*
        \brief The articulation joint DOF velocities.
        
        - N = getDofs().
        - Read/write using PxArticulationCacheFlag::eVELOCITY.
        - The indexing follows the internal DOF index order. Therefore, the application should calculate the DOF data indices by summing the joint DOFs in the order of
        the links' low-level indices (see the manual Section "Cache Indexing" for a snippet for this calculation):
        \verbatim Low-level link index:   | link 0 | link 1 | link 2 | link 3 | ... | <- PxArticulationLink::getLinkIndex()       \endverbatim
        \verbatim Link inbound joint DOF: | 0      | 1      | 2      | 1      | ... | <- PxArticulationLink::getInboundJointDof() \endverbatim
        \verbatim Low-level DOF index:    | -      | 0      | 1, 2   | 3      | ... |                                             \endverbatim
        The root link always has low-level index 0 and always has zero inbound joint DOFs. The link DOF indexing follows the order in PxArticulationAxis::Enum.
        For example, assume that low-level link 2 has an inbound spherical joint with two DOFs: eSWING1 and eSWING2. The corresponding low-level joint DOF indices
        are therefore 1 for eSWING1 and 2 for eSWING2.
        */
        jointVelocity:          *PxReal;

        /*
        \brief The articulation joint DOF accelerations.
        
        - N = getDofs().
        - Read using PxArticulationCacheFlag::eACCELERATION.
        - The indexing follows the internal DOF index order, see PxArticulationCache::jointVelocity.
        - Delta joint DOF velocities can be computed from acceleration * dt.
        */
        jointAcceleration:      *PxReal;

        /*
        \brief The articulation joint DOF positions.
        
        - N = getDofs().
        - Read/write using PxArticulationCacheFlag::ePOSITION.
        - The indexing follows the internal DOF index order, see PxArticulationCache::jointVelocity.
        - For spherical joints, the joint position for each axis on the joint must be in range [-Pi, Pi].
        */
        jointPosition:          *PxReal;

        /*
        \brief The articulation joint DOF forces.
        
        - N = getDofs().
        - Read/Write using PxArticulationCacheFlag::eFORCE.
        - The indexing follows the internal DOF index order, see PxArticulationCache::jointVelocity.
        - Applied joint forces persist and are applied each frame until changed.
        */
        jointForce:             *PxReal;

        /*
        \brief The articulation joint drive target positions.
        
        - N = getDofs().
        - Write using PxArticulationCacheFlag::eJOINT_TARGET_POSITIONS.
        - The indexing follows the internal DOF index order, see PxArticulationCache::jointVelocity.
        */
        jointTargetPositions:   *PxReal;

        /*
        \brief The articulation joint drive target velocities.
        
        - N = getDofs().
        - Write using PxArticulationCacheFlag::eJOINT_TARGET_VELOCITIES.
        - The indexing follows the internal DOF index order, see PxArticulationCache::jointVelocity.
        */
        jointTargetVelocities:  *PxReal;

        /*
        \brief Link spatial velocity.
        
        - N = getNbLinks().
        - Read using PxArticulationCacheFlag::eLINK_VELOCITY.
        - The indexing follows the internal link indexing, see PxArticulationLink::getLinkIndex.
        - The velocity is with respect to the link's center of mass but represented in world space.
        
        \see PxRigidBody::getCMassLocalPose
        */
        linkVelocity:           *PxSpatialVelocity;

        /*
        \brief Link classical acceleration.
        
        - N = getNbLinks().
        - Read using PxArticulationCacheFlag::eLINK_ACCELERATION.
        - The indexing follows the internal link indexing, see PxArticulationLink::getLinkIndex.
        - The acceleration is with respect to the link's center of mass.
        
        \see PxArticulationReducedCoordinate::getLinkAcceleration, PxRigidBody::getCMassLocalPose
        */
        linkAcceleration:       *PxSpatialVelocity;

        /*
        \brief Link incoming joint force, i.e. the total force transmitted from the parent link to this link.
        
        - N = getNbLinks().
        - Read using PxArticulationCacheFlag::eLINK_INCOMING_JOINT_FORCE.
        - The indexing follows the internal link indexing, see PxArticulationLink::getLinkIndex.
        - The force is reported in the child joint frame of the link's incoming joint.
        
        \see PxArticulationJointReducedCoordinate::getChildPose
        \note The root link reports a zero spatial force.
        */
        linkIncomingJointForce: *PxSpatialForce;

        /*
        \brief Root link transform, velocities, and accelerations.
        
        - N = 1.
        - Read/write using PxArticulationCacheFlag::eROOT_TRANSFORM and PxArticulationCacheFlag::eROOT_VELOCITIES (accelerations are read-only).
        
        \see PxArticulationRootLinkData
        */
        rootLinkData:           *PxArticulationRootLinkData;

        /*
        \deprecated The API related to loop joints will be removed in a future version once a replacement is made available.
        
        \brief Constraint coefficient matrix.
        
        - N = getCoefficentMatrixSize().
        - The user needs to allocate memory and set this member to the allocated memory.
        
        \see PxArticulationReducedCoordinate::computeCoefficientMatrix
        */
        coefficientMatrix:      *PxReal;

        /*
        \deprecated The API related to loop joints will be removed in a future version once a replacement is made available.
        
        \brief Constraint lambda values (impulses applied by the respective constraints).
        
        - N = getNbLoopJoints().
        - The user needs to allocate memory and set this member to the allocated memory.
        
        \see PxArticulationReducedCoordinate::computeLambda
        */
        lambda:                 *PxReal;

        scratchMemory:          *void; //!< The scratch memory is used for internal calculations.
        scratchAllocator:       *void; //!< The scratch allocator is used for internal calculations.
        version:                PxU32; //!< The cache version used internally to check compatibility with the articulation, i.e. detect if the articulation configuration changed after the cache was created.
    }

    /*
    \brief Flag that configures articulation-state updates by PxArticulationReducedCoordinate::updateKinematic.
    */
    PxArticulationKinematicFlag :: struct {
        Enum :: enum s32 {
            POSITION :: 1;
            VELOCITY :: 2;

            ePOSITION :: POSITION;
            eVELOCITY :: VELOCITY;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxArticulationKinematicFlags :: PxFlags(PxArticulationKinematicFlag.Enum, PxU8);
    operator| :: (a: PxArticulationKinematicFlag.Enum, b: PxArticulationKinematicFlag.Enum) -> PxFlags(PxArticulationKinematicFlag.Enum, PxU8) #foreign physx_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxArticulationKinematicFlag@physx@@E@0@W4Enum@PxArticulationKinematicFlag@0@0@Z";

    /*
    \brief A tree structure of bodies connected by joints that is treated as a unit by the dynamics solver. Parametrized in reduced (joint) coordinates.
    
    \see PxArticulationJointReducedCoordinate, PxArticulationLink, PxPhysics::createArticulationReducedCoordinate
    */
    PxArticulationReducedCoordinate :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxArticulationReducedCoordinate, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationReducedCoordinate@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationReducedCoordinate, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationReducedCoordinate@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxarticulationreducedcoordinate_vtable: *PxArticulationReducedCoordinate_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxArticulationReducedCoordinate, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationReducedCoordinate@physx@@UEAA@XZ";
    }
    PxArticulationReducedCoordinate_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getScene: (this: *PxArticulationReducedCoordinate) -> *PxScene #cpp_method;

        setSolverIterationCounts: (this: *PxArticulationReducedCoordinate, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) -> void #cpp_method;

        getSolverIterationCounts: (this: *PxArticulationReducedCoordinate, minPositionIters: *PxU32, minVelocityIters: *PxU32) -> void #cpp_method;

        isSleeping: (this: *PxArticulationReducedCoordinate) -> bool #cpp_method;

        setSleepThreshold: (this: *PxArticulationReducedCoordinate, threshold: PxReal) -> void #cpp_method;

        getSleepThreshold: (this: *PxArticulationReducedCoordinate) -> PxReal #cpp_method;

        setStabilizationThreshold: (this: *PxArticulationReducedCoordinate, threshold: PxReal) -> void #cpp_method;

        getStabilizationThreshold: (this: *PxArticulationReducedCoordinate) -> PxReal #cpp_method;

        setWakeCounter: (this: *PxArticulationReducedCoordinate, wakeCounterValue: PxReal) -> void #cpp_method;

        getWakeCounter: (this: *PxArticulationReducedCoordinate) -> PxReal #cpp_method;

        wakeUp: (this: *PxArticulationReducedCoordinate) -> void #cpp_method;

        putToSleep: (this: *PxArticulationReducedCoordinate) -> void #cpp_method;

        setMaxCOMLinearVelocity: (this: *PxArticulationReducedCoordinate, maxLinearVelocity: PxReal) -> void #cpp_method;

        getMaxCOMLinearVelocity: (this: *PxArticulationReducedCoordinate) -> PxReal #cpp_method;

        setMaxCOMAngularVelocity: (this: *PxArticulationReducedCoordinate, maxAngularVelocity: PxReal) -> void #cpp_method;

        getMaxCOMAngularVelocity: (this: *PxArticulationReducedCoordinate) -> PxReal #cpp_method;

        createLink: (this: *PxArticulationReducedCoordinate, parent: *PxArticulationLink, pose: *PxTransform) -> *PxArticulationLink #cpp_method;

        getNbLinks: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        getLinks: (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbShapes: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        setName: (this: *PxArticulationReducedCoordinate, name: *u8) -> void #cpp_method;

        getName: (this: *PxArticulationReducedCoordinate) -> *u8 #cpp_method;

        getWorldBounds: (this: *PxArticulationReducedCoordinate, inflation: float = 1.01) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getAggregate: (this: *PxArticulationReducedCoordinate) -> *PxAggregate #cpp_method;

        setArticulationFlags: (this: *PxArticulationReducedCoordinate, flags: PxArticulationFlags) -> void #cpp_method;

        setArticulationFlag: (this: *PxArticulationReducedCoordinate, flag: PxArticulationFlag.Enum, value: bool) -> void #cpp_method;

        getArticulationFlags: (this: *PxArticulationReducedCoordinate) -> PxArticulationFlags #cpp_method;

        getDofs: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        createCache: (this: *PxArticulationReducedCoordinate) -> *PxArticulationCache #cpp_method;

        getCacheDataSize: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        zeroCache: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        applyCache: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flags: PxArticulationCacheFlags, autowake := true) -> void #cpp_method;

        copyInternalStateToCache: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flags: PxArticulationCacheFlags) -> void #cpp_method;

        packJointData: (this: *PxArticulationReducedCoordinate, maximum: *PxReal, reduced: *PxReal) -> void #cpp_method;

        unpackJointData: (this: *PxArticulationReducedCoordinate, reduced: *PxReal, maximum: *PxReal) -> void #cpp_method;

        commonInit: (this: *PxArticulationReducedCoordinate) -> void #cpp_method;

        computeGeneralizedGravityForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeCoriolisAndCentrifugalForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeGeneralizedExternalForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeJointAcceleration: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeJointForce: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeDenseJacobian: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, nRows: *PxU32, nCols: *PxU32) -> void #cpp_method;

        computeCoefficientMatrix: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        computeLambda: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, initialState: *PxArticulationCache, jointTorque: *PxReal, maxIter: PxU32) -> bool #cpp_method;

        computeGeneralizedMassMatrix: (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) -> void #cpp_method;

        addLoopJoint: (this: *PxArticulationReducedCoordinate, joint: *PxConstraint) -> void #cpp_method;

        removeLoopJoint: (this: *PxArticulationReducedCoordinate, joint: *PxConstraint) -> void #cpp_method;

        getNbLoopJoints: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        getLoopJoints: (this: *PxArticulationReducedCoordinate, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getCoefficientMatrixSize: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        setRootGlobalPose: (this: *PxArticulationReducedCoordinate, pose: *PxTransform, autowake := true) -> void #cpp_method;

        getRootGlobalPose: (this: *PxArticulationReducedCoordinate) -> PxTransform #cpp_method;

        setRootLinearVelocity: (this: *PxArticulationReducedCoordinate, linearVelocity: *PxVec3, autowake := true) -> void #cpp_method;

        getRootLinearVelocity: (this: *PxArticulationReducedCoordinate) -> PxVec3 #cpp_method;

        setRootAngularVelocity: (this: *PxArticulationReducedCoordinate, angularVelocity: *PxVec3, autowake := true) -> void #cpp_method;

        getRootAngularVelocity: (this: *PxArticulationReducedCoordinate) -> PxVec3 #cpp_method;

        getLinkAcceleration: (this: *PxArticulationReducedCoordinate, linkId: PxU32) -> PxSpatialVelocity #cpp_method;

        getGpuArticulationIndex: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        getGPUIndex: (this: *PxArticulationReducedCoordinate) -> PxArticulationGPUIndex #cpp_method;

        createSpatialTendon: (this: *PxArticulationReducedCoordinate) -> *PxArticulationSpatialTendon #cpp_method;

        createFixedTendon: (this: *PxArticulationReducedCoordinate) -> *PxArticulationFixedTendon #cpp_method;

        getSpatialTendons: (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationSpatialTendon, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbSpatialTendons: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        getFixedTendons: (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationFixedTendon, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbFixedTendons: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        createMimicJoint: (this: *PxArticulationReducedCoordinate, jointA: *PxArticulationJointReducedCoordinate, axisA: PxArticulationAxis.Enum, jointB: *PxArticulationJointReducedCoordinate, axisB: PxArticulationAxis.Enum, gearRatio: PxReal, offset: PxReal) -> *PxArticulationMimicJoint #cpp_method;

        getMimicJoints: (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationMimicJoint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbMimicJoints: (this: *PxArticulationReducedCoordinate) -> PxU32 #cpp_method;

        updateKinematic: (this: *PxArticulationReducedCoordinate, flags: PxArticulationKinematicFlags) -> void #cpp_method;

        getSolverResidual: (this: *PxArticulationReducedCoordinate) -> PxArticulationResidual #cpp_method;
    }

    PxArticulationReducedCoordinate_getScene :: inline (this: *PxArticulationReducedCoordinate) -> *PxScene { return this.pxarticulationreducedcoordinate_vtable.getScene(this); }

    PxArticulationReducedCoordinate_setSolverIterationCounts :: inline (this: *PxArticulationReducedCoordinate, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) { this.pxarticulationreducedcoordinate_vtable.setSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxArticulationReducedCoordinate_getSolverIterationCounts :: inline (this: *PxArticulationReducedCoordinate, minPositionIters: *PxU32, minVelocityIters: *PxU32) { this.pxarticulationreducedcoordinate_vtable.getSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxArticulationReducedCoordinate_isSleeping :: inline (this: *PxArticulationReducedCoordinate) -> bool { return this.pxarticulationreducedcoordinate_vtable.isSleeping(this); }

    PxArticulationReducedCoordinate_setSleepThreshold :: inline (this: *PxArticulationReducedCoordinate, threshold: PxReal) { this.pxarticulationreducedcoordinate_vtable.setSleepThreshold(this, threshold); }

    PxArticulationReducedCoordinate_getSleepThreshold :: inline (this: *PxArticulationReducedCoordinate) -> PxReal { return this.pxarticulationreducedcoordinate_vtable.getSleepThreshold(this); }

    PxArticulationReducedCoordinate_setStabilizationThreshold :: inline (this: *PxArticulationReducedCoordinate, threshold: PxReal) { this.pxarticulationreducedcoordinate_vtable.setStabilizationThreshold(this, threshold); }

    PxArticulationReducedCoordinate_getStabilizationThreshold :: inline (this: *PxArticulationReducedCoordinate) -> PxReal { return this.pxarticulationreducedcoordinate_vtable.getStabilizationThreshold(this); }

    PxArticulationReducedCoordinate_setWakeCounter :: inline (this: *PxArticulationReducedCoordinate, wakeCounterValue: PxReal) { this.pxarticulationreducedcoordinate_vtable.setWakeCounter(this, wakeCounterValue); }

    PxArticulationReducedCoordinate_getWakeCounter :: inline (this: *PxArticulationReducedCoordinate) -> PxReal { return this.pxarticulationreducedcoordinate_vtable.getWakeCounter(this); }

    PxArticulationReducedCoordinate_wakeUp :: inline (this: *PxArticulationReducedCoordinate) { this.pxarticulationreducedcoordinate_vtable.wakeUp(this); }

    PxArticulationReducedCoordinate_putToSleep :: inline (this: *PxArticulationReducedCoordinate) { this.pxarticulationreducedcoordinate_vtable.putToSleep(this); }

    PxArticulationReducedCoordinate_setMaxCOMLinearVelocity :: inline (this: *PxArticulationReducedCoordinate, maxLinearVelocity: PxReal) { this.pxarticulationreducedcoordinate_vtable.setMaxCOMLinearVelocity(this, maxLinearVelocity); }

    PxArticulationReducedCoordinate_getMaxCOMLinearVelocity :: inline (this: *PxArticulationReducedCoordinate) -> PxReal { return this.pxarticulationreducedcoordinate_vtable.getMaxCOMLinearVelocity(this); }

    PxArticulationReducedCoordinate_setMaxCOMAngularVelocity :: inline (this: *PxArticulationReducedCoordinate, maxAngularVelocity: PxReal) { this.pxarticulationreducedcoordinate_vtable.setMaxCOMAngularVelocity(this, maxAngularVelocity); }

    PxArticulationReducedCoordinate_getMaxCOMAngularVelocity :: inline (this: *PxArticulationReducedCoordinate) -> PxReal { return this.pxarticulationreducedcoordinate_vtable.getMaxCOMAngularVelocity(this); }

    PxArticulationReducedCoordinate_createLink :: inline (this: *PxArticulationReducedCoordinate, parent: *PxArticulationLink, pose: *PxTransform) -> *PxArticulationLink { return this.pxarticulationreducedcoordinate_vtable.createLink(this, parent, pose); }

    PxArticulationReducedCoordinate_getNbLinks :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getNbLinks(this); }

    PxArticulationReducedCoordinate_getLinks :: inline (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getLinks(this, userBuffer, bufferSize, startIndex); }

    PxArticulationReducedCoordinate_getNbShapes :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getNbShapes(this); }

    PxArticulationReducedCoordinate_setName :: inline (this: *PxArticulationReducedCoordinate, name: *u8) { this.pxarticulationreducedcoordinate_vtable.setName(this, name); }

    PxArticulationReducedCoordinate_getName :: inline (this: *PxArticulationReducedCoordinate) -> *u8 { return this.pxarticulationreducedcoordinate_vtable.getName(this); }

    PxArticulationReducedCoordinate_getWorldBounds :: inline (this: *PxArticulationReducedCoordinate, inflation: float = 1.01) -> PxBounds3 { return this.pxarticulationreducedcoordinate_vtable.getWorldBounds(this, inflation); }

    PxArticulationReducedCoordinate_getAggregate :: inline (this: *PxArticulationReducedCoordinate) -> *PxAggregate { return this.pxarticulationreducedcoordinate_vtable.getAggregate(this); }

    PxArticulationReducedCoordinate_setArticulationFlags :: inline (this: *PxArticulationReducedCoordinate, flags: PxArticulationFlags) { this.pxarticulationreducedcoordinate_vtable.setArticulationFlags(this, flags); }

    PxArticulationReducedCoordinate_setArticulationFlag :: inline (this: *PxArticulationReducedCoordinate, flag: PxArticulationFlag.Enum, value: bool) { this.pxarticulationreducedcoordinate_vtable.setArticulationFlag(this, flag, value); }

    PxArticulationReducedCoordinate_getArticulationFlags :: inline (this: *PxArticulationReducedCoordinate) -> PxArticulationFlags { return this.pxarticulationreducedcoordinate_vtable.getArticulationFlags(this); }

    PxArticulationReducedCoordinate_getDofs :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getDofs(this); }

    PxArticulationReducedCoordinate_createCache :: inline (this: *PxArticulationReducedCoordinate) -> *PxArticulationCache { return this.pxarticulationreducedcoordinate_vtable.createCache(this); }

    PxArticulationReducedCoordinate_getCacheDataSize :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getCacheDataSize(this); }

    PxArticulationReducedCoordinate_zeroCache :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.zeroCache(this, cache); }

    PxArticulationReducedCoordinate_applyCache :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flags: PxArticulationCacheFlags, autowake := true) { this.pxarticulationreducedcoordinate_vtable.applyCache(this, cache, flags, autowake); }

    PxArticulationReducedCoordinate_copyInternalStateToCache :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, flags: PxArticulationCacheFlags) { this.pxarticulationreducedcoordinate_vtable.copyInternalStateToCache(this, cache, flags); }

    PxArticulationReducedCoordinate_packJointData :: inline (this: *PxArticulationReducedCoordinate, maximum: *PxReal, reduced: *PxReal) { this.pxarticulationreducedcoordinate_vtable.packJointData(this, maximum, reduced); }

    PxArticulationReducedCoordinate_unpackJointData :: inline (this: *PxArticulationReducedCoordinate, reduced: *PxReal, maximum: *PxReal) { this.pxarticulationreducedcoordinate_vtable.unpackJointData(this, reduced, maximum); }

    PxArticulationReducedCoordinate_commonInit :: inline (this: *PxArticulationReducedCoordinate) { this.pxarticulationreducedcoordinate_vtable.commonInit(this); }

    PxArticulationReducedCoordinate_computeGeneralizedGravityForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeGeneralizedGravityForce(this, cache); }

    PxArticulationReducedCoordinate_computeCoriolisAndCentrifugalForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeCoriolisAndCentrifugalForce(this, cache); }

    PxArticulationReducedCoordinate_computeGeneralizedExternalForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeGeneralizedExternalForce(this, cache); }

    PxArticulationReducedCoordinate_computeJointAcceleration :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeJointAcceleration(this, cache); }

    PxArticulationReducedCoordinate_computeJointForce :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeJointForce(this, cache); }

    PxArticulationReducedCoordinate_computeDenseJacobian :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, nRows: *PxU32, nCols: *PxU32) { this.pxarticulationreducedcoordinate_vtable.computeDenseJacobian(this, cache, nRows, nCols); }

    PxArticulationReducedCoordinate_computeCoefficientMatrix :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeCoefficientMatrix(this, cache); }

    PxArticulationReducedCoordinate_computeLambda :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache, initialState: *PxArticulationCache, jointTorque: *PxReal, maxIter: PxU32) -> bool { return this.pxarticulationreducedcoordinate_vtable.computeLambda(this, cache, initialState, jointTorque, maxIter); }

    PxArticulationReducedCoordinate_computeGeneralizedMassMatrix :: inline (this: *PxArticulationReducedCoordinate, cache: *PxArticulationCache) { this.pxarticulationreducedcoordinate_vtable.computeGeneralizedMassMatrix(this, cache); }

    PxArticulationReducedCoordinate_addLoopJoint :: inline (this: *PxArticulationReducedCoordinate, joint: *PxConstraint) { this.pxarticulationreducedcoordinate_vtable.addLoopJoint(this, joint); }

    PxArticulationReducedCoordinate_removeLoopJoint :: inline (this: *PxArticulationReducedCoordinate, joint: *PxConstraint) { this.pxarticulationreducedcoordinate_vtable.removeLoopJoint(this, joint); }

    PxArticulationReducedCoordinate_getNbLoopJoints :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getNbLoopJoints(this); }

    PxArticulationReducedCoordinate_getLoopJoints :: inline (this: *PxArticulationReducedCoordinate, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getLoopJoints(this, userBuffer, bufferSize, startIndex); }

    PxArticulationReducedCoordinate_getCoefficientMatrixSize :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getCoefficientMatrixSize(this); }

    PxArticulationReducedCoordinate_setRootGlobalPose :: inline (this: *PxArticulationReducedCoordinate, pose: *PxTransform, autowake := true) { this.pxarticulationreducedcoordinate_vtable.setRootGlobalPose(this, pose, autowake); }

    PxArticulationReducedCoordinate_getRootGlobalPose :: inline (this: *PxArticulationReducedCoordinate) -> PxTransform { return this.pxarticulationreducedcoordinate_vtable.getRootGlobalPose(this); }

    PxArticulationReducedCoordinate_setRootLinearVelocity :: inline (this: *PxArticulationReducedCoordinate, linearVelocity: *PxVec3, autowake := true) { this.pxarticulationreducedcoordinate_vtable.setRootLinearVelocity(this, linearVelocity, autowake); }

    PxArticulationReducedCoordinate_getRootLinearVelocity :: inline (this: *PxArticulationReducedCoordinate) -> PxVec3 { return this.pxarticulationreducedcoordinate_vtable.getRootLinearVelocity(this); }

    PxArticulationReducedCoordinate_setRootAngularVelocity :: inline (this: *PxArticulationReducedCoordinate, angularVelocity: *PxVec3, autowake := true) { this.pxarticulationreducedcoordinate_vtable.setRootAngularVelocity(this, angularVelocity, autowake); }

    PxArticulationReducedCoordinate_getRootAngularVelocity :: inline (this: *PxArticulationReducedCoordinate) -> PxVec3 { return this.pxarticulationreducedcoordinate_vtable.getRootAngularVelocity(this); }

    PxArticulationReducedCoordinate_getLinkAcceleration :: inline (this: *PxArticulationReducedCoordinate, linkId: PxU32) -> PxSpatialVelocity { return this.pxarticulationreducedcoordinate_vtable.getLinkAcceleration(this, linkId); }

    PxArticulationReducedCoordinate_getGpuArticulationIndex :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getGpuArticulationIndex(this); }

    PxArticulationReducedCoordinate_getGPUIndex :: inline (this: *PxArticulationReducedCoordinate) -> PxArticulationGPUIndex { return this.pxarticulationreducedcoordinate_vtable.getGPUIndex(this); }

    PxArticulationReducedCoordinate_createSpatialTendon :: inline (this: *PxArticulationReducedCoordinate) -> *PxArticulationSpatialTendon { return this.pxarticulationreducedcoordinate_vtable.createSpatialTendon(this); }

    PxArticulationReducedCoordinate_createFixedTendon :: inline (this: *PxArticulationReducedCoordinate) -> *PxArticulationFixedTendon { return this.pxarticulationreducedcoordinate_vtable.createFixedTendon(this); }

    PxArticulationReducedCoordinate_getSpatialTendons :: inline (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationSpatialTendon, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getSpatialTendons(this, userBuffer, bufferSize, startIndex); }

    PxArticulationReducedCoordinate_getNbSpatialTendons :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getNbSpatialTendons(this); }

    PxArticulationReducedCoordinate_getFixedTendons :: inline (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationFixedTendon, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getFixedTendons(this, userBuffer, bufferSize, startIndex); }

    PxArticulationReducedCoordinate_getNbFixedTendons :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getNbFixedTendons(this); }

    PxArticulationReducedCoordinate_createMimicJoint :: inline (this: *PxArticulationReducedCoordinate, jointA: *PxArticulationJointReducedCoordinate, axisA: PxArticulationAxis.Enum, jointB: *PxArticulationJointReducedCoordinate, axisB: PxArticulationAxis.Enum, gearRatio: PxReal, offset: PxReal) -> *PxArticulationMimicJoint { return this.pxarticulationreducedcoordinate_vtable.createMimicJoint(this, jointA, axisA, jointB, axisB, gearRatio, offset); }

    PxArticulationReducedCoordinate_getMimicJoints :: inline (this: *PxArticulationReducedCoordinate, userBuffer: **PxArticulationMimicJoint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getMimicJoints(this, userBuffer, bufferSize, startIndex); }

    PxArticulationReducedCoordinate_getNbMimicJoints :: inline (this: *PxArticulationReducedCoordinate) -> PxU32 { return this.pxarticulationreducedcoordinate_vtable.getNbMimicJoints(this); }

    PxArticulationReducedCoordinate_updateKinematic :: inline (this: *PxArticulationReducedCoordinate, flags: PxArticulationKinematicFlags) { this.pxarticulationreducedcoordinate_vtable.updateKinematic(this, flags); }

    PxArticulationReducedCoordinate_getSolverResidual :: inline (this: *PxArticulationReducedCoordinate) -> PxArticulationResidual { return this.pxarticulationreducedcoordinate_vtable.getSolverResidual(this); }

    vtable :: (obj: *PxArticulationReducedCoordinate) -> *PxArticulationReducedCoordinate_VTable { return obj.pxarticulationreducedcoordinate_vtable; }


    /*
    \brief A joint between two links in an articulation.
    
    \see PxArticulationReducedCoordinate, PxArticulationLink
    */
    PxArticulationJointReducedCoordinate :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< The user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxArticulationJointReducedCoordinate, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationJointReducedCoordinate@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationJointReducedCoordinate, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationJointReducedCoordinate@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxarticulationjointreducedcoordinate_vtable: *PxArticulationJointReducedCoordinate_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief Returns the string name of the dynamic type.
        
        \return The string name.
        */
        virtual_getConcreteTypeName :: (this: *PxArticulationJointReducedCoordinate) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxArticulationJointReducedCoordinate@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxArticulationJointReducedCoordinate, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationJointReducedCoordinate@physx@@UEAA@XZ";

        virtual_isKindOf :: (this: *PxArticulationJointReducedCoordinate, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxArticulationJointReducedCoordinate@physx@@MEBA_NPEBD@Z";
    }
    PxArticulationJointReducedCoordinate_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getParentArticulationLink: (this: *PxArticulationJointReducedCoordinate) -> *PxArticulationLink #cpp_method;

        setParentPose: (this: *PxArticulationJointReducedCoordinate, pose: *PxTransform) -> void #cpp_method;

        getParentPose: (this: *PxArticulationJointReducedCoordinate) -> PxTransform #cpp_method;

        getChildArticulationLink: (this: *PxArticulationJointReducedCoordinate) -> *PxArticulationLink #cpp_method;

        setChildPose: (this: *PxArticulationJointReducedCoordinate, pose: *PxTransform) -> void #cpp_method;

        getChildPose: (this: *PxArticulationJointReducedCoordinate) -> PxTransform #cpp_method;

        setJointType: (this: *PxArticulationJointReducedCoordinate, jointType: PxArticulationJointType.Enum) -> void #cpp_method;

        getJointType: (this: *PxArticulationJointReducedCoordinate) -> PxArticulationJointType.Enum #cpp_method;

        setMotion: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, motion: PxArticulationMotion.Enum) -> void #cpp_method;

        getMotion: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationMotion.Enum #cpp_method;

        setLimitParams: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, limit: *PxArticulationLimit) -> void #cpp_method;

        getLimitParams: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationLimit #cpp_method #cpp_return_type_is_non_pod;

        setDriveParams: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, drive: *PxArticulationDrive) -> void #cpp_method;

        getDriveParams: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationDrive #cpp_method #cpp_return_type_is_non_pod;

        setDriveTarget: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, target: PxReal, autowake := true) -> void #cpp_method;

        getDriveTarget: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal #cpp_method;

        setDriveVelocity: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, targetVel: PxReal, autowake := true) -> void #cpp_method;

        getDriveVelocity: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal #cpp_method;

        setArmature: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, armature: PxReal) -> void #cpp_method;

        getArmature: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal #cpp_method;

        setFrictionCoefficient: (this: *PxArticulationJointReducedCoordinate, coefficient: PxReal) -> void #cpp_method;

        getFrictionCoefficient: (this: *PxArticulationJointReducedCoordinate) -> PxReal #cpp_method;

        setMaxJointVelocity: (this: *PxArticulationJointReducedCoordinate, maxJointV: PxReal) -> void #cpp_method;

        getMaxJointVelocity: (this: *PxArticulationJointReducedCoordinate) -> PxReal #cpp_method;

        setJointPosition: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, jointPos: PxReal) -> void #cpp_method;

        getJointPosition: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal #cpp_method;

        setJointVelocity: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, jointVel: PxReal) -> void #cpp_method;

        getJointVelocity: (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal #cpp_method;
    }

    PxArticulationJointReducedCoordinate_getParentArticulationLink :: inline (this: *PxArticulationJointReducedCoordinate) -> *PxArticulationLink { return this.pxarticulationjointreducedcoordinate_vtable.getParentArticulationLink(this); }

    PxArticulationJointReducedCoordinate_setParentPose :: inline (this: *PxArticulationJointReducedCoordinate, pose: *PxTransform) { this.pxarticulationjointreducedcoordinate_vtable.setParentPose(this, pose); }

    PxArticulationJointReducedCoordinate_getParentPose :: inline (this: *PxArticulationJointReducedCoordinate) -> PxTransform { return this.pxarticulationjointreducedcoordinate_vtable.getParentPose(this); }

    PxArticulationJointReducedCoordinate_getChildArticulationLink :: inline (this: *PxArticulationJointReducedCoordinate) -> *PxArticulationLink { return this.pxarticulationjointreducedcoordinate_vtable.getChildArticulationLink(this); }

    PxArticulationJointReducedCoordinate_setChildPose :: inline (this: *PxArticulationJointReducedCoordinate, pose: *PxTransform) { this.pxarticulationjointreducedcoordinate_vtable.setChildPose(this, pose); }

    PxArticulationJointReducedCoordinate_getChildPose :: inline (this: *PxArticulationJointReducedCoordinate) -> PxTransform { return this.pxarticulationjointreducedcoordinate_vtable.getChildPose(this); }

    PxArticulationJointReducedCoordinate_setJointType :: inline (this: *PxArticulationJointReducedCoordinate, jointType: PxArticulationJointType.Enum) { this.pxarticulationjointreducedcoordinate_vtable.setJointType(this, jointType); }

    PxArticulationJointReducedCoordinate_getJointType :: inline (this: *PxArticulationJointReducedCoordinate) -> PxArticulationJointType.Enum { return this.pxarticulationjointreducedcoordinate_vtable.getJointType(this); }

    PxArticulationJointReducedCoordinate_setMotion :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, motion: PxArticulationMotion.Enum) { this.pxarticulationjointreducedcoordinate_vtable.setMotion(this, axis, motion); }

    PxArticulationJointReducedCoordinate_getMotion :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationMotion.Enum { return this.pxarticulationjointreducedcoordinate_vtable.getMotion(this, axis); }

    PxArticulationJointReducedCoordinate_setLimitParams :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, limit: *PxArticulationLimit) { this.pxarticulationjointreducedcoordinate_vtable.setLimitParams(this, axis, limit); }

    PxArticulationJointReducedCoordinate_getLimitParams :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationLimit { return this.pxarticulationjointreducedcoordinate_vtable.getLimitParams(this, axis); }

    PxArticulationJointReducedCoordinate_setDriveParams :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, drive: *PxArticulationDrive) { this.pxarticulationjointreducedcoordinate_vtable.setDriveParams(this, axis, drive); }

    PxArticulationJointReducedCoordinate_getDriveParams :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxArticulationDrive { return this.pxarticulationjointreducedcoordinate_vtable.getDriveParams(this, axis); }

    PxArticulationJointReducedCoordinate_setDriveTarget :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, target: PxReal, autowake := true) { this.pxarticulationjointreducedcoordinate_vtable.setDriveTarget(this, axis, target, autowake); }

    PxArticulationJointReducedCoordinate_getDriveTarget :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getDriveTarget(this, axis); }

    PxArticulationJointReducedCoordinate_setDriveVelocity :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, targetVel: PxReal, autowake := true) { this.pxarticulationjointreducedcoordinate_vtable.setDriveVelocity(this, axis, targetVel, autowake); }

    PxArticulationJointReducedCoordinate_getDriveVelocity :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getDriveVelocity(this, axis); }

    PxArticulationJointReducedCoordinate_setArmature :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, armature: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setArmature(this, axis, armature); }

    PxArticulationJointReducedCoordinate_getArmature :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getArmature(this, axis); }

    PxArticulationJointReducedCoordinate_setFrictionCoefficient :: inline (this: *PxArticulationJointReducedCoordinate, coefficient: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setFrictionCoefficient(this, coefficient); }

    PxArticulationJointReducedCoordinate_getFrictionCoefficient :: inline (this: *PxArticulationJointReducedCoordinate) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getFrictionCoefficient(this); }

    PxArticulationJointReducedCoordinate_setMaxJointVelocity :: inline (this: *PxArticulationJointReducedCoordinate, maxJointV: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setMaxJointVelocity(this, maxJointV); }

    PxArticulationJointReducedCoordinate_getMaxJointVelocity :: inline (this: *PxArticulationJointReducedCoordinate) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getMaxJointVelocity(this); }

    PxArticulationJointReducedCoordinate_setJointPosition :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, jointPos: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setJointPosition(this, axis, jointPos); }

    PxArticulationJointReducedCoordinate_getJointPosition :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getJointPosition(this, axis); }

    PxArticulationJointReducedCoordinate_setJointVelocity :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum, jointVel: PxReal) { this.pxarticulationjointreducedcoordinate_vtable.setJointVelocity(this, axis, jointVel); }

    PxArticulationJointReducedCoordinate_getJointVelocity :: inline (this: *PxArticulationJointReducedCoordinate, axis: PxArticulationAxis.Enum) -> PxReal { return this.pxarticulationjointreducedcoordinate_vtable.getJointVelocity(this, axis); }

    vtable :: (obj: *PxArticulationJointReducedCoordinate) -> *PxArticulationJointReducedCoordinate_VTable { return obj.pxarticulationjointreducedcoordinate_vtable; }


    /*
    \brief Flags which affect the behavior of PxShapes.
    
    \see PxShape PxShape.setFlag()
    */
    PxShapeFlag :: struct {
        Enum :: enum s32 {
            SIMULATION_SHAPE  :: 1;

            SCENE_QUERY_SHAPE :: 2;

            TRIGGER_SHAPE     :: 4;

            VISUALIZATION     :: 8;

            eSIMULATION_SHAPE  :: SIMULATION_SHAPE;

            eSCENE_QUERY_SHAPE :: SCENE_QUERY_SHAPE;

            eTRIGGER_SHAPE     :: TRIGGER_SHAPE;

            eVISUALIZATION     :: VISUALIZATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxShapeFlag.
    
    \see PxShapeFlag
    */
    PxShapeFlags :: PxFlags(PxShapeFlag.Enum, PxU8);
    operator| :: (a: PxShapeFlag.Enum, b: PxShapeFlag.Enum) -> PxFlags(PxShapeFlag.Enum, PxU8) #foreign physxcharacterkinematic_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxShapeFlag@physx@@E@0@W4Enum@PxShapeFlag@0@0@Z";
    operator~ :: (a: PxShapeFlag.Enum) -> PxFlags(PxShapeFlag.Enum, PxU8) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxShapeFlag@physx@@E@0@W4Enum@PxShapeFlag@0@@Z";

    /*
    \brief Abstract class for collision shapes.
    
    Shapes are shared, reference counted objects.
    
    An instance can be created by calling the createShape() method of the PxRigidActor class, or
    the createShape() method of the PxPhysics class.
    
    <h3>Visualizations</h3>
    \li PxVisualizationParameter::eCOLLISION_AABBS
    \li PxVisualizationParameter::eCOLLISION_SHAPES
    \li PxVisualizationParameter::eCOLLISION_AXES
    
    \see PxPhysics.createShape() PxRigidActor.createShape() PxBoxGeometry PxSphereGeometry PxCapsuleGeometry PxPlaneGeometry PxConvexMeshGeometry
    PxTriangleMeshGeometry PxHeightFieldGeometry
    */
    PxShape :: struct {
        #as using pxrefcounted: PxRefCounted;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxShape, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxShape@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxShape, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxShape@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrefcounted; pxshape_vtable: *PxShape_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxShape) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxShape@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxShape, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxShape@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxShape, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxShape@physx@@MEBA_NPEBD@Z";
    }
    PxShape_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        setGeometry: (this: *PxShape, geometry: *PxGeometry) -> void #cpp_method;

        getGeometry: (this: *PxShape) -> *PxGeometry #cpp_method;

        getActor: (this: *PxShape) -> *PxRigidActor #cpp_method;

        setLocalPose: (this: *PxShape, pose: *PxTransform) -> void #cpp_method;

        getLocalPose: (this: *PxShape) -> PxTransform #cpp_method;

        setSimulationFilterData: (this: *PxShape, data: *PxFilterData) -> void #cpp_method;

        getSimulationFilterData: (this: *PxShape) -> PxFilterData #cpp_method #cpp_return_type_is_non_pod;

        setQueryFilterData: (this: *PxShape, data: *PxFilterData) -> void #cpp_method;

        getQueryFilterData: (this: *PxShape) -> PxFilterData #cpp_method #cpp_return_type_is_non_pod;

        setMaterials: (this: *PxShape, materials: **PxMaterial, materialCount: PxU16) -> void #cpp_method;

        setSoftBodyMaterials: (this: *PxShape, materials: **PxFEMSoftBodyMaterial, materialCount: PxU16) -> void #cpp_method;

        setClothMaterials: (this: *PxShape, materials: **PxFEMClothMaterial, materialCount: PxU16) -> void #cpp_method;

        getNbMaterials: (this: *PxShape) -> PxU16 #cpp_method;

        getMaterials: (this: *PxShape, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getSoftBodyMaterials: (this: *PxShape, userBuffer: **PxFEMSoftBodyMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getClothMaterials: (this: *PxShape, userBuffer: **PxFEMClothMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getMaterialFromInternalFaceIndex: (this: *PxShape, faceIndex: PxU32) -> *PxBaseMaterial #cpp_method;

        setContactOffset: (this: *PxShape, contactOffset: PxReal) -> void #cpp_method;

        getContactOffset: (this: *PxShape) -> PxReal #cpp_method;

        setRestOffset: (this: *PxShape, restOffset: PxReal) -> void #cpp_method;

        getRestOffset: (this: *PxShape) -> PxReal #cpp_method;

        setDensityForFluid: (this: *PxShape, densityForFluid: PxReal) -> void #cpp_method;

        getDensityForFluid: (this: *PxShape) -> PxReal #cpp_method;

        setTorsionalPatchRadius: (this: *PxShape, radius: PxReal) -> void #cpp_method;

        getTorsionalPatchRadius: (this: *PxShape) -> PxReal #cpp_method;

        setMinTorsionalPatchRadius: (this: *PxShape, radius: PxReal) -> void #cpp_method;

        getMinTorsionalPatchRadius: (this: *PxShape) -> PxReal #cpp_method;

        getInternalShapeIndex: (this: *PxShape) -> PxU32 #cpp_method;

        getGPUIndex: (this: *PxShape) -> PxShapeGPUIndex #cpp_method;

        setFlag: (this: *PxShape, flag: PxShapeFlag.Enum, value: bool) -> void #cpp_method;

        setFlags: (this: *PxShape, inFlags: PxShapeFlags) -> void #cpp_method;

        getFlags: (this: *PxShape) -> PxShapeFlags #cpp_method;

        isExclusive: (this: *PxShape) -> bool #cpp_method;

        setName: (this: *PxShape, name: *u8) -> void #cpp_method;

        getName: (this: *PxShape) -> *u8 #cpp_method;
    }

    PxShape_setGeometry :: inline (this: *PxShape, geometry: *PxGeometry) { this.pxshape_vtable.setGeometry(this, geometry); }

    PxShape_getGeometry :: inline (this: *PxShape) -> *PxGeometry { return this.pxshape_vtable.getGeometry(this); }

    PxShape_getActor :: inline (this: *PxShape) -> *PxRigidActor { return this.pxshape_vtable.getActor(this); }

    PxShape_setLocalPose :: inline (this: *PxShape, pose: *PxTransform) { this.pxshape_vtable.setLocalPose(this, pose); }

    PxShape_getLocalPose :: inline (this: *PxShape) -> PxTransform { return this.pxshape_vtable.getLocalPose(this); }

    PxShape_setSimulationFilterData :: inline (this: *PxShape, data: *PxFilterData) { this.pxshape_vtable.setSimulationFilterData(this, data); }

    PxShape_getSimulationFilterData :: inline (this: *PxShape) -> PxFilterData { return this.pxshape_vtable.getSimulationFilterData(this); }

    PxShape_setQueryFilterData :: inline (this: *PxShape, data: *PxFilterData) { this.pxshape_vtable.setQueryFilterData(this, data); }

    PxShape_getQueryFilterData :: inline (this: *PxShape) -> PxFilterData { return this.pxshape_vtable.getQueryFilterData(this); }

    PxShape_setMaterials :: inline (this: *PxShape, materials: **PxMaterial, materialCount: PxU16) { this.pxshape_vtable.setMaterials(this, materials, materialCount); }

    PxShape_setSoftBodyMaterials :: inline (this: *PxShape, materials: **PxFEMSoftBodyMaterial, materialCount: PxU16) { this.pxshape_vtable.setSoftBodyMaterials(this, materials, materialCount); }

    PxShape_setClothMaterials :: inline (this: *PxShape, materials: **PxFEMClothMaterial, materialCount: PxU16) { this.pxshape_vtable.setClothMaterials(this, materials, materialCount); }

    PxShape_getNbMaterials :: inline (this: *PxShape) -> PxU16 { return this.pxshape_vtable.getNbMaterials(this); }

    PxShape_getMaterials :: inline (this: *PxShape, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxshape_vtable.getMaterials(this, userBuffer, bufferSize, startIndex); }

    PxShape_getSoftBodyMaterials :: inline (this: *PxShape, userBuffer: **PxFEMSoftBodyMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxshape_vtable.getSoftBodyMaterials(this, userBuffer, bufferSize, startIndex); }

    PxShape_getClothMaterials :: inline (this: *PxShape, userBuffer: **PxFEMClothMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxshape_vtable.getClothMaterials(this, userBuffer, bufferSize, startIndex); }

    PxShape_getMaterialFromInternalFaceIndex :: inline (this: *PxShape, faceIndex: PxU32) -> *PxBaseMaterial { return this.pxshape_vtable.getMaterialFromInternalFaceIndex(this, faceIndex); }

    PxShape_setContactOffset :: inline (this: *PxShape, contactOffset: PxReal) { this.pxshape_vtable.setContactOffset(this, contactOffset); }

    PxShape_getContactOffset :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getContactOffset(this); }

    PxShape_setRestOffset :: inline (this: *PxShape, restOffset: PxReal) { this.pxshape_vtable.setRestOffset(this, restOffset); }

    PxShape_getRestOffset :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getRestOffset(this); }

    PxShape_setDensityForFluid :: inline (this: *PxShape, densityForFluid: PxReal) { this.pxshape_vtable.setDensityForFluid(this, densityForFluid); }

    PxShape_getDensityForFluid :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getDensityForFluid(this); }

    PxShape_setTorsionalPatchRadius :: inline (this: *PxShape, radius: PxReal) { this.pxshape_vtable.setTorsionalPatchRadius(this, radius); }

    PxShape_getTorsionalPatchRadius :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getTorsionalPatchRadius(this); }

    PxShape_setMinTorsionalPatchRadius :: inline (this: *PxShape, radius: PxReal) { this.pxshape_vtable.setMinTorsionalPatchRadius(this, radius); }

    PxShape_getMinTorsionalPatchRadius :: inline (this: *PxShape) -> PxReal { return this.pxshape_vtable.getMinTorsionalPatchRadius(this); }

    PxShape_getInternalShapeIndex :: inline (this: *PxShape) -> PxU32 { return this.pxshape_vtable.getInternalShapeIndex(this); }

    PxShape_getGPUIndex :: inline (this: *PxShape) -> PxShapeGPUIndex { return this.pxshape_vtable.getGPUIndex(this); }

    PxShape_setFlag :: inline (this: *PxShape, flag: PxShapeFlag.Enum, value: bool) { this.pxshape_vtable.setFlag(this, flag, value); }

    PxShape_setFlags :: inline (this: *PxShape, inFlags: PxShapeFlags) { this.pxshape_vtable.setFlags(this, inFlags); }

    PxShape_getFlags :: inline (this: *PxShape) -> PxShapeFlags { return this.pxshape_vtable.getFlags(this); }

    PxShape_isExclusive :: inline (this: *PxShape) -> bool { return this.pxshape_vtable.isExclusive(this); }

    PxShape_setName :: inline (this: *PxShape, name: *u8) { this.pxshape_vtable.setName(this, name); }

    PxShape_getName :: inline (this: *PxShape) -> *u8 { return this.pxshape_vtable.getName(this); }

    vtable :: (obj: *PxShape) -> *PxShape_VTable { return obj.pxshape_vtable; }


    /*
    \brief PxRigidActor represents a base class shared between dynamic and static rigid bodies in the physics SDK.
    
    PxRigidActor objects specify the geometry of the object by defining a set of attached shapes (see #PxShape).
    
    \see PxActor
    */
    PxRigidActor :: struct {
        #as using pxactor: PxActor;

        Constructor :: (this: *PxRigidActor, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidActor@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxRigidActor, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidActor@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxactor; pxrigidactor_vtable: *PxRigidActor_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxRigidActor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxRigidActor@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxRigidActor, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxRigidActor@physx@@MEBA_NPEBD@Z";
    }
    PxRigidActor_VTable :: struct #type_info_none {
        using pxactor: PxActor_VTable;
        getInternalActorIndex: (this: *PxRigidActor) -> PxU32 #cpp_method;

        getGlobalPose: (this: *PxRigidActor) -> PxTransform #cpp_method;

        setGlobalPose: (this: *PxRigidActor, pose: *PxTransform, autowake := true) -> void #cpp_method;

        attachShape: (this: *PxRigidActor, shape: *PxShape) -> bool #cpp_method;

        detachShape: (this: *PxRigidActor, shape: *PxShape, wakeOnLostTouch := true) -> void #cpp_method;

        getNbShapes: (this: *PxRigidActor) -> PxU32 #cpp_method;

        getShapes: (this: *PxRigidActor, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbConstraints: (this: *PxRigidActor) -> PxU32 #cpp_method;

        getConstraints: (this: *PxRigidActor, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;
    }

    PxRigidActor_getInternalActorIndex :: inline (this: *PxRigidActor) -> PxU32 { return this.pxrigidactor_vtable.getInternalActorIndex(this); }

    PxRigidActor_getGlobalPose :: inline (this: *PxRigidActor) -> PxTransform { return this.pxrigidactor_vtable.getGlobalPose(this); }

    PxRigidActor_setGlobalPose :: inline (this: *PxRigidActor, pose: *PxTransform, autowake := true) { this.pxrigidactor_vtable.setGlobalPose(this, pose, autowake); }

    PxRigidActor_attachShape :: inline (this: *PxRigidActor, shape: *PxShape) -> bool { return this.pxrigidactor_vtable.attachShape(this, shape); }

    PxRigidActor_detachShape :: inline (this: *PxRigidActor, shape: *PxShape, wakeOnLostTouch := true) { this.pxrigidactor_vtable.detachShape(this, shape, wakeOnLostTouch); }

    PxRigidActor_getNbShapes :: inline (this: *PxRigidActor) -> PxU32 { return this.pxrigidactor_vtable.getNbShapes(this); }

    PxRigidActor_getShapes :: inline (this: *PxRigidActor, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxrigidactor_vtable.getShapes(this, userBuffer, bufferSize, startIndex); }

    PxRigidActor_getNbConstraints :: inline (this: *PxRigidActor) -> PxU32 { return this.pxrigidactor_vtable.getNbConstraints(this); }

    PxRigidActor_getConstraints :: inline (this: *PxRigidActor, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxrigidactor_vtable.getConstraints(this, userBuffer, bufferSize, startIndex); }

    vtable :: (obj: *PxRigidActor) -> *PxRigidActor_VTable { return obj.pxrigidactor_vtable; }


    /*
    \brief Parameter to addForce() and addTorque() calls, determines the exact operation that is carried out.
    
    \see PxRigidBody.addForce() PxRigidBody.addTorque()
    */
    PxForceMode :: struct {
        Enum :: enum s32 {
            FORCE           :: 0;
            IMPULSE         :: 1;
            VELOCITY_CHANGE :: 2;
            ACCELERATION    :: 3;

            eFORCE           :: FORCE;
            eIMPULSE         :: IMPULSE;
            eVELOCITY_CHANGE :: VELOCITY_CHANGE;
            eACCELERATION    :: ACCELERATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief PxNodeIndex
    
    Node index is the unique index for each actor referenced by the island gen. It contains details like
    if the actor is an articulation or rigid body. If it is an articulation, the node index also contains
    the link index of the rigid body within the articulation. Also, it contains information to detect whether
    the rigid body is static body or not
    */
    PxNodeIndex :: struct {
        ind: PxU64;

        Constructor :: (this: *PxNodeIndex, id: PxU32 = 4294967295) -> void #cpp_method #foreign physx_static "??0PxNodeIndex@physx@@QEAA@I@Z";

        index :: (this: *PxNodeIndex) -> PxU32 #cpp_method #foreign physx_static "?index@PxNodeIndex@physx@@QEBAIXZ";
        articulationLinkId :: (this: *PxNodeIndex) -> PxU32 #cpp_method #foreign physx_static "?articulationLinkId@PxNodeIndex@physx@@QEBAIXZ";

        isStaticBody :: (this: *PxNodeIndex) -> bool #cpp_method #foreign physx_static "?isStaticBody@PxNodeIndex@physx@@QEBA_NXZ";

        isValid :: (this: *PxNodeIndex) -> bool #cpp_method #foreign physx_static "?isValid@PxNodeIndex@physx@@QEBA_NXZ";

        setIndices :: (this: *PxNodeIndex, index: PxU32, articLinkId: PxU32) -> void #cpp_method #foreign physx_static "?setIndices@PxNodeIndex@physx@@QEAAXII@Z";

        setIndices :: (this: *PxNodeIndex, index: PxU32) -> void #cpp_method #foreign physx_static "?setIndices@PxNodeIndex@physx@@QEAAXI@Z";

        getInd :: (this: *PxNodeIndex) -> PxU64 #cpp_method #foreign physx_static "?getInd@PxNodeIndex@physx@@QEBA_KXZ";
    }

    operator< :: (this: *physx.PxNodeIndex, other: *physx.PxNodeIndex) -> bool #cpp_method #foreign physx_static "??MPxNodeIndex@physx@@QEBA_NAEBV01@@Z";
    operator< :: (this: physx.PxNodeIndex, other: physx.PxNodeIndex) -> bool #no_context {
        return operator<(*this, *other);
    }

    operator== :: (this: *physx.PxNodeIndex, other: *physx.PxNodeIndex) -> bool #cpp_method #foreign physx_static "??8PxNodeIndex@physx@@QEBA_NAEBV01@@Z";
    operator== :: (this: physx.PxNodeIndex, other: physx.PxNodeIndex) -> bool #no_context {
        return operator==(*this, *other);
    }

    /*
    \brief Collection of flags describing the behavior of a rigid body.
    
    \see PxRigidBody.setRigidBodyFlag(), PxRigidBody.getRigidBodyFlags()
    */
    PxRigidBodyFlag :: struct {
        Enum :: enum s32 {
            KINEMATIC                              :: 1;

            USE_KINEMATIC_TARGET_FOR_SCENE_QUERIES :: 2;

            ENABLE_CCD                             :: 4;

            ENABLE_CCD_FRICTION                    :: 8;

            ENABLE_SPECULATIVE_CCD                 :: 16;

            ENABLE_POSE_INTEGRATION_PREVIEW        :: 32;

            ENABLE_CCD_MAX_CONTACT_IMPULSE         :: 64;

            RETAIN_ACCELERATIONS                   :: 128;

            FORCE_KINE_KINE_NOTIFICATIONS          :: 256;

            FORCE_STATIC_KINE_NOTIFICATIONS        :: 512;

            ENABLE_GYROSCOPIC_FORCES               :: 1024;

            RESERVED                               :: 32768;

            eKINEMATIC                              :: KINEMATIC;

            eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES :: USE_KINEMATIC_TARGET_FOR_SCENE_QUERIES;

            eENABLE_CCD                             :: ENABLE_CCD;

            eENABLE_CCD_FRICTION                    :: ENABLE_CCD_FRICTION;

            eENABLE_SPECULATIVE_CCD                 :: ENABLE_SPECULATIVE_CCD;

            eENABLE_POSE_INTEGRATION_PREVIEW        :: ENABLE_POSE_INTEGRATION_PREVIEW;

            eENABLE_CCD_MAX_CONTACT_IMPULSE         :: ENABLE_CCD_MAX_CONTACT_IMPULSE;

            eRETAIN_ACCELERATIONS                   :: RETAIN_ACCELERATIONS;

            eFORCE_KINE_KINE_NOTIFICATIONS          :: FORCE_KINE_KINE_NOTIFICATIONS;

            eFORCE_STATIC_KINE_NOTIFICATIONS        :: FORCE_STATIC_KINE_NOTIFICATIONS;

            eENABLE_GYROSCOPIC_FORCES               :: ENABLE_GYROSCOPIC_FORCES;

            eRESERVED                               :: RESERVED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxRigidBodyFlag.
    
    \see PxRigidBodyFlag
    */
    PxRigidBodyFlags :: PxFlags(PxRigidBodyFlag.Enum, PxU16);
    operator| :: (a: PxRigidBodyFlag.Enum, b: PxRigidBodyFlag.Enum) -> PxFlags(PxRigidBodyFlag.Enum, PxU16) #foreign physx_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxRigidBodyFlag@physx@@G@0@W4Enum@PxRigidBodyFlag@0@0@Z";
    operator~ :: (a: PxRigidBodyFlag.Enum) -> PxFlags(PxRigidBodyFlag.Enum, PxU16) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxRigidBodyFlag@physx@@G@0@W4Enum@PxRigidBodyFlag@0@@Z";

    /*
    \brief PxRigidBody is a base class shared between dynamic rigid body objects.
    
    \see PxRigidActor
    */
    PxRigidBody :: struct {
        #as using pxrigidactor: PxRigidActor;

        Constructor :: (this: *PxRigidBody, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidBody@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxRigidBody, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidBody@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrigidactor; pxrigidbody_vtable: *PxRigidBody_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxRigidBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxRigidBody@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxRigidBody, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxRigidBody@physx@@MEBA_NPEBD@Z";
    }
    PxRigidBody_VTable :: struct #type_info_none {
        using pxrigidactor: PxRigidActor_VTable;
        setCMassLocalPose: (this: *PxRigidBody, pose: *PxTransform) -> void #cpp_method;

        getCMassLocalPose: (this: *PxRigidBody) -> PxTransform #cpp_method;

        setMass: (this: *PxRigidBody, mass: PxReal) -> void #cpp_method;

        getMass: (this: *PxRigidBody) -> PxReal #cpp_method;

        getInvMass: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMassSpaceInertiaTensor: (this: *PxRigidBody, m: *PxVec3) -> void #cpp_method;

        getMassSpaceInertiaTensor: (this: *PxRigidBody) -> PxVec3 #cpp_method;

        getMassSpaceInvInertiaTensor: (this: *PxRigidBody) -> PxVec3 #cpp_method;

        setLinearDamping: (this: *PxRigidBody, linDamp: PxReal) -> void #cpp_method;

        getLinearDamping: (this: *PxRigidBody) -> PxReal #cpp_method;

        setAngularDamping: (this: *PxRigidBody, angDamp: PxReal) -> void #cpp_method;

        getAngularDamping: (this: *PxRigidBody) -> PxReal #cpp_method;

        getLinearVelocity: (this: *PxRigidBody) -> PxVec3 #cpp_method;

        getAngularVelocity: (this: *PxRigidBody) -> PxVec3 #cpp_method;

        setMaxLinearVelocity: (this: *PxRigidBody, maxLinVel: PxReal) -> void #cpp_method;

        getMaxLinearVelocity: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMaxAngularVelocity: (this: *PxRigidBody, maxAngVel: PxReal) -> void #cpp_method;

        getMaxAngularVelocity: (this: *PxRigidBody) -> PxReal #cpp_method;

        getLinearAcceleration: (this: *PxRigidBody) -> PxVec3 #cpp_method;

        getAngularAcceleration: (this: *PxRigidBody) -> PxVec3 #cpp_method;

        addForce: (this: *PxRigidBody, force: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) -> void #cpp_method;

        addTorque: (this: *PxRigidBody, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) -> void #cpp_method;

        clearForce: (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) -> void #cpp_method;

        clearTorque: (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) -> void #cpp_method;

        setForceAndTorque: (this: *PxRigidBody, force: *PxVec3, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE) -> void #cpp_method;

        setRigidBodyFlag: (this: *PxRigidBody, flag: PxRigidBodyFlag.Enum, value: bool) -> void #cpp_method;
        setRigidBodyFlags: (this: *PxRigidBody, inFlags: PxRigidBodyFlags) -> void #cpp_method;

        getRigidBodyFlags: (this: *PxRigidBody) -> PxRigidBodyFlags #cpp_method;

        setMinCCDAdvanceCoefficient: (this: *PxRigidBody, advanceCoefficient: PxReal) -> void #cpp_method;

        getMinCCDAdvanceCoefficient: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMaxDepenetrationVelocity: (this: *PxRigidBody, biasClamp: PxReal) -> void #cpp_method;

        getMaxDepenetrationVelocity: (this: *PxRigidBody) -> PxReal #cpp_method;

        setMaxContactImpulse: (this: *PxRigidBody, maxImpulse: PxReal) -> void #cpp_method;

        getMaxContactImpulse: (this: *PxRigidBody) -> PxReal #cpp_method;

        setContactSlopCoefficient: (this: *PxRigidBody, slopCoefficient: PxReal) -> void #cpp_method;

        getContactSlopCoefficient: (this: *PxRigidBody) -> PxReal #cpp_method;

        getInternalIslandNodeIndex: (this: *PxRigidBody) -> PxNodeIndex #cpp_method #cpp_return_type_is_non_pod;
    }

    PxRigidBody_setCMassLocalPose :: inline (this: *PxRigidBody, pose: *PxTransform) { this.pxrigidbody_vtable.setCMassLocalPose(this, pose); }

    PxRigidBody_getCMassLocalPose :: inline (this: *PxRigidBody) -> PxTransform { return this.pxrigidbody_vtable.getCMassLocalPose(this); }

    PxRigidBody_setMass :: inline (this: *PxRigidBody, mass: PxReal) { this.pxrigidbody_vtable.setMass(this, mass); }

    PxRigidBody_getMass :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMass(this); }

    PxRigidBody_getInvMass :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getInvMass(this); }

    PxRigidBody_setMassSpaceInertiaTensor :: inline (this: *PxRigidBody, m: *PxVec3) { this.pxrigidbody_vtable.setMassSpaceInertiaTensor(this, m); }

    PxRigidBody_getMassSpaceInertiaTensor :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getMassSpaceInertiaTensor(this); }

    PxRigidBody_getMassSpaceInvInertiaTensor :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getMassSpaceInvInertiaTensor(this); }

    PxRigidBody_setLinearDamping :: inline (this: *PxRigidBody, linDamp: PxReal) { this.pxrigidbody_vtable.setLinearDamping(this, linDamp); }

    PxRigidBody_getLinearDamping :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getLinearDamping(this); }

    PxRigidBody_setAngularDamping :: inline (this: *PxRigidBody, angDamp: PxReal) { this.pxrigidbody_vtable.setAngularDamping(this, angDamp); }

    PxRigidBody_getAngularDamping :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getAngularDamping(this); }

    PxRigidBody_getLinearVelocity :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getLinearVelocity(this); }

    PxRigidBody_getAngularVelocity :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getAngularVelocity(this); }

    PxRigidBody_setMaxLinearVelocity :: inline (this: *PxRigidBody, maxLinVel: PxReal) { this.pxrigidbody_vtable.setMaxLinearVelocity(this, maxLinVel); }

    PxRigidBody_getMaxLinearVelocity :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxLinearVelocity(this); }

    PxRigidBody_setMaxAngularVelocity :: inline (this: *PxRigidBody, maxAngVel: PxReal) { this.pxrigidbody_vtable.setMaxAngularVelocity(this, maxAngVel); }

    PxRigidBody_getMaxAngularVelocity :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxAngularVelocity(this); }

    PxRigidBody_getLinearAcceleration :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getLinearAcceleration(this); }

    PxRigidBody_getAngularAcceleration :: inline (this: *PxRigidBody) -> PxVec3 { return this.pxrigidbody_vtable.getAngularAcceleration(this); }

    PxRigidBody_addForce :: inline (this: *PxRigidBody, force: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) { this.pxrigidbody_vtable.addForce(this, force, mode, autowake); }

    PxRigidBody_addTorque :: inline (this: *PxRigidBody, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE, autowake := true) { this.pxrigidbody_vtable.addTorque(this, torque, mode, autowake); }

    PxRigidBody_clearForce :: inline (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) { this.pxrigidbody_vtable.clearForce(this, mode); }

    PxRigidBody_clearTorque :: inline (this: *PxRigidBody, mode: PxForceMode.Enum = .FORCE) { this.pxrigidbody_vtable.clearTorque(this, mode); }

    PxRigidBody_setForceAndTorque :: inline (this: *PxRigidBody, force: *PxVec3, torque: *PxVec3, mode: PxForceMode.Enum = .FORCE) { this.pxrigidbody_vtable.setForceAndTorque(this, force, torque, mode); }

    PxRigidBody_setRigidBodyFlag :: inline (this: *PxRigidBody, flag: PxRigidBodyFlag.Enum, value: bool) { this.pxrigidbody_vtable.setRigidBodyFlag(this, flag, value); }
    PxRigidBody_setRigidBodyFlags :: inline (this: *PxRigidBody, inFlags: PxRigidBodyFlags) { this.pxrigidbody_vtable.setRigidBodyFlags(this, inFlags); }

    PxRigidBody_getRigidBodyFlags :: inline (this: *PxRigidBody) -> PxRigidBodyFlags { return this.pxrigidbody_vtable.getRigidBodyFlags(this); }

    PxRigidBody_setMinCCDAdvanceCoefficient :: inline (this: *PxRigidBody, advanceCoefficient: PxReal) { this.pxrigidbody_vtable.setMinCCDAdvanceCoefficient(this, advanceCoefficient); }

    PxRigidBody_getMinCCDAdvanceCoefficient :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMinCCDAdvanceCoefficient(this); }

    PxRigidBody_setMaxDepenetrationVelocity :: inline (this: *PxRigidBody, biasClamp: PxReal) { this.pxrigidbody_vtable.setMaxDepenetrationVelocity(this, biasClamp); }

    PxRigidBody_getMaxDepenetrationVelocity :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxDepenetrationVelocity(this); }

    PxRigidBody_setMaxContactImpulse :: inline (this: *PxRigidBody, maxImpulse: PxReal) { this.pxrigidbody_vtable.setMaxContactImpulse(this, maxImpulse); }

    PxRigidBody_getMaxContactImpulse :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getMaxContactImpulse(this); }

    PxRigidBody_setContactSlopCoefficient :: inline (this: *PxRigidBody, slopCoefficient: PxReal) { this.pxrigidbody_vtable.setContactSlopCoefficient(this, slopCoefficient); }

    PxRigidBody_getContactSlopCoefficient :: inline (this: *PxRigidBody) -> PxReal { return this.pxrigidbody_vtable.getContactSlopCoefficient(this); }

    PxRigidBody_getInternalIslandNodeIndex :: inline (this: *PxRigidBody) -> PxNodeIndex { return this.pxrigidbody_vtable.getInternalIslandNodeIndex(this); }

    vtable :: (obj: *PxRigidBody) -> *PxRigidBody_VTable { return obj.pxrigidbody_vtable; }


    /*
    \brief A component of an articulation that represents a rigid body.
    
    Articulation links have a restricted subset of the functionality of a PxRigidDynamic:
    - They may not be kinematic, and do not support contact-force thresholds.
    - Their velocity or global pose cannot be set directly, but must be set via the articulation-root and joint positions/velocities.
    - Sleep state and solver iteration counts are properties of the entire articulation rather than the individual links.
    
    \see PxArticulationReducedCoordinate, PxArticulationReducedCoordinate::createLink, PxArticulationJointReducedCoordinate, PxRigidBody
    */
    PxArticulationLink :: struct {
        #as using pxrigidbody: PxRigidBody;

        Constructor :: (this: *PxArticulationLink, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationLink@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxArticulationLink, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxArticulationLink@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrigidbody; pxarticulationlink_vtable: *PxArticulationLink_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /*
        \brief Returns the string name of the dynamic type.
        
        \return The string name.
        */
        virtual_getConcreteTypeName :: (this: *PxArticulationLink) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxArticulationLink@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxArticulationLink, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxArticulationLink@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxArticulationLink, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxArticulationLink@physx@@MEBA_NPEBD@Z";
    }
    PxArticulationLink_VTable :: struct #type_info_none {
        using pxrigidbody: PxRigidBody_VTable;
        getArticulation: (this: *PxArticulationLink) -> *PxArticulationReducedCoordinate #cpp_method;

        getInboundJoint: (this: *PxArticulationLink) -> *PxArticulationJointReducedCoordinate #cpp_method;

        getInboundJointDof: (this: *PxArticulationLink) -> PxU32 #cpp_method;

        getNbChildren: (this: *PxArticulationLink) -> PxU32 #cpp_method;

        getLinkIndex: (this: *PxArticulationLink) -> PxU32 #cpp_method;

        getChildren: (this: *PxArticulationLink, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        setCfmScale: (this: *PxArticulationLink, cfm: PxReal) -> void #cpp_method;

        getCfmScale: (this: *PxArticulationLink) -> PxReal #cpp_method;
    }

    PxArticulationLink_getArticulation :: inline (this: *PxArticulationLink) -> *PxArticulationReducedCoordinate { return this.pxarticulationlink_vtable.getArticulation(this); }

    PxArticulationLink_getInboundJoint :: inline (this: *PxArticulationLink) -> *PxArticulationJointReducedCoordinate { return this.pxarticulationlink_vtable.getInboundJoint(this); }

    PxArticulationLink_getInboundJointDof :: inline (this: *PxArticulationLink) -> PxU32 { return this.pxarticulationlink_vtable.getInboundJointDof(this); }

    PxArticulationLink_getNbChildren :: inline (this: *PxArticulationLink) -> PxU32 { return this.pxarticulationlink_vtable.getNbChildren(this); }

    PxArticulationLink_getLinkIndex :: inline (this: *PxArticulationLink) -> PxU32 { return this.pxarticulationlink_vtable.getLinkIndex(this); }

    PxArticulationLink_getChildren :: inline (this: *PxArticulationLink, userBuffer: **PxArticulationLink, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxarticulationlink_vtable.getChildren(this, userBuffer, bufferSize, startIndex); }

    PxArticulationLink_setCfmScale :: inline (this: *PxArticulationLink, cfm: PxReal) { this.pxarticulationlink_vtable.setCfmScale(this, cfm); }

    PxArticulationLink_getCfmScale :: inline (this: *PxArticulationLink) -> PxReal { return this.pxarticulationlink_vtable.getCfmScale(this); }

    vtable :: (obj: *PxArticulationLink) -> *PxArticulationLink_VTable { return obj.pxarticulationlink_vtable; }


    /*
    \brief A constraint descriptor for limiting movement to a conical region.
    */
    PxConeLimitedConstraint :: struct {
        mAxis:      PxVec3; //!< Axis of the cone in actor space
        mAngle:     PxReal; //!< Opening angle in radians, negative indicates unlimited
        mLowLimit:  PxReal; //!< Minimum distance, negative indicates unlimited
        mHighLimit: PxReal; //!< Maximum distance, negative indicates unlimited
    }

    /*
    \brief Compressed form of cone limit parameters
    \see PxConeLimitedConstraint
    */
    PxConeLimitParams :: struct {
        lowHighLimits: PxVec4; // [lowLimit, highLimit, unused, unused]
        axisAngle:     PxVec4; // [axis.x, axis.y, axis.z, angle]
    }

    /*
    \brief constraint flags
    
    \note eBROKEN is a read only flag
    */
    PxConstraintFlag :: struct {
        Enum :: enum s32 {
            BROKEN                  :: 1;
            COLLISION_ENABLED       :: 8;
            VISUALIZATION           :: 16;
            DRIVE_LIMITS_ARE_FORCES :: 32;
            IMPROVED_SLERP          :: 128;
            DISABLE_PREPROCESSING   :: 256;
            ENABLE_EXTENDED_LIMITS  :: 512;
            GPU_COMPATIBLE          :: 1024;
            ALWAYS_UPDATE           :: 2048;
            DISABLE_CONSTRAINT      :: 4096;

            eBROKEN                  :: BROKEN;
            eCOLLISION_ENABLED       :: COLLISION_ENABLED;
            eVISUALIZATION           :: VISUALIZATION;
            eDRIVE_LIMITS_ARE_FORCES :: DRIVE_LIMITS_ARE_FORCES;
            eIMPROVED_SLERP          :: IMPROVED_SLERP;
            eDISABLE_PREPROCESSING   :: DISABLE_PREPROCESSING;
            eENABLE_EXTENDED_LIMITS  :: ENABLE_EXTENDED_LIMITS;
            eGPU_COMPATIBLE          :: GPU_COMPATIBLE;
            eALWAYS_UPDATE           :: ALWAYS_UPDATE;
            eDISABLE_CONSTRAINT      :: DISABLE_CONSTRAINT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief constraint flags
    \see PxConstraintFlag
    */
    PxConstraintFlags :: PxFlags(PxConstraintFlag.Enum, PxU16);
    operator~ :: (a: PxConstraintFlag.Enum) -> PxFlags(PxConstraintFlag.Enum, PxU16) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxConstraintFlag@physx@@G@0@W4Enum@PxConstraintFlag@0@@Z";

    /*
    \brief a table of function pointers for a constraint
    
    \see PxConstraint
    */
    PxConstraintShaderTable :: struct {
        solverPrep: PxConstraintSolverPrep; //!< solver constraint generation function
        visualize:  PxConstraintVisualize; //!< constraint visualization function
        flag:       PxConstraintFlag.Enum; //!< constraint flags
    }

    /*
    \brief A plugin class for implementing constraints
    
    \see PxPhysics.createConstraint
    */
    PxConstraint :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxConstraint, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxConstraint@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxConstraint, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxConstraint@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxconstraint_vtable: *PxConstraint_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxConstraint) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxConstraint@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxConstraint, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxConstraint@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxConstraint, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxConstraint@physx@@MEBA_NPEBD@Z";
    }
    PxConstraint_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getScene: (this: *PxConstraint) -> *PxScene #cpp_method;

        getActors: (this: *PxConstraint, actor0: **PxRigidActor, actor1: **PxRigidActor) -> void #cpp_method;

        setActors: (this: *PxConstraint, actor0: *PxRigidActor, actor1: *PxRigidActor) -> void #cpp_method;

        markDirty: (this: *PxConstraint) -> void #cpp_method;

        getFlags: (this: *PxConstraint) -> PxConstraintFlags #cpp_method;

        setFlags: (this: *PxConstraint, flags: PxConstraintFlags) -> void #cpp_method;

        setFlag: (this: *PxConstraint, flag: PxConstraintFlag.Enum, value: bool) -> void #cpp_method;

        getForce: (this: *PxConstraint, linear: *PxVec3, angular: *PxVec3) -> void #cpp_method;

        isValid: (this: *PxConstraint) -> bool #cpp_method;

        setBreakForce: (this: *PxConstraint, linear: PxReal, angular: PxReal) -> void #cpp_method;

        getBreakForce: (this: *PxConstraint, linear: *PxReal, angular: *PxReal) -> void #cpp_method;

        setMinResponseThreshold: (this: *PxConstraint, threshold: PxReal) -> void #cpp_method;

        getMinResponseThreshold: (this: *PxConstraint) -> PxReal #cpp_method;

        getExternalReference: (this: *PxConstraint, typeID: *PxU32) -> *void #cpp_method;

        setConstraintFunctions: (this: *PxConstraint, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable) -> void #cpp_method;

        getSolverResidual: (this: *PxConstraint) -> PxConstraintResidual #cpp_method #cpp_return_type_is_non_pod;
    }

    PxConstraint_getScene :: inline (this: *PxConstraint) -> *PxScene { return this.pxconstraint_vtable.getScene(this); }

    PxConstraint_getActors :: inline (this: *PxConstraint, actor0: **PxRigidActor, actor1: **PxRigidActor) { this.pxconstraint_vtable.getActors(this, actor0, actor1); }

    PxConstraint_setActors :: inline (this: *PxConstraint, actor0: *PxRigidActor, actor1: *PxRigidActor) { this.pxconstraint_vtable.setActors(this, actor0, actor1); }

    PxConstraint_markDirty :: inline (this: *PxConstraint) { this.pxconstraint_vtable.markDirty(this); }

    PxConstraint_getFlags :: inline (this: *PxConstraint) -> PxConstraintFlags { return this.pxconstraint_vtable.getFlags(this); }

    PxConstraint_setFlags :: inline (this: *PxConstraint, flags: PxConstraintFlags) { this.pxconstraint_vtable.setFlags(this, flags); }

    PxConstraint_setFlag :: inline (this: *PxConstraint, flag: PxConstraintFlag.Enum, value: bool) { this.pxconstraint_vtable.setFlag(this, flag, value); }

    PxConstraint_getForce :: inline (this: *PxConstraint, linear: *PxVec3, angular: *PxVec3) { this.pxconstraint_vtable.getForce(this, linear, angular); }

    PxConstraint_isValid :: inline (this: *PxConstraint) -> bool { return this.pxconstraint_vtable.isValid(this); }

    PxConstraint_setBreakForce :: inline (this: *PxConstraint, linear: PxReal, angular: PxReal) { this.pxconstraint_vtable.setBreakForce(this, linear, angular); }

    PxConstraint_getBreakForce :: inline (this: *PxConstraint, linear: *PxReal, angular: *PxReal) { this.pxconstraint_vtable.getBreakForce(this, linear, angular); }

    PxConstraint_setMinResponseThreshold :: inline (this: *PxConstraint, threshold: PxReal) { this.pxconstraint_vtable.setMinResponseThreshold(this, threshold); }

    PxConstraint_getMinResponseThreshold :: inline (this: *PxConstraint) -> PxReal { return this.pxconstraint_vtable.getMinResponseThreshold(this); }

    PxConstraint_getExternalReference :: inline (this: *PxConstraint, typeID: *PxU32) -> *void { return this.pxconstraint_vtable.getExternalReference(this, typeID); }

    PxConstraint_setConstraintFunctions :: inline (this: *PxConstraint, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable) { this.pxconstraint_vtable.setConstraintFunctions(this, connector, shaders); }

    PxConstraint_getSolverResidual :: inline (this: *PxConstraint) -> PxConstraintResidual { return this.pxconstraint_vtable.getSolverResidual(this); }

    vtable :: (obj: *PxConstraint) -> *PxConstraint_VTable { return obj.pxconstraint_vtable; }


    /*
    \brief Base material class.
    
    \see PxPhysics.createMaterial PxPhysics.createFEMClothMaterial PxPhysics.createFEMSoftBodyMaterial PxPhysics.createPBDMaterial
    */
    PxBaseMaterial :: struct {
        #as using pxrefcounted: PxRefCounted;

        Constructor :: (this: *PxBaseMaterial, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxBaseMaterial@physx@@QEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxBaseMaterial, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxBaseMaterial@physx@@QEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxBaseMaterial, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxBaseMaterial@physx@@UEAA@XZ";
        virtual_isKindOf :: (this: *PxBaseMaterial, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxBaseMaterial@physx@@UEBA_NPEBD@Z";
    }

    /*
    \brief Flags which control the behavior of a material.
    
    \see PxMaterial
    */
    PxMaterialFlag :: struct {
        Enum :: enum s32 {
            DISABLE_FRICTION              :: 1;

            DISABLE_STRONG_FRICTION       :: 2;

            IMPROVED_PATCH_FRICTION       :: 4;

            COMPLIANT_CONTACT             :: 8;

            COMPLIANT_ACCELERATION_SPRING :: 16;

            eDISABLE_FRICTION              :: DISABLE_FRICTION;

            eDISABLE_STRONG_FRICTION       :: DISABLE_STRONG_FRICTION;

            eIMPROVED_PATCH_FRICTION       :: IMPROVED_PATCH_FRICTION;

            eCOMPLIANT_CONTACT             :: COMPLIANT_CONTACT;

            eCOMPLIANT_ACCELERATION_SPRING :: COMPLIANT_ACCELERATION_SPRING;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxMaterialFlag.
    
    \see PxMaterialFlag
    */
    PxMaterialFlags :: PxFlags(PxMaterialFlag.Enum, PxU16);

    /*
    \brief Enumeration that determines the way in which two material properties will be combined to yield a friction or restitution coefficient for a collision.
    
    When two actors come in contact with each other, they each have materials with various coefficients, but we only need a single set of coefficients for the pair.
    
    Physics doesn't have any inherent combinations because the coefficients are determined empirically on a case by case
    basis. However, simulating this with a pairwise lookup table is often impractical.
    
    For this reason the following combine behaviors are available:
    
    eAVERAGE
    eMIN
    eMULTIPLY
    eMAX
    
    The effective combine mode for the pair is maximum(material0.combineMode, material1.combineMode).
    
    Notes that the restitution coefficient is overloaded if it is negative and represents a spring stiffness for compliant contacts. In the compliant contact case, the following rules apply:
    * If a compliant (restitution < 0) material interacts with a rigid (restitution >= 0) material, the compliant behavior will be chosen independent
    of combine mode. In all other cases (i.e., also for compliant-compliant interactions) the combine mode is used.
    * For a compliant-compliant interaction with eMULTIPLY combine mode, we multiply the values but keep the sign negative.
    * The material damping follows the same logic, i.e., for the compliant vs non-compliant case, we take the damping value of the compliant material. Otherwise the combine mode is respected.
    * In an interaction between a compliant-force and a compliant-acceleration body the latter will dominate and exclusively determine the collision behavior with its parameters.
    
    \see PxMaterial.setFrictionCombineMode() PxMaterial.getFrictionCombineMode() PxMaterial.setRestitutionCombineMode() PxMaterial.getFrictionCombineMode()
    */
    PxCombineMode :: struct {
        Enum :: enum s32 {
            AVERAGE  :: 0;
            MIN      :: 1;
            MULTIPLY :: 2;
            MAX      :: 3;
            N_VALUES :: 4;
            PAD_32   :: 2147483647;

            eAVERAGE  :: AVERAGE;
            eMIN      :: MIN;
            eMULTIPLY :: MULTIPLY;
            eMAX      :: MAX;
            eN_VALUES :: N_VALUES;
            ePAD_32   :: PAD_32;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Material class to represent a set of surface properties.
    
    \see PxPhysics.createMaterial
    */
    PxMaterial :: struct {
        #as using pxbasematerial: PxBaseMaterial;

        //~PxBase
        Constructor :: (this: *PxMaterial, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxMaterial@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxMaterial, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxMaterial@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbasematerial; pxmaterial_vtable: *PxMaterial_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        // PxBase
        virtual_getConcreteTypeName :: (this: *PxMaterial) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxMaterial@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxMaterial, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxMaterial@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxMaterial, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxMaterial@physx@@MEBA_NPEBD@Z";
    }
    PxMaterial_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        setDynamicFriction: (this: *PxMaterial, coef: PxReal) -> void #cpp_method;

        getDynamicFriction: (this: *PxMaterial) -> PxReal #cpp_method;

        setStaticFriction: (this: *PxMaterial, coef: PxReal) -> void #cpp_method;

        getStaticFriction: (this: *PxMaterial) -> PxReal #cpp_method;

        setRestitution: (this: *PxMaterial, rest: PxReal) -> void #cpp_method;

        getRestitution: (this: *PxMaterial) -> PxReal #cpp_method;

        setDamping: (this: *PxMaterial, damping: PxReal) -> void #cpp_method;

        getDamping: (this: *PxMaterial) -> PxReal #cpp_method;

        setFlag: (this: *PxMaterial, flag: PxMaterialFlag.Enum, b: bool) -> void #cpp_method;

        setFlags: (this: *PxMaterial, flags: PxMaterialFlags) -> void #cpp_method;

        getFlags: (this: *PxMaterial) -> PxMaterialFlags #cpp_method;

        setFrictionCombineMode: (this: *PxMaterial, combMode: PxCombineMode.Enum) -> void #cpp_method;

        getFrictionCombineMode: (this: *PxMaterial) -> PxCombineMode.Enum #cpp_method;

        setRestitutionCombineMode: (this: *PxMaterial, combMode: PxCombineMode.Enum) -> void #cpp_method;

        getRestitutionCombineMode: (this: *PxMaterial) -> PxCombineMode.Enum #cpp_method;

        setDampingCombineMode: (this: *PxMaterial, combMode: PxCombineMode.Enum) -> void #cpp_method;

        getDampingCombineMode: (this: *PxMaterial) -> PxCombineMode.Enum #cpp_method;
    }

    PxMaterial_setDynamicFriction :: inline (this: *PxMaterial, coef: PxReal) { this.pxmaterial_vtable.setDynamicFriction(this, coef); }

    PxMaterial_getDynamicFriction :: inline (this: *PxMaterial) -> PxReal { return this.pxmaterial_vtable.getDynamicFriction(this); }

    PxMaterial_setStaticFriction :: inline (this: *PxMaterial, coef: PxReal) { this.pxmaterial_vtable.setStaticFriction(this, coef); }

    PxMaterial_getStaticFriction :: inline (this: *PxMaterial) -> PxReal { return this.pxmaterial_vtable.getStaticFriction(this); }

    PxMaterial_setRestitution :: inline (this: *PxMaterial, rest: PxReal) { this.pxmaterial_vtable.setRestitution(this, rest); }

    PxMaterial_getRestitution :: inline (this: *PxMaterial) -> PxReal { return this.pxmaterial_vtable.getRestitution(this); }

    PxMaterial_setDamping :: inline (this: *PxMaterial, damping: PxReal) { this.pxmaterial_vtable.setDamping(this, damping); }

    PxMaterial_getDamping :: inline (this: *PxMaterial) -> PxReal { return this.pxmaterial_vtable.getDamping(this); }

    PxMaterial_setFlag :: inline (this: *PxMaterial, flag: PxMaterialFlag.Enum, b: bool) { this.pxmaterial_vtable.setFlag(this, flag, b); }

    PxMaterial_setFlags :: inline (this: *PxMaterial, flags: PxMaterialFlags) { this.pxmaterial_vtable.setFlags(this, flags); }

    PxMaterial_getFlags :: inline (this: *PxMaterial) -> PxMaterialFlags { return this.pxmaterial_vtable.getFlags(this); }

    PxMaterial_setFrictionCombineMode :: inline (this: *PxMaterial, combMode: PxCombineMode.Enum) { this.pxmaterial_vtable.setFrictionCombineMode(this, combMode); }

    PxMaterial_getFrictionCombineMode :: inline (this: *PxMaterial) -> PxCombineMode.Enum { return this.pxmaterial_vtable.getFrictionCombineMode(this); }

    PxMaterial_setRestitutionCombineMode :: inline (this: *PxMaterial, combMode: PxCombineMode.Enum) { this.pxmaterial_vtable.setRestitutionCombineMode(this, combMode); }

    PxMaterial_getRestitutionCombineMode :: inline (this: *PxMaterial) -> PxCombineMode.Enum { return this.pxmaterial_vtable.getRestitutionCombineMode(this); }

    PxMaterial_setDampingCombineMode :: inline (this: *PxMaterial, combMode: PxCombineMode.Enum) { this.pxmaterial_vtable.setDampingCombineMode(this, combMode); }

    PxMaterial_getDampingCombineMode :: inline (this: *PxMaterial) -> PxCombineMode.Enum { return this.pxmaterial_vtable.getDampingCombineMode(this); }

    vtable :: (obj: *PxMaterial) -> *PxMaterial_VTable { return obj.pxmaterial_vtable; }


    /*
    \brief Header for a contact patch where all points share same material and normal
    */
    PxContactPatch :: struct {
        PxContactPatchFlags :: enum s32 {
            HAS_FACE_INDICES            :: 1;
            MODIFIABLE                  :: 2;
            FORCE_NO_RESPONSE           :: 4;
            HAS_MODIFIED_MASS_RATIOS    :: 8;
            HAS_TARGET_VELOCITY         :: 16;
            HAS_MAX_IMPULSE             :: 32;
            REGENERATE_PATCHES          :: 64;
            COMPRESSED_MODIFIED_CONTACT :: 128;

            eHAS_FACE_INDICES            :: HAS_FACE_INDICES;
            eMODIFIABLE                  :: MODIFIABLE;
            eFORCE_NO_RESPONSE           :: FORCE_NO_RESPONSE;
            eHAS_MODIFIED_MASS_RATIOS    :: HAS_MODIFIED_MASS_RATIOS;
            eHAS_TARGET_VELOCITY         :: HAS_TARGET_VELOCITY;
            eHAS_MAX_IMPULSE             :: HAS_MAX_IMPULSE;
            eREGENERATE_PATCHES          :: REGENERATE_PATCHES;
            eCOMPRESSED_MODIFIED_CONTACT :: COMPRESSED_MODIFIED_CONTACT;
        }

        mMassModification: PxConstraintInvMassScale;

        normal:            PxVec3;

        /*
        \brief Restitution coefficient
        */
        restitution:       PxReal;

        /*
        \brief Dynamic friction coefficient
        */
        dynamicFriction:   PxReal;

        /*
        \brief Static friction coefficient
        */
        staticFriction:    PxReal;

        /*
        \brief Damping coefficient (for compliant contacts)
        */
        damping:           PxReal;

        /*
        \brief Index of the first contact in the patch
        */
        startContactIndex: PxU16;

        /*
        \brief The number of contacts in this patch
        */
        nbContacts:        PxU8;

        /*
        \brief The combined material flag of two actors that come in contact
        \see PxMaterialFlag, PxCombineMode
        */
        materialFlags:     PxU8;

        /*
        \brief The PxContactPatchFlags for this patch
        */
        internalFlags:     PxU16;

        /*
        \brief Material index of first body
        */
        materialIndex0:    PxU16;

        /*
        \brief Material index of second body
        */
        materialIndex1:    PxU16;

        pad:               [5] PxU16;
    }

    /*
    \brief Contact point data
    */
    PxContact :: struct {
        /*
        \brief Contact point in world space
        */
        contact:    PxVec3;

        /*
        \brief Separation value (negative implies penetration).
        */
        separation: PxReal;
    }

    /*
    \brief Contact point data with additional target and max impulse values
    */
    PxExtendedContact :: struct {
        #as using pxcontact: PxContact;

        targetVelocity: PxVec3;

        /*
        \brief Maximum impulse
        */
        maxImpulse:     PxReal;
    }

    /*
    \brief A modifiable contact point. This has additional fields per-contact to permit modification by user.
    \note Not all fields are currently exposed to the user.
    */
    PxModifiableContact :: struct {
        #as using pxextendedcontact: PxExtendedContact;

        normal:          PxVec3;

        /*
        \brief Restitution coefficient
        */
        restitution:     PxReal;

        /*
        \brief Material Flags
        */
        materialFlags:   PxU32;

        /*
        \brief Shape A's material index
        */
        materialIndex0:  PxU16;

        /*
        \brief Shape B's material index
        */
        materialIndex1:  PxU16;

        /*
        \brief static friction coefficient
        */
        staticFriction:  PxReal;

        /*
        \brief dynamic friction coefficient
        */
        dynamicFriction: PxReal;
    }

    /*
    \brief A class to iterate over a compressed contact stream. This supports read-only access to the various contact formats.
    */
    PxContactStreamIterator :: struct {
        StreamFormat :: enum s32 {
            SIMPLE_STREAM                :: 0;
            MODIFIABLE_STREAM            :: 1;
            COMPRESSED_MODIFIABLE_STREAM :: 2;

            eSIMPLE_STREAM                :: SIMPLE_STREAM;
            eMODIFIABLE_STREAM            :: MODIFIABLE_STREAM;
            eCOMPRESSED_MODIFIABLE_STREAM :: COMPRESSED_MODIFIABLE_STREAM;
        }

        /*
        \brief Utility zero vector to optimize functions returning zero vectors when a certain flag isn't set.
        \note This allows us to return by reference instead of having to return by value. Returning by value will go via memory (registers -> stack -> registers), which can
        cause performance issues on certain platforms.
        */
        zero:                   PxVec3;

        /*
        \brief The patch headers.
        */
        patch:                  *PxContactPatch;

        /*
        \brief The contacts
        */
        contact:                *PxContact;

        /*
        \brief The contact triangle face index
        */
        faceIndice:             *PxU32;

        /*
        \brief The total number of patches in this contact stream
        */
        totalPatches:           PxU32;

        /*
        \brief The total number of contact points in this stream
        */
        totalContacts:          PxU32;

        /*
        \brief The current contact index
        */
        nextContactIndex:       PxU32;

        /*
        \brief The current patch Index
        */
        nextPatchIndex:         PxU32;

        /*
        \brief Size of contact patch header
        \note This varies whether the patch is modifiable or not.
        */
        contactPatchHeaderSize: PxU32;

        /*
        \brief Contact point size
        \note This varies whether the patch has feature indices or is modifiable.
        */
        contactPointSize:       PxU32;

        /*
        \brief The stream format
        */
        mStreamFormat:          StreamFormat;

        /*
        \brief Indicates whether this stream is notify-only or not.
        */
        forceNoResponse:        PxU32;

        /*
        \brief Internal helper for stepping the contact stream iterator
        */
        pointStepped:           bool;

        /*
        \brief Specifies if this contactPatch has face indices (handled as bool)
        \see faceIndice
        */
        hasFaceIndices:         PxU32;

        /*
        \brief Constructor
        */
        Constructor :: (this: *PxContactStreamIterator, contactPatches: *PxU8, contactPoints: *PxU8, contactFaceIndices: *PxU32, nbPatches: PxU32, nbContacts: PxU32) -> void #cpp_method #foreign physx_static "??0PxContactStreamIterator@physx@@QEAA@PEBE0PEBIII@Z";

        /*
        \brief Returns whether there are more patches in this stream.
        \return Whether there are more patches in this stream.
        */
        hasNextPatch :: (this: *PxContactStreamIterator) -> bool #cpp_method #foreign physx_static "?hasNextPatch@PxContactStreamIterator@physx@@QEBA_NXZ";

        /*
        \brief Advances iterator to next contact patch.
        */
        nextPatch :: (this: *PxContactStreamIterator) -> void #cpp_method #foreign physx_static "?nextPatch@PxContactStreamIterator@physx@@QEAAXXZ";

        /*
        \brief Returns if the current patch has more contacts.
        \return If there are more contacts in the current patch.
        */
        hasNextContact :: (this: *PxContactStreamIterator) -> bool #cpp_method #foreign physx_static "?hasNextContact@PxContactStreamIterator@physx@@QEBA_NXZ";

        /*
        \brief Advances to the next contact in the patch.
        */
        nextContact :: (this: *PxContactStreamIterator) -> void #cpp_method #foreign physx_static "?nextContact@PxContactStreamIterator@physx@@QEAAXXZ";

        /*
        \brief Gets the current contact's normal
        \return The current contact's normal.
        */
        getContactNormal :: (this: *PxContactStreamIterator) -> *PxVec3 #cpp_method #foreign physx_static "?getContactNormal@PxContactStreamIterator@physx@@QEBAAEBV?$PxVec3T@M@2@XZ";

        /*
        \brief Gets the inverse mass scale for body 0.
        \return The inverse mass scale for body 0.
        */
        getInvMassScale0 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getInvMassScale0@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the inverse mass scale for body 1.
        \return The inverse mass scale for body 1.
        */
        getInvMassScale1 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getInvMassScale1@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the inverse inertia scale for body 0.
        \return The inverse inertia scale for body 0.
        */
        getInvInertiaScale0 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getInvInertiaScale0@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the inverse inertia scale for body 1.
        \return The inverse inertia scale for body 1.
        */
        getInvInertiaScale1 :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getInvInertiaScale1@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the contact's max impulse.
        \return The contact's max impulse.
        */
        getMaxImpulse :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getMaxImpulse@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the contact's target velocity.
        \return The contact's target velocity.
        */
        getTargetVel :: (this: *PxContactStreamIterator) -> *PxVec3 #cpp_method #foreign physx_static "?getTargetVel@PxContactStreamIterator@physx@@QEBAAEBV?$PxVec3T@M@2@XZ";

        /*
        \brief Gets the contact's contact point.
        \return The contact's contact point.
        */
        getContactPoint :: (this: *PxContactStreamIterator) -> *PxVec3 #cpp_method #foreign physx_static "?getContactPoint@PxContactStreamIterator@physx@@QEBAAEBV?$PxVec3T@M@2@XZ";

        /*
        \brief Gets the contact's separation.
        \return The contact's separation.
        */
        getSeparation :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getSeparation@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the contact's face index for shape 0.
        \return The contact's face index for shape 0.
        */
        getFaceIndex0 :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_static "?getFaceIndex0@PxContactStreamIterator@physx@@QEBAIXZ";

        /*
        \brief Gets the contact's face index for shape 1.
        \return The contact's face index for shape 1.
        */
        getFaceIndex1 :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_static "?getFaceIndex1@PxContactStreamIterator@physx@@QEBAIXZ";

        /*
        \brief Gets the contact's static friction coefficient.
        \return The contact's static friction coefficient.
        */
        getStaticFriction :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getStaticFriction@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the contact's dynamic friction coefficient.
        \return The contact's dynamic friction coefficient.
        */
        getDynamicFriction :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getDynamicFriction@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the contact's restitution coefficient.
        \return The contact's restitution coefficient.
        */
        getRestitution :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getRestitution@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the contact's damping value.
        \return The contact's damping value.
        */
        getDamping :: (this: *PxContactStreamIterator) -> PxReal #cpp_method #foreign physx_static "?getDamping@PxContactStreamIterator@physx@@QEBAMXZ";

        /*
        \brief Gets the contact's material flags.
        \return The contact's material flags.
        */
        getMaterialFlags :: (this: *PxContactStreamIterator) -> PxU32 #cpp_method #foreign physx_static "?getMaterialFlags@PxContactStreamIterator@physx@@QEBAIXZ";

        /*
        \brief Gets the contact's material index for shape 0.
        \return The contact's material index for shape 0.
        */
        getMaterialIndex0 :: (this: *PxContactStreamIterator) -> PxU16 #cpp_method #foreign physx_static "?getMaterialIndex0@PxContactStreamIterator@physx@@QEBAGXZ";

        /*
        \brief Gets the contact's material index for shape 1.
        \return The contact's material index for shape 1.
        */
        getMaterialIndex1 :: (this: *PxContactStreamIterator) -> PxU16 #cpp_method #foreign physx_static "?getMaterialIndex1@PxContactStreamIterator@physx@@QEBAGXZ";

        /*
        \brief Internal helper
        */
        getContactPatch :: (this: *PxContactStreamIterator) -> *PxContactPatch #cpp_method #foreign physx_static "?getContactPatch@PxContactStreamIterator@physx@@AEBAAEBUPxContactPatch@2@XZ";

        getExtendedContact :: (this: *PxContactStreamIterator) -> *PxExtendedContact #cpp_method #foreign physx_static "?getExtendedContact@PxContactStreamIterator@physx@@AEBAAEBUPxExtendedContact@2@XZ";
    }

    /*
    \brief Contact patch friction information.
    */
    PxFrictionPatch :: struct {
        /*
        \brief Max anchors per patch
        */
        MAX_ANCHOR_COUNT: PxU32 : 2;

        /*
        \brief Friction anchors' positions
        */
        anchorPositions:  [2] PxVec3;

        /*
        \brief Friction anchors' impulses
        */
        anchorImpulses:   [2] PxVec3;

        /*
        \brief Friction anchor count
        */
        anchorCount:      PxU32;
    }

    /*
    \brief A class to iterate over a friction anchor stream.
    */
    PxFrictionAnchorStreamIterator :: struct {
        mContactPatches:      *PxContactPatch;
        mFrictionPatches:     *PxFrictionPatch;
        mPatchCount:          PxU32;
        mFrictionAnchorIndex: PxI32;
        mPatchIndex:          PxI32;
    }

    /*
    \brief Contains contact information for a contact reported by the direct-GPU contact report API. See PxScene::copyContactData().
    */
    PxGpuContactPair :: struct {
        contactPatches:     *PxU8; //!< Ptr to contact patches. Type: PxContactPatch*, size: nbPatches.
        contactPoints:      *PxU8; //!< Ptr to contact points. Type: PxContact*, size: nbContacts.
        contactForces:      *PxReal; //!< Ptr to contact forces. Size: nbContacts.
        frictionPatches:    *PxU8; //!< Ptr to friction patch information. Type: PxFrictionPatch*, size: nbPatches.
        transformCacheRef0: PxU32; //!< Ref to shape0's transform in transform cache.
        transformCacheRef1: PxU32; //!< Ref to shape1's transform in transform cache.
        nodeIndex0:         PxNodeIndex; //!< Unique Id for actor0 if the actor is dynamic.
        nodeIndex1:         PxNodeIndex; //!< Unique Id for actor1 if the actor is dynamic.
        actor0:             *PxActor; //!< Ptr to PxActor for actor0.
        actor1:             *PxActor; //!< Ptr to PxActor for actor1.

        nbContacts:         PxU16; //!< Num contacts.
        nbPatches:          PxU16; //!< Num patches.
    }

    /*
    \brief An array of contact points, as passed to contact modification.
    
    The word 'set' in the name does not imply that duplicates are filtered in any
    way.  This initial set of contacts does potentially get reduced to a smaller
    set before being passed to the solver.
    
    You can use the accessors to read and write contact properties.  The number of
    contacts is immutable, other than being able to disable contacts using ignore().
    
    \see PxContactModifyCallback, PxModifiableContact
    */
    PxContactSet :: struct {
        mCount:    PxU32; //!< Number of contact points in the set
        mContacts: *PxModifiableContact; //!< The contact points of the set
    }

    /*
    \brief An array of instances of this class is passed to PxContactModifyCallback::onContactModify().
    
    \see PxContactModifyCallback
    */
    PxContactModifyPair :: struct {
        /*
        \brief The actors which make up the pair in contact.
        
        Note that these are the actors as seen by the simulation, and may have been deleted since the simulation step started.
        */
        actor:     [2] *PxRigidActor;

        /*
        \brief The shapes which make up the pair in contact.
        
        Note that these are the shapes as seen by the simulation, and may have been deleted since the simulation step started.
        */
        shape:     [2] *PxShape;

        /*
        \brief The shape to world transforms of the two shapes.
        
        These are the transforms as the simulation engine sees them, and may have been modified by the application
        since the simulation step started.
        */
        transform: [2] PxTransform;

        /*
        \brief An array of contact points between these two shapes.
        */
        contacts:  PxContactSet;
    }

    /*
    \brief An interface class that the user can implement in order to modify contact constraints.
    
    <b>Threading:</b> It is <b>necessary</b> to make this class thread safe as it will be called in the context of the
    simulation thread. It might also be necessary to make it reentrant, since some calls can be made by multi-threaded
    parts of the physics engine.
    
    You can enable the use of this contact modification callback by raising the flag PxPairFlag::eMODIFY_CONTACTS in
    the filter shader/callback (see #PxSimulationFilterShader) for a pair of rigid body objects.
    
    Please note:
    + Raising the contact modification flag will not wake the actors up automatically.
    + It is not possible to turn off the performance degradation by simply removing the callback from the scene, the
    filter shader/callback has to be used to clear the contact modification flag.
    + The contacts will only be reported as long as the actors are awake. There will be no callbacks while the actors are sleeping.
    
    \see PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
    */
    PxContactModifyCallback :: struct {
        vtable: *PxContactModifyCallback_VTable;
    }
    PxContactModifyCallback_VTable :: struct #type_info_none {
        onContactModify: (this: *PxContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) -> void #cpp_method;

        Destructor: (this: *PxContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxContactModifyCallback_onContactModify :: inline (this: *PxContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) { this.vtable.onContactModify(this, pairs, count); }

    PxContactModifyCallback_Destructor :: inline (this: *PxContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxContactModifyCallback) -> *PxContactModifyCallback_VTable { return obj.vtable; }


    /*
    \brief An interface class that the user can implement in order to modify CCD contact constraints.
    
    <b>Threading:</b> It is <b>necessary</b> to make this class thread safe as it will be called in the context of the
    simulation thread. It might also be necessary to make it reentrant, since some calls can be made by multi-threaded
    parts of the physics engine.
    
    You can enable the use of this contact modification callback by raising the flag PxPairFlag::eMODIFY_CONTACTS in
    the filter shader/callback (see #PxSimulationFilterShader) for a pair of rigid body objects.
    
    Please note:
    + Raising the contact modification flag will not wake the actors up automatically.
    + It is not possible to turn off the performance degradation by simply removing the callback from the scene, the
    filter shader/callback has to be used to clear the contact modification flag.
    + The contacts will only be reported as long as the actors are awake. There will be no callbacks while the actors are sleeping.
    
    \see PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
    */
    PxCCDContactModifyCallback :: struct {
        vtable: *PxCCDContactModifyCallback_VTable;
    }
    PxCCDContactModifyCallback_VTable :: struct #type_info_none {
        onCCDContactModify: (this: *PxCCDContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) -> void #cpp_method;

        Destructor: (this: *PxCCDContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxCCDContactModifyCallback_onCCDContactModify :: inline (this: *PxCCDContactModifyCallback, pairs: *PxContactModifyPair, count: PxU32) { this.vtable.onCCDContactModify(this, pairs, count); }

    PxCCDContactModifyCallback_Destructor :: inline (this: *PxCCDContactModifyCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxCCDContactModifyCallback) -> *PxCCDContactModifyCallback_VTable { return obj.vtable; }


    /*
    \brief Flags specifying deletion event types.
    
    \see PxDeletionListener::onRelease PxPhysics.registerDeletionListener()
    */
    PxDeletionEventFlag :: struct {
        Enum :: enum s32 {
            USER_RELEASE   :: 1;
            MEMORY_RELEASE :: 2;

            eUSER_RELEASE   :: USER_RELEASE;
            eMEMORY_RELEASE :: MEMORY_RELEASE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Collection of set bits defined in PxDeletionEventFlag.
    
    \see PxDeletionEventFlag
    */
    PxDeletionEventFlags :: PxFlags(PxDeletionEventFlag.Enum, PxU8);

    /*
    \brief interface to get notification on object deletion
    
    */
    PxDeletionListener :: struct {
        vtable: *PxDeletionListener_VTable;
        Constructor :: (this: *PxDeletionListener) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxDeletionListener@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxDeletionListener, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxDeletionListener@physx@@MEAA@XZ";
    }
    PxDeletionListener_VTable :: struct #type_info_none {
        onRelease: (this: *PxDeletionListener, observed: *PxBase, userData: *void, deletionEvent: PxDeletionEventFlag.Enum) -> void #cpp_method;

        Destructor: (this: *PxDeletionListener, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxDeletionListener_onRelease :: inline (this: *PxDeletionListener, observed: *PxBase, userData: *void, deletionEvent: PxDeletionEventFlag.Enum) { this.vtable.onRelease(this, observed, userData, deletionEvent); }

    PxDeletionListener_Destructor :: inline (this: *PxDeletionListener, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxDeletionListener) -> *PxDeletionListener_VTable { return obj.vtable; }


    /*
    \brief Material class to represent a set of FEM material properties.
    
    \see PxPhysics.createFEMSoftBodyMaterial
    */
    PxFEMMaterial :: struct {
        #as using pxbasematerial: PxBaseMaterial;

        Constructor :: (this: *PxFEMMaterial, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxFEMMaterial@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxFEMMaterial, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxFEMMaterial@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbasematerial; pxfemmaterial_vtable: *PxFEMMaterial_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxFEMMaterial, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxFEMMaterial@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxFEMMaterial, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxFEMMaterial@physx@@MEBA_NPEBD@Z";
    }
    PxFEMMaterial_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        setYoungsModulus: (this: *PxFEMMaterial, young: PxReal) -> void #cpp_method;

        getYoungsModulus: (this: *PxFEMMaterial) -> PxReal #cpp_method;

        setPoissons: (this: *PxFEMMaterial, poisson: PxReal) -> void #cpp_method;

        getPoissons: (this: *PxFEMMaterial) -> PxReal #cpp_method;

        setDynamicFriction: (this: *PxFEMMaterial, dynamicFriction: PxReal) -> void #cpp_method;

        getDynamicFriction: (this: *PxFEMMaterial) -> PxReal #cpp_method;
    }

    PxFEMMaterial_setYoungsModulus :: inline (this: *PxFEMMaterial, young: PxReal) { this.pxfemmaterial_vtable.setYoungsModulus(this, young); }

    PxFEMMaterial_getYoungsModulus :: inline (this: *PxFEMMaterial) -> PxReal { return this.pxfemmaterial_vtable.getYoungsModulus(this); }

    PxFEMMaterial_setPoissons :: inline (this: *PxFEMMaterial, poisson: PxReal) { this.pxfemmaterial_vtable.setPoissons(this, poisson); }

    PxFEMMaterial_getPoissons :: inline (this: *PxFEMMaterial) -> PxReal { return this.pxfemmaterial_vtable.getPoissons(this); }

    PxFEMMaterial_setDynamicFriction :: inline (this: *PxFEMMaterial, dynamicFriction: PxReal) { this.pxfemmaterial_vtable.setDynamicFriction(this, dynamicFriction); }

    PxFEMMaterial_getDynamicFriction :: inline (this: *PxFEMMaterial) -> PxReal { return this.pxfemmaterial_vtable.getDynamicFriction(this); }

    vtable :: (obj: *PxFEMMaterial) -> *PxFEMMaterial_VTable { return obj.pxfemmaterial_vtable; }


    PxFEMSoftBodyMaterialModel :: struct {
        Enum :: enum s32 {
            CO_ROTATIONAL :: 0;
            NEO_HOOKEAN   :: 1;

            eCO_ROTATIONAL :: CO_ROTATIONAL;
            eNEO_HOOKEAN   :: NEO_HOOKEAN;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Material class to represent a set of softbody FEM material properties.
    
    \see PxPhysics.createFEMSoftBodyMaterial
    */
    PxFEMSoftBodyMaterial :: struct {
        #as using pxfemmaterial: PxFEMMaterial;

        Constructor :: (this: *PxFEMSoftBodyMaterial, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxFEMSoftBodyMaterial@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxFEMSoftBodyMaterial, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxFEMSoftBodyMaterial@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxfemmaterial; pxfemsoftbodymaterial_vtable: *PxFEMSoftBodyMaterial_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxFEMSoftBodyMaterial) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxFEMSoftBodyMaterial@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxFEMSoftBodyMaterial, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxFEMSoftBodyMaterial@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxFEMSoftBodyMaterial, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxFEMSoftBodyMaterial@physx@@MEBA_NPEBD@Z";
    }
    PxFEMSoftBodyMaterial_VTable :: struct #type_info_none {
        using pxfemmaterial: PxFEMMaterial_VTable;
        setDamping: (this: *PxFEMSoftBodyMaterial, damping: PxReal) -> void #cpp_method;

        getDamping: (this: *PxFEMSoftBodyMaterial) -> PxReal #cpp_method;

        setDampingScale: (this: *PxFEMSoftBodyMaterial, scale: PxReal) -> void #cpp_method;

        getDampingScale: (this: *PxFEMSoftBodyMaterial) -> PxReal #cpp_method;

        setMaterialModel: (this: *PxFEMSoftBodyMaterial, model: PxFEMSoftBodyMaterialModel.Enum) -> void #cpp_method;

        getMaterialModel: (this: *PxFEMSoftBodyMaterial) -> PxFEMSoftBodyMaterialModel.Enum #cpp_method;
    }

    PxFEMSoftBodyMaterial_setDamping :: inline (this: *PxFEMSoftBodyMaterial, damping: PxReal) { this.pxfemsoftbodymaterial_vtable.setDamping(this, damping); }

    PxFEMSoftBodyMaterial_getDamping :: inline (this: *PxFEMSoftBodyMaterial) -> PxReal { return this.pxfemsoftbodymaterial_vtable.getDamping(this); }

    PxFEMSoftBodyMaterial_setDampingScale :: inline (this: *PxFEMSoftBodyMaterial, scale: PxReal) { this.pxfemsoftbodymaterial_vtable.setDampingScale(this, scale); }

    PxFEMSoftBodyMaterial_getDampingScale :: inline (this: *PxFEMSoftBodyMaterial) -> PxReal { return this.pxfemsoftbodymaterial_vtable.getDampingScale(this); }

    PxFEMSoftBodyMaterial_setMaterialModel :: inline (this: *PxFEMSoftBodyMaterial, model: PxFEMSoftBodyMaterialModel.Enum) { this.pxfemsoftbodymaterial_vtable.setMaterialModel(this, model); }

    PxFEMSoftBodyMaterial_getMaterialModel :: inline (this: *PxFEMSoftBodyMaterial) -> PxFEMSoftBodyMaterialModel.Enum { return this.pxfemsoftbodymaterial_vtable.getMaterialModel(this); }

    vtable :: (obj: *PxFEMSoftBodyMaterial) -> *PxFEMSoftBodyMaterial_VTable { return obj.pxfemsoftbodymaterial_vtable; }


    PxDataAccessFlag :: struct {
        Enum :: enum s32 {
            READABLE :: 1;
            WRITABLE :: 2;
            DEVICE   :: 4;

            eREADABLE :: READABLE;
            eWRITABLE :: WRITABLE;
            eDEVICE   :: DEVICE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxDataAccessFlag.
    
    \see PxDataAccessFlag
    */
    PxDataAccessFlags :: PxFlags(PxDataAccessFlag.Enum, PxU8);

    /*
    \brief Parent class for bulk data that is shared between the SDK and the application.
    */
    PxLockedData :: struct {
        vtable: *PxLockedData_VTable;
    }
    PxLockedData_VTable :: struct #type_info_none {
        getDataAccessFlags: (this: *PxLockedData) -> PxDataAccessFlags #cpp_method;

        unlock: (this: *PxLockedData) -> void #cpp_method;

        Destructor: (this: *PxLockedData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxLockedData_getDataAccessFlags :: inline (this: *PxLockedData) -> PxDataAccessFlags { return this.vtable.getDataAccessFlags(this); }

    PxLockedData_unlock :: inline (this: *PxLockedData) { this.vtable.unlock(this); }

    PxLockedData_Destructor :: inline (this: *PxLockedData, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxLockedData) -> *PxLockedData_VTable { return obj.vtable; }


    PxParticleRigidAttachment :: struct {}

    /*
    \brief Particle volume structure. Used to track the bounding volume of a user-specified set of particles. The particles are required
    to be laid out contiguously within the same PxParticleBuffer.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    */
    PxParticleVolume :: struct {
        bound:                 PxBounds3; //!< The current bounds of the particles contained in this #PxParticleVolume.
        particleIndicesOffset: PxU32; //!< The index into the particle list of the #PxParticleBuffer for the first particle of this volume.
        numParticles:          PxU32; //!< The number of particles contained in this #PxParticleVolume.
    }

    /*
    \brief The shared base class for all particle buffers, can be instantiated directly to simulate granular and fluid particles.
    
    See #PxPhysics::createParticleBuffer.
    
    A particle buffer is a container that specifies per-particle attributes of a set of particles that will be used during the simulation
    of a particle system. It exposes direct access to the underlying GPU buffers and is independent of the scene and particle system. Particle
    buffers can be added/removed from a particle system at any time between simulation steps, and transferred from one particle system to another.
    */
    PxParticleBuffer :: struct {
        #as using pxbase: PxBase;

        /*
        \deprecated Will be removed in a future version, use getUniqueId() instead.
        \brief Unique index that does not change over the lifetime of a PxParticleBuffer.
        */
        bufferUniqueId: PxU32;

        userData:       *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.

        Constructor :: (this: *PxParticleBuffer, type: PxType) -> void #cpp_method #foreign physx_static "??0PxParticleBuffer@physx@@IEAA@G@Z";
        #place pxbase; pxparticlebuffer_vtable: *PxParticleBuffer_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxParticleBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxParticleBuffer@physx@@MEAA@XZ";
    }
    PxParticleBuffer_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getPositionInvMasses: (this: *PxParticleBuffer) -> *PxVec4 #cpp_method;

        getVelocities: (this: *PxParticleBuffer) -> *PxVec4 #cpp_method;

        getPhases: (this: *PxParticleBuffer) -> *PxU32 #cpp_method;

        getParticleVolumes: (this: *PxParticleBuffer) -> *PxParticleVolume #cpp_method;

        setNbActiveParticles: (this: *PxParticleBuffer, nbActiveParticles: PxU32) -> void #cpp_method;

        getNbActiveParticles: (this: *PxParticleBuffer) -> PxU32 #cpp_method;

        getMaxParticles: (this: *PxParticleBuffer) -> PxU32 #cpp_method;

        getNbParticleVolumes: (this: *PxParticleBuffer) -> PxU32 #cpp_method;

        setNbParticleVolumes: (this: *PxParticleBuffer, nbParticleVolumes: PxU32) -> void #cpp_method;

        getMaxParticleVolumes: (this: *PxParticleBuffer) -> PxU32 #cpp_method;

        setRigidFilters: (this: *PxParticleBuffer, filters: *PxParticleRigidFilterPair, nbFilters: PxU32) -> void #cpp_method;

        setRigidAttachments: (this: *PxParticleBuffer, attachments: *PxParticleRigidAttachment, nbAttachments: PxU32) -> void #cpp_method;

        getFlatListStartIndex: (this: *PxParticleBuffer) -> PxU32 #cpp_method;

        raiseFlags: (this: *PxParticleBuffer, flags: PxParticleBufferFlag.Enum) -> void #cpp_method;

        getUniqueId: (this: *PxParticleBuffer) -> PxU32 #cpp_method;
    }

    PxParticleBuffer_getPositionInvMasses :: inline (this: *PxParticleBuffer) -> *PxVec4 { return this.pxparticlebuffer_vtable.getPositionInvMasses(this); }

    PxParticleBuffer_getVelocities :: inline (this: *PxParticleBuffer) -> *PxVec4 { return this.pxparticlebuffer_vtable.getVelocities(this); }

    PxParticleBuffer_getPhases :: inline (this: *PxParticleBuffer) -> *PxU32 { return this.pxparticlebuffer_vtable.getPhases(this); }

    PxParticleBuffer_getParticleVolumes :: inline (this: *PxParticleBuffer) -> *PxParticleVolume { return this.pxparticlebuffer_vtable.getParticleVolumes(this); }

    PxParticleBuffer_setNbActiveParticles :: inline (this: *PxParticleBuffer, nbActiveParticles: PxU32) { this.pxparticlebuffer_vtable.setNbActiveParticles(this, nbActiveParticles); }

    PxParticleBuffer_getNbActiveParticles :: inline (this: *PxParticleBuffer) -> PxU32 { return this.pxparticlebuffer_vtable.getNbActiveParticles(this); }

    PxParticleBuffer_getMaxParticles :: inline (this: *PxParticleBuffer) -> PxU32 { return this.pxparticlebuffer_vtable.getMaxParticles(this); }

    PxParticleBuffer_getNbParticleVolumes :: inline (this: *PxParticleBuffer) -> PxU32 { return this.pxparticlebuffer_vtable.getNbParticleVolumes(this); }

    PxParticleBuffer_setNbParticleVolumes :: inline (this: *PxParticleBuffer, nbParticleVolumes: PxU32) { this.pxparticlebuffer_vtable.setNbParticleVolumes(this, nbParticleVolumes); }

    PxParticleBuffer_getMaxParticleVolumes :: inline (this: *PxParticleBuffer) -> PxU32 { return this.pxparticlebuffer_vtable.getMaxParticleVolumes(this); }

    PxParticleBuffer_setRigidFilters :: inline (this: *PxParticleBuffer, filters: *PxParticleRigidFilterPair, nbFilters: PxU32) { this.pxparticlebuffer_vtable.setRigidFilters(this, filters, nbFilters); }

    PxParticleBuffer_setRigidAttachments :: inline (this: *PxParticleBuffer, attachments: *PxParticleRigidAttachment, nbAttachments: PxU32) { this.pxparticlebuffer_vtable.setRigidAttachments(this, attachments, nbAttachments); }

    PxParticleBuffer_getFlatListStartIndex :: inline (this: *PxParticleBuffer) -> PxU32 { return this.pxparticlebuffer_vtable.getFlatListStartIndex(this); }

    PxParticleBuffer_raiseFlags :: inline (this: *PxParticleBuffer, flags: PxParticleBufferFlag.Enum) { this.pxparticlebuffer_vtable.raiseFlags(this, flags); }

    PxParticleBuffer_getUniqueId :: inline (this: *PxParticleBuffer) -> PxU32 { return this.pxparticlebuffer_vtable.getUniqueId(this); }

    vtable :: (obj: *PxParticleBuffer) -> *PxParticleBuffer_VTable { return obj.pxparticlebuffer_vtable; }


    /*
    \brief Parameters to configure the behavior of diffuse particles
    */
    PxDiffuseParticleParams :: struct {
        threshold:           PxReal; //!< Particles with potential value greater than the threshold will spawn diffuse particles
        lifetime:            PxReal; //!< Diffuse particle will be removed after the specified lifetime
        airDrag:             PxReal; //!< Air drag force factor for spray particles
        bubbleDrag:          PxReal; //!< Fluid drag force factor for bubble particles
        buoyancy:            PxReal; //!< Buoyancy force factor for bubble particles
        kineticEnergyWeight: PxReal; //!< Contribution from kinetic energy when deciding diffuse particle creation.
        pressureWeight:      PxReal; //!< Contribution from pressure when deciding diffuse particle creation.
        divergenceWeight:    PxReal; //!< Contribution from divergence when deciding diffuse particle creation.
        collisionDecay:      PxReal; //!< Decay factor of diffuse particles' lifetime after they collide with shapes.
        useAccurateVelocity: bool; //!< If true, enables accurate velocity estimation when using PBD solver.
    }

    /*
    \brief A particle buffer used to simulate diffuse particles.
    
    See #PxPhysics::createParticleAndDiffuseBuffer.
    */
    PxParticleAndDiffuseBuffer :: struct {
        #as using pxparticlebuffer: PxParticleBuffer;

        Constructor :: (this: *PxParticleAndDiffuseBuffer, type: PxType) -> void #cpp_method #foreign physx_static "??0PxParticleAndDiffuseBuffer@physx@@IEAA@G@Z";
        #place pxparticlebuffer; pxparticleanddiffusebuffer_vtable: *PxParticleAndDiffuseBuffer_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxParticleAndDiffuseBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxParticleAndDiffuseBuffer@physx@@MEAA@XZ";
    }
    PxParticleAndDiffuseBuffer_VTable :: struct #type_info_none {
        using pxparticlebuffer: PxParticleBuffer_VTable;
        getDiffusePositionLifeTime: (this: *PxParticleAndDiffuseBuffer) -> *PxVec4 #cpp_method;

        getDiffuseVelocities: (this: *PxParticleAndDiffuseBuffer) -> *PxVec4 #cpp_method;

        getNbActiveDiffuseParticles: (this: *PxParticleAndDiffuseBuffer) -> PxU32 #cpp_method;

        setMaxActiveDiffuseParticles: (this: *PxParticleAndDiffuseBuffer, maxActiveDiffuseParticles: PxU32) -> void #cpp_method;

        getMaxDiffuseParticles: (this: *PxParticleAndDiffuseBuffer) -> PxU32 #cpp_method;

        setDiffuseParticleParams: (this: *PxParticleAndDiffuseBuffer, params: *PxDiffuseParticleParams) -> void #cpp_method;

        getDiffuseParticleParams: (this: *PxParticleAndDiffuseBuffer) -> PxDiffuseParticleParams #cpp_method #cpp_return_type_is_non_pod;
    }

    PxParticleAndDiffuseBuffer_getDiffusePositionLifeTime :: inline (this: *PxParticleAndDiffuseBuffer) -> *PxVec4 { return this.pxparticleanddiffusebuffer_vtable.getDiffusePositionLifeTime(this); }

    PxParticleAndDiffuseBuffer_getDiffuseVelocities :: inline (this: *PxParticleAndDiffuseBuffer) -> *PxVec4 { return this.pxparticleanddiffusebuffer_vtable.getDiffuseVelocities(this); }

    PxParticleAndDiffuseBuffer_getNbActiveDiffuseParticles :: inline (this: *PxParticleAndDiffuseBuffer) -> PxU32 { return this.pxparticleanddiffusebuffer_vtable.getNbActiveDiffuseParticles(this); }

    PxParticleAndDiffuseBuffer_setMaxActiveDiffuseParticles :: inline (this: *PxParticleAndDiffuseBuffer, maxActiveDiffuseParticles: PxU32) { this.pxparticleanddiffusebuffer_vtable.setMaxActiveDiffuseParticles(this, maxActiveDiffuseParticles); }

    PxParticleAndDiffuseBuffer_getMaxDiffuseParticles :: inline (this: *PxParticleAndDiffuseBuffer) -> PxU32 { return this.pxparticleanddiffusebuffer_vtable.getMaxDiffuseParticles(this); }

    PxParticleAndDiffuseBuffer_setDiffuseParticleParams :: inline (this: *PxParticleAndDiffuseBuffer, params: *PxDiffuseParticleParams) { this.pxparticleanddiffusebuffer_vtable.setDiffuseParticleParams(this, params); }

    PxParticleAndDiffuseBuffer_getDiffuseParticleParams :: inline (this: *PxParticleAndDiffuseBuffer) -> PxDiffuseParticleParams { return this.pxparticleanddiffusebuffer_vtable.getDiffuseParticleParams(this); }

    vtable :: (obj: *PxParticleAndDiffuseBuffer) -> *PxParticleAndDiffuseBuffer_VTable { return obj.pxparticleanddiffusebuffer_vtable; }


    /*
    \brief Holds all the information for a spring constraint between two particles. Used for particle cloth simulation.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    */
    PxParticleSpring :: struct {
        ind0:      PxU32; //!< particle index of first particle
        ind1:      PxU32; //!< particle index of second particle
        length:    PxReal; //!< spring length
        stiffness: PxReal; //!< spring stiffness
        damping:   PxReal; //!< spring damping factor
        pad:       PxReal; //!< padding bytes.
    }

    /*
    \brief Particle cloth structure. Holds information about a single piece of cloth that is part of a #PxParticleClothBuffer.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    */
    PxParticleCloth :: struct {
        startVertexIndex:   PxU32; //!< Index of the first particle of this cloth in the position/velocity buffers of the parent #PxParticleClothBuffer
        numVertices:        PxU32; //!< The number of particles of this piece of cloth
        clothBlendScale:    PxReal; //!< Used internally.
        restVolume:         PxReal; //!< The rest volume of this piece of cloth, used for inflatable simulation.
        pressure:           PxReal; //!< The factor of the rest volume to specify the target volume for this piece of cloth, used for inflatable simulation.
        startTriangleIndex: PxU32; //!< The index of the first triangle of this piece of cloth in the triangle list.
        numTriangles:       PxU32; //!< The number of triangles of this piece of cloth.
    }

    operator< :: (this: *physx.PxParticleCloth, other: *physx.PxParticleCloth) -> bool #cpp_method #foreign physx_static "??MPxParticleCloth@physx@@QEBA_NAEBU01@@Z";
    operator< :: (this: physx.PxParticleCloth, other: physx.PxParticleCloth) -> bool #no_context {
        return operator<(*this, *other);
    }

    /*
    \brief Structure to describe the set of particle cloths in the same #PxParticleClothBuffer. Used an input for the cloth preprocessing.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    */
    PxParticleClothDesc :: struct {
        cloths:        *PxParticleCloth; //!< List of PxParticleCloth s, describes the individual cloths.
        triangles:     *PxU32; //!< List of triangle indices, 3 consecutive PxU32 that map triangle vertices to particles
        springs:       *PxParticleSpring; //!< List of PxParticleSpring s.
        restPositions: *PxVec4; //!< List of rest positions for all particles
        nbCloths:      PxU32; //!< The number of cloths in described using this cloth descriptor
        nbSprings:     PxU32; //!< The number of springs in this cloth descriptor
        nbTriangles:   PxU32; //!< The number of triangles in this cloth descriptor
        nbParticles:   PxU32; //!< The number of particles in this cloth descriptor
    }

    /*
    \brief Structure to describe the output of the particle cloth preprocessing. Used as an input to specify cloth data for a #PxParticleClothBuffer.
    All the pointers point to pinned host memory.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    
    See #PxParticleClothPreProcessor
    */
    PxPartitionedParticleCloth :: struct {
        accumulatedSpringsPerPartitions: *PxU32; //!< The number of springs in each partition. Size: numPartitions.
        accumulatedCopiesPerParticles:   *PxU32; //!< Start index for each particle in the accumulation buffer. Size: numParticles.
        remapOutput:                     *PxU32; //!< Index of the next copy of this particle in the next partition, or in the accumulation buffer. Size: numSprings * 2.
        orderedSprings:                  *PxParticleSpring; //!< Springs ordered by partition. Size: numSprings.
        sortedClothStartIndices:         *PxU32; //!< The first particle index into the position buffer of the #PxParticleClothBuffer for each cloth. Cloths are sorted by start particle index. Size: numCloths.
        cloths:                          *PxParticleCloth; //!< The #PxParticleCloth s sorted by start particle index.

        remapOutputSize:                 PxU32; //!< Size of remapOutput.
        nbPartitions:                    PxU32; //!< The number of partitions.
        nbSprings:                       PxU32; //!< The number of springs.
        nbCloths:                        PxU32; //!< The number of cloths.
        maxSpringsPerPartition:          PxU32; //!< The maximum number of springs in a partition.

        mCudaManager:                    *PxCudaContextManager; //!< A cuda context manager.

        Constructor :: (this: *PxPartitionedParticleCloth) -> void #cpp_method #foreign physx_static "??0PxPartitionedParticleCloth@physx@@QEAA@XZ";
        Destructor :: (this: *PxPartitionedParticleCloth) -> void #cpp_method #foreign physx_static "??1PxPartitionedParticleCloth@physx@@QEAA@XZ";

        /*
        \brief allocate all the buffers for this #PxPartitionedParticleCloth.
        
        \param[in] nbParticles the number of particles this #PxPartitionedParticleCloth will be generated for.
        \param[in] cudaManager a cuda context manager.
        */
        allocateBuffers :: (this: *PxPartitionedParticleCloth, nbParticles: PxU32, cudaManager: *PxCudaContextManager) -> void #cpp_method #foreign physx_static "?allocateBuffers@PxPartitionedParticleCloth@physx@@QEAAXIPEAVPxCudaContextManager@2@@Z";
    }

    /*
    \brief A particle buffer used to simulate particle cloth.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    
    See #PxPhysics::createParticleClothBuffer.
    */
    PxParticleClothBuffer :: struct {
        #as using pxparticlebuffer: PxParticleBuffer;

        Constructor :: (this: *PxParticleClothBuffer, type: PxType) -> void #cpp_method #foreign physx_static "??0PxParticleClothBuffer@physx@@IEAA@G@Z";
        #place pxparticlebuffer; pxparticleclothbuffer_vtable: *PxParticleClothBuffer_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxParticleClothBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxParticleClothBuffer@physx@@MEAA@XZ";
    }
    PxParticleClothBuffer_VTable :: struct #type_info_none {
        using pxparticlebuffer: PxParticleBuffer_VTable;
        getRestPositions: (this: *PxParticleClothBuffer) -> *PxVec4 #cpp_method;

        getTriangles: (this: *PxParticleClothBuffer) -> *PxU32 #cpp_method;

        setNbTriangles: (this: *PxParticleClothBuffer, nbTriangles: PxU32) -> void #cpp_method;

        getNbTriangles: (this: *PxParticleClothBuffer) -> PxU32 #cpp_method;

        getNbSprings: (this: *PxParticleClothBuffer) -> PxU32 #cpp_method;

        getSprings: (this: *PxParticleClothBuffer) -> *PxParticleSpring #cpp_method;

        setCloths: (this: *PxParticleClothBuffer, cloths: *PxPartitionedParticleCloth) -> void #cpp_method;
    }

    PxParticleClothBuffer_getRestPositions :: inline (this: *PxParticleClothBuffer) -> *PxVec4 { return this.pxparticleclothbuffer_vtable.getRestPositions(this); }

    PxParticleClothBuffer_getTriangles :: inline (this: *PxParticleClothBuffer) -> *PxU32 { return this.pxparticleclothbuffer_vtable.getTriangles(this); }

    PxParticleClothBuffer_setNbTriangles :: inline (this: *PxParticleClothBuffer, nbTriangles: PxU32) { this.pxparticleclothbuffer_vtable.setNbTriangles(this, nbTriangles); }

    PxParticleClothBuffer_getNbTriangles :: inline (this: *PxParticleClothBuffer) -> PxU32 { return this.pxparticleclothbuffer_vtable.getNbTriangles(this); }

    PxParticleClothBuffer_getNbSprings :: inline (this: *PxParticleClothBuffer) -> PxU32 { return this.pxparticleclothbuffer_vtable.getNbSprings(this); }

    PxParticleClothBuffer_getSprings :: inline (this: *PxParticleClothBuffer) -> *PxParticleSpring { return this.pxparticleclothbuffer_vtable.getSprings(this); }

    PxParticleClothBuffer_setCloths :: inline (this: *PxParticleClothBuffer, cloths: *PxPartitionedParticleCloth) { this.pxparticleclothbuffer_vtable.setCloths(this, cloths); }

    vtable :: (obj: *PxParticleClothBuffer) -> *PxParticleClothBuffer_VTable { return obj.pxparticleclothbuffer_vtable; }


    /*
    \brief A particle buffer used to simulate rigid bodies using shape matching with particles.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    
    See #PxPhysics::createParticleRigidBuffer.
    */
    PxParticleRigidBuffer :: struct {
        #as using pxparticlebuffer: PxParticleBuffer;

        Constructor :: (this: *PxParticleRigidBuffer, type: PxType) -> void #cpp_method #foreign physx_static "??0PxParticleRigidBuffer@physx@@IEAA@G@Z";
        #place pxparticlebuffer; pxparticlerigidbuffer_vtable: *PxParticleRigidBuffer_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxParticleRigidBuffer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxParticleRigidBuffer@physx@@MEAA@XZ";
    }
    PxParticleRigidBuffer_VTable :: struct #type_info_none {
        using pxparticlebuffer: PxParticleBuffer_VTable;
        getRigidOffsets: (this: *PxParticleRigidBuffer) -> *PxU32 #cpp_method;

        getRigidCoefficients: (this: *PxParticleRigidBuffer) -> *PxReal #cpp_method;

        getRigidLocalPositions: (this: *PxParticleRigidBuffer) -> *PxVec4 #cpp_method;

        getRigidTranslations: (this: *PxParticleRigidBuffer) -> *PxVec4 #cpp_method;

        getRigidRotations: (this: *PxParticleRigidBuffer) -> *PxVec4 #cpp_method;

        getRigidLocalNormals: (this: *PxParticleRigidBuffer) -> *PxVec4 #cpp_method;

        setNbRigids: (this: *PxParticleRigidBuffer, nbRigids: PxU32) -> void #cpp_method;

        getNbRigids: (this: *PxParticleRigidBuffer) -> PxU32 #cpp_method;
    }

    PxParticleRigidBuffer_getRigidOffsets :: inline (this: *PxParticleRigidBuffer) -> *PxU32 { return this.pxparticlerigidbuffer_vtable.getRigidOffsets(this); }

    PxParticleRigidBuffer_getRigidCoefficients :: inline (this: *PxParticleRigidBuffer) -> *PxReal { return this.pxparticlerigidbuffer_vtable.getRigidCoefficients(this); }

    PxParticleRigidBuffer_getRigidLocalPositions :: inline (this: *PxParticleRigidBuffer) -> *PxVec4 { return this.pxparticlerigidbuffer_vtable.getRigidLocalPositions(this); }

    PxParticleRigidBuffer_getRigidTranslations :: inline (this: *PxParticleRigidBuffer) -> *PxVec4 { return this.pxparticlerigidbuffer_vtable.getRigidTranslations(this); }

    PxParticleRigidBuffer_getRigidRotations :: inline (this: *PxParticleRigidBuffer) -> *PxVec4 { return this.pxparticlerigidbuffer_vtable.getRigidRotations(this); }

    PxParticleRigidBuffer_getRigidLocalNormals :: inline (this: *PxParticleRigidBuffer) -> *PxVec4 { return this.pxparticlerigidbuffer_vtable.getRigidLocalNormals(this); }

    PxParticleRigidBuffer_setNbRigids :: inline (this: *PxParticleRigidBuffer, nbRigids: PxU32) { this.pxparticlerigidbuffer_vtable.setNbRigids(this, nbRigids); }

    PxParticleRigidBuffer_getNbRigids :: inline (this: *PxParticleRigidBuffer) -> PxU32 { return this.pxparticlerigidbuffer_vtable.getNbRigids(this); }

    vtable :: (obj: *PxParticleRigidBuffer) -> *PxParticleRigidBuffer_VTable { return obj.pxparticlerigidbuffer_vtable; }


    /*
    \brief Preprocessor to prepare particle cloths for simulation.
    
    \deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
    
    Preprocessing is done by calling #PxParticleClothPreProcessor::partitionSprings() on an instance of this class. This will allocate the memory in the
    output object, partition the springs and fill all the members of the ouput object. The output can then be passed without
    any further modifications to #PxParticleClothBuffer::setCloths().
    
    See #PxParticleClothDesc, #PxPartitionedParticleCloth
    */
    PxParticleClothPreProcessor :: struct {
        vtable: *PxParticleClothPreProcessor_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxParticleClothPreProcessor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxParticleClothPreProcessor@physx@@MEAA@XZ";
    }
    PxParticleClothPreProcessor_VTable :: struct #type_info_none {
        release: (this: *PxParticleClothPreProcessor) -> void #cpp_method;

        partitionSprings: (this: *PxParticleClothPreProcessor, clothDesc: *PxParticleClothDesc, output: *PxPartitionedParticleCloth) -> void #cpp_method;

        Destructor: (this: *PxParticleClothPreProcessor, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxParticleClothPreProcessor_release :: inline (this: *PxParticleClothPreProcessor) { this.vtable.release(this); }

    PxParticleClothPreProcessor_partitionSprings :: inline (this: *PxParticleClothPreProcessor, clothDesc: *PxParticleClothDesc, output: *PxPartitionedParticleCloth) { this.vtable.partitionSprings(this, clothDesc, output); }

    PxParticleClothPreProcessor_Destructor :: inline (this: *PxParticleClothPreProcessor, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxParticleClothPreProcessor) -> *PxParticleClothPreProcessor_VTable { return obj.vtable; }


    /*
    \deprecated This typedef only serves for deprecation and will be removed in a future version.
    */
    PxParticleMaterial :: PxPBDMaterial;

    /*
    \brief Material class to represent a set of PBD particle material properties.
    
    \see #PxPhysics.createPBDMaterial
    */
    PxPBDMaterial :: struct {
        #as using pxbasematerial: PxBaseMaterial;

        Constructor :: (this: *PxPBDMaterial, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxPBDMaterial@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxPBDMaterial, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxPBDMaterial@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbasematerial; pxpbdmaterial_vtable: *PxPBDMaterial_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxPBDMaterial) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxPBDMaterial@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxPBDMaterial, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxPBDMaterial@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxPBDMaterial, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxPBDMaterial@physx@@MEBA_NPEBD@Z";
    }
    PxPBDMaterial_VTable :: struct #type_info_none {
        using pxrefcounted: PxRefCounted_VTable;
        setFriction: (this: *PxPBDMaterial, friction: PxReal) -> void #cpp_method;

        getFriction: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setDamping: (this: *PxPBDMaterial, damping: PxReal) -> void #cpp_method;

        getDamping: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setAdhesion: (this: *PxPBDMaterial, adhesion: PxReal) -> void #cpp_method;

        getAdhesion: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setGravityScale: (this: *PxPBDMaterial, scale: PxReal) -> void #cpp_method;

        getGravityScale: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setAdhesionRadiusScale: (this: *PxPBDMaterial, scale: PxReal) -> void #cpp_method;

        getAdhesionRadiusScale: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setViscosity: (this: *PxPBDMaterial, viscosity: PxReal) -> void #cpp_method;

        getViscosity: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setVorticityConfinement: (this: *PxPBDMaterial, vorticityConfinement: PxReal) -> void #cpp_method;

        getVorticityConfinement: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setSurfaceTension: (this: *PxPBDMaterial, surfaceTension: PxReal) -> void #cpp_method;

        getSurfaceTension: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setCohesion: (this: *PxPBDMaterial, cohesion: PxReal) -> void #cpp_method;

        getCohesion: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setLift: (this: *PxPBDMaterial, lift: PxReal) -> void #cpp_method;

        getLift: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setDrag: (this: *PxPBDMaterial, drag: PxReal) -> void #cpp_method;

        getDrag: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setCFLCoefficient: (this: *PxPBDMaterial, coefficient: PxReal) -> void #cpp_method;

        getCFLCoefficient: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setParticleFrictionScale: (this: *PxPBDMaterial, scale: PxReal) -> void #cpp_method;

        getParticleFrictionScale: (this: *PxPBDMaterial) -> PxReal #cpp_method;

        setParticleAdhesionScale: (this: *PxPBDMaterial, adhesion: PxReal) -> void #cpp_method;

        getParticleAdhesionScale: (this: *PxPBDMaterial) -> PxReal #cpp_method;
    }

    PxPBDMaterial_setFriction :: inline (this: *PxPBDMaterial, friction: PxReal) { this.pxpbdmaterial_vtable.setFriction(this, friction); }

    PxPBDMaterial_getFriction :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getFriction(this); }

    PxPBDMaterial_setDamping :: inline (this: *PxPBDMaterial, damping: PxReal) { this.pxpbdmaterial_vtable.setDamping(this, damping); }

    PxPBDMaterial_getDamping :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getDamping(this); }

    PxPBDMaterial_setAdhesion :: inline (this: *PxPBDMaterial, adhesion: PxReal) { this.pxpbdmaterial_vtable.setAdhesion(this, adhesion); }

    PxPBDMaterial_getAdhesion :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getAdhesion(this); }

    PxPBDMaterial_setGravityScale :: inline (this: *PxPBDMaterial, scale: PxReal) { this.pxpbdmaterial_vtable.setGravityScale(this, scale); }

    PxPBDMaterial_getGravityScale :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getGravityScale(this); }

    PxPBDMaterial_setAdhesionRadiusScale :: inline (this: *PxPBDMaterial, scale: PxReal) { this.pxpbdmaterial_vtable.setAdhesionRadiusScale(this, scale); }

    PxPBDMaterial_getAdhesionRadiusScale :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getAdhesionRadiusScale(this); }

    PxPBDMaterial_setViscosity :: inline (this: *PxPBDMaterial, viscosity: PxReal) { this.pxpbdmaterial_vtable.setViscosity(this, viscosity); }

    PxPBDMaterial_getViscosity :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getViscosity(this); }

    PxPBDMaterial_setVorticityConfinement :: inline (this: *PxPBDMaterial, vorticityConfinement: PxReal) { this.pxpbdmaterial_vtable.setVorticityConfinement(this, vorticityConfinement); }

    PxPBDMaterial_getVorticityConfinement :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getVorticityConfinement(this); }

    PxPBDMaterial_setSurfaceTension :: inline (this: *PxPBDMaterial, surfaceTension: PxReal) { this.pxpbdmaterial_vtable.setSurfaceTension(this, surfaceTension); }

    PxPBDMaterial_getSurfaceTension :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getSurfaceTension(this); }

    PxPBDMaterial_setCohesion :: inline (this: *PxPBDMaterial, cohesion: PxReal) { this.pxpbdmaterial_vtable.setCohesion(this, cohesion); }

    PxPBDMaterial_getCohesion :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getCohesion(this); }

    PxPBDMaterial_setLift :: inline (this: *PxPBDMaterial, lift: PxReal) { this.pxpbdmaterial_vtable.setLift(this, lift); }

    PxPBDMaterial_getLift :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getLift(this); }

    PxPBDMaterial_setDrag :: inline (this: *PxPBDMaterial, drag: PxReal) { this.pxpbdmaterial_vtable.setDrag(this, drag); }

    PxPBDMaterial_getDrag :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getDrag(this); }

    PxPBDMaterial_setCFLCoefficient :: inline (this: *PxPBDMaterial, coefficient: PxReal) { this.pxpbdmaterial_vtable.setCFLCoefficient(this, coefficient); }

    PxPBDMaterial_getCFLCoefficient :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getCFLCoefficient(this); }

    PxPBDMaterial_setParticleFrictionScale :: inline (this: *PxPBDMaterial, scale: PxReal) { this.pxpbdmaterial_vtable.setParticleFrictionScale(this, scale); }

    PxPBDMaterial_getParticleFrictionScale :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getParticleFrictionScale(this); }

    PxPBDMaterial_setParticleAdhesionScale :: inline (this: *PxPBDMaterial, adhesion: PxReal) { this.pxpbdmaterial_vtable.setParticleAdhesionScale(this, adhesion); }

    PxPBDMaterial_getParticleAdhesionScale :: inline (this: *PxPBDMaterial) -> PxReal { return this.pxpbdmaterial_vtable.getParticleAdhesionScale(this); }

    vtable :: (obj: *PxPBDMaterial) -> *PxPBDMaterial_VTable { return obj.pxpbdmaterial_vtable; }


    PxOmniPvd :: struct {}

    /*
    \brief Abstract singleton factory class used for instancing objects in the Physics SDK.
    
    In addition you can use PxPhysics to set global parameters which will effect all scenes and create
    objects that can be shared across multiple scenes.
    
    You can get an instance of this class by calling PxCreatePhysics().
    
    \see PxCreatePhysics() PxScene
    */
    PxPhysics :: struct {
        vtable: *PxPhysics_VTable;
        /*
        \brief Creates a shape which may be attached to multiple actors
        
        The shape will be created with a reference count of 1.
        
        \param	[in] geometry		The geometry for the shape
        \param	[in] material		The material for the shape
        \param	[in] isExclusive	Whether this shape is exclusive to a single actor or maybe be shared
        \param	[in] shapeFlags		The PxShapeFlags to be set
        \return The shape
        
        \note Shared shapes are not mutable when they are attached to an actor
        
        \see PxShape
        */
        createShape :: (this: *PxPhysics, geometry: *PxGeometry, material: *PxMaterial, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #cpp_method #foreign physxcharacterkinematic_static "?createShape@PxPhysics@physx@@QEAAPEAVPxShape@2@AEBVPxGeometry@2@AEBVPxMaterial@2@_NV?$PxFlags@W4Enum@PxShapeFlag@physx@@E@2@@Z";
        createShape :: (this: *PxPhysics, geometry: PxGeometry, material: PxMaterial, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #no_context {
            return createShape(this, *geometry, *material, isExclusive, shapeFlags);
        }

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        /* \name Basics
        */
        //\{
        virtual_Destructor :: (this: *PxPhysics, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxPhysics@physx@@UEAA@XZ";
    }
    PxPhysics_VTable :: struct #type_info_none {
        Destructor: (this: *PxPhysics, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        release: (this: *PxPhysics) -> void #cpp_method;

        getFoundation: (this: *PxPhysics) -> *PxFoundation #cpp_method;

        getOmniPvd: (this: *PxPhysics) -> *PxOmniPvd #cpp_method;

        createAggregate: (this: *PxPhysics, maxActor: PxU32, maxShape: PxU32, filterHint: PxAggregateFilterHint) -> *PxAggregate #cpp_method;

        getTolerancesScale: (this: *PxPhysics) -> *PxTolerancesScale #cpp_method;

        createTriangleMesh: (this: *PxPhysics, stream: *PxInputStream) -> *PxTriangleMesh #cpp_method;

        getNbTriangleMeshes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getTriangleMeshes: (this: *PxPhysics, userBuffer: **PxTriangleMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createTetrahedronMesh: (this: *PxPhysics, stream: *PxInputStream) -> *PxTetrahedronMesh #cpp_method;

        createSoftBodyMesh: (this: *PxPhysics, stream: *PxInputStream) -> *PxSoftBodyMesh #cpp_method;

        getNbTetrahedronMeshes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getTetrahedronMeshes: (this: *PxPhysics, userBuffer: **PxTetrahedronMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createHeightField: (this: *PxPhysics, stream: *PxInputStream) -> *PxHeightField #cpp_method;

        getNbHeightFields: (this: *PxPhysics) -> PxU32 #cpp_method;

        getHeightFields: (this: *PxPhysics, userBuffer: **PxHeightField, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createConvexMesh: (this: *PxPhysics, stream: *PxInputStream) -> *PxConvexMesh #cpp_method;

        getNbConvexMeshes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getConvexMeshes: (this: *PxPhysics, userBuffer: **PxConvexMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createBVH: (this: *PxPhysics, stream: *PxInputStream) -> *PxBVH #cpp_method;

        getNbBVHs: (this: *PxPhysics) -> PxU32 #cpp_method;

        getBVHs: (this: *PxPhysics, userBuffer: **PxBVH, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createScene: (this: *PxPhysics, sceneDesc: *PxSceneDesc) -> *PxScene #cpp_method;

        getNbScenes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getScenes: (this: *PxPhysics, userBuffer: **PxScene, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createRigidStatic: (this: *PxPhysics, pose: *PxTransform) -> *PxRigidStatic #cpp_method;

        createRigidDynamic: (this: *PxPhysics, pose: *PxTransform) -> *PxRigidDynamic #cpp_method;

        createPruningStructure: (this: *PxPhysics, actors: **PxRigidActor, nbActors: PxU32) -> *PxPruningStructure #cpp_method;

        createShape: (this: *PxPhysics, geometry: *PxGeometry, materials: **PxFEMClothMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #cpp_method;

        createShape_1: (this: *PxPhysics, geometry: /*const reference*/ *PxGeometry, materials: /*const*/ **PxFEMSoftBodyMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #cpp_method;

        createShape_2: (this: *PxPhysics, geometry: /*const reference*/ *PxGeometry, materials: /*const*/ **PxMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape #cpp_method;

        getNbShapes: (this: *PxPhysics) -> PxU32 #cpp_method;

        getShapes: (this: *PxPhysics, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createConstraint: (this: *PxPhysics, actor0: *PxRigidActor, actor1: *PxRigidActor, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable, dataSize: PxU32) -> *PxConstraint #cpp_method;

        createArticulationReducedCoordinate: (this: *PxPhysics) -> *PxArticulationReducedCoordinate #cpp_method;

        createFEMCloth: (this: *PxPhysics, cudaContextManager: *PxCudaContextManager) -> *PxFEMCloth #cpp_method;

        createSoftBody: (this: *PxPhysics, cudaContextManager: *PxCudaContextManager) -> *PxSoftBody #cpp_method;

        createHairSystem: (this: *PxPhysics, cudaContextManager: *PxCudaContextManager) -> *PxHairSystem #cpp_method;

        createPBDParticleSystem: (this: *PxPhysics, cudaContextManager: *PxCudaContextManager, maxNeighborhood: PxU32 = 96, neighborhoodScale: PxReal = 1.01) -> *PxPBDParticleSystem #cpp_method;

        createParticleBuffer: (this: *PxPhysics, maxParticles: PxU32, maxVolumes: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleBuffer #cpp_method;

        createParticleAndDiffuseBuffer: (this: *PxPhysics, maxParticles: PxU32, maxVolumes: PxU32, maxDiffuseParticles: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleAndDiffuseBuffer #cpp_method;

        createParticleClothBuffer: (this: *PxPhysics, maxParticles: PxU32, maxNumVolumes: PxU32, maxNumCloths: PxU32, maxNumTriangles: PxU32, maxNumSprings: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleClothBuffer #cpp_method;

        createParticleRigidBuffer: (this: *PxPhysics, maxParticles: PxU32, maxNumVolumes: PxU32, maxNumRigids: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleRigidBuffer #cpp_method;

        createMaterial: (this: *PxPhysics, staticFriction: PxReal, dynamicFriction: PxReal, restitution: PxReal) -> *PxMaterial #cpp_method;

        getNbMaterials: (this: *PxPhysics) -> PxU32 #cpp_method;

        getMaterials: (this: *PxPhysics, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createFEMSoftBodyMaterial: (this: *PxPhysics, youngs: PxReal, poissons: PxReal, dynamicFriction: PxReal) -> *PxFEMSoftBodyMaterial #cpp_method;

        getNbFEMSoftBodyMaterials: (this: *PxPhysics) -> PxU32 #cpp_method;

        getFEMSoftBodyMaterials: (this: *PxPhysics, userBuffer: **PxFEMSoftBodyMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createFEMClothMaterial: (this: *PxPhysics, youngs: PxReal, poissons: PxReal, dynamicFriction: PxReal, thickness: PxReal = 0.001) -> *PxFEMClothMaterial #cpp_method;

        getNbFEMClothMaterials: (this: *PxPhysics) -> PxU32 #cpp_method;

        getFEMClothMaterials: (this: *PxPhysics, userBuffer: **PxFEMClothMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        createPBDMaterial: (this: *PxPhysics, friction: PxReal, damping: PxReal, adhesion: PxReal, viscosity: PxReal, vorticityConfinement: PxReal, surfaceTension: PxReal, cohesion: PxReal, lift: PxReal, drag: PxReal, cflCoefficient: PxReal = 1.0, gravityScale: PxReal = 1.0) -> *PxPBDMaterial #cpp_method;

        getNbPBDMaterials: (this: *PxPhysics) -> PxU32 #cpp_method;

        getPBDMaterials: (this: *PxPhysics, userBuffer: **PxPBDMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        registerDeletionListener: (this: *PxPhysics, observer: *PxDeletionListener, deletionEvents: *PxDeletionEventFlags, restrictedObjectSet := false) -> void #cpp_method;

        unregisterDeletionListener: (this: *PxPhysics, observer: *PxDeletionListener) -> void #cpp_method;

        registerDeletionListenerObjects: (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) -> void #cpp_method;

        unregisterDeletionListenerObjects: (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) -> void #cpp_method;

        getPhysicsInsertionCallback: (this: *PxPhysics) -> *PxInsertionCallback #cpp_method;
    }

    PxPhysics_Destructor :: inline (this: *PxPhysics, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxPhysics_release :: inline (this: *PxPhysics) { this.vtable.release(this); }

    PxPhysics_getFoundation :: inline (this: *PxPhysics) -> *PxFoundation { return this.vtable.getFoundation(this); }

    PxPhysics_getOmniPvd :: inline (this: *PxPhysics) -> *PxOmniPvd { return this.vtable.getOmniPvd(this); }

    PxPhysics_createAggregate :: inline (this: *PxPhysics, maxActor: PxU32, maxShape: PxU32, filterHint: PxAggregateFilterHint) -> *PxAggregate { return this.vtable.createAggregate(this, maxActor, maxShape, filterHint); }

    PxPhysics_getTolerancesScale :: inline (this: *PxPhysics) -> *PxTolerancesScale { return this.vtable.getTolerancesScale(this); }

    PxPhysics_createTriangleMesh :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxTriangleMesh { return this.vtable.createTriangleMesh(this, stream); }

    PxPhysics_getNbTriangleMeshes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbTriangleMeshes(this); }

    PxPhysics_getTriangleMeshes :: inline (this: *PxPhysics, userBuffer: **PxTriangleMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getTriangleMeshes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createTetrahedronMesh :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxTetrahedronMesh { return this.vtable.createTetrahedronMesh(this, stream); }

    PxPhysics_createSoftBodyMesh :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxSoftBodyMesh { return this.vtable.createSoftBodyMesh(this, stream); }

    PxPhysics_getNbTetrahedronMeshes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbTetrahedronMeshes(this); }

    PxPhysics_getTetrahedronMeshes :: inline (this: *PxPhysics, userBuffer: **PxTetrahedronMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getTetrahedronMeshes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createHeightField :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxHeightField { return this.vtable.createHeightField(this, stream); }

    PxPhysics_getNbHeightFields :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbHeightFields(this); }

    PxPhysics_getHeightFields :: inline (this: *PxPhysics, userBuffer: **PxHeightField, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getHeightFields(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createConvexMesh :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxConvexMesh { return this.vtable.createConvexMesh(this, stream); }

    PxPhysics_getNbConvexMeshes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbConvexMeshes(this); }

    PxPhysics_getConvexMeshes :: inline (this: *PxPhysics, userBuffer: **PxConvexMesh, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getConvexMeshes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createBVH :: inline (this: *PxPhysics, stream: *PxInputStream) -> *PxBVH { return this.vtable.createBVH(this, stream); }

    PxPhysics_getNbBVHs :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbBVHs(this); }

    PxPhysics_getBVHs :: inline (this: *PxPhysics, userBuffer: **PxBVH, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getBVHs(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createScene :: inline (this: *PxPhysics, sceneDesc: *PxSceneDesc) -> *PxScene { return this.vtable.createScene(this, sceneDesc); }

    PxPhysics_getNbScenes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbScenes(this); }

    PxPhysics_getScenes :: inline (this: *PxPhysics, userBuffer: **PxScene, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getScenes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createRigidStatic :: inline (this: *PxPhysics, pose: *PxTransform) -> *PxRigidStatic { return this.vtable.createRigidStatic(this, pose); }

    PxPhysics_createRigidDynamic :: inline (this: *PxPhysics, pose: *PxTransform) -> *PxRigidDynamic { return this.vtable.createRigidDynamic(this, pose); }

    PxPhysics_createPruningStructure :: inline (this: *PxPhysics, actors: **PxRigidActor, nbActors: PxU32) -> *PxPruningStructure { return this.vtable.createPruningStructure(this, actors, nbActors); }

    PxPhysics_createShape :: inline (this: *PxPhysics, geometry: /*const reference*/ *PxGeometry, materials: /*const*/ **PxFEMClothMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape { return this.vtable.createShape(this, geometry, materials, materialCount, isExclusive, shapeFlags); }

    PxPhysics_createShape_1 :: inline (this: *PxPhysics, geometry: /*const reference*/ *PxGeometry, materials: /*const*/ **PxFEMSoftBodyMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape { return this.vtable.createShape_1(this, geometry, materials, materialCount, isExclusive, shapeFlags); }

    PxPhysics_createShape_2 :: inline (this: *PxPhysics, geometry: /*const reference*/ *PxGeometry, materials: /*const*/ **PxMaterial, materialCount: PxU16, isExclusive := false, shapeFlags: PxShapeFlags) -> *PxShape { return this.vtable.createShape_2(this, geometry, materials, materialCount, isExclusive, shapeFlags); }

    PxPhysics_getNbShapes :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbShapes(this); }

    PxPhysics_getShapes :: inline (this: *PxPhysics, userBuffer: **PxShape, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getShapes(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createConstraint :: inline (this: *PxPhysics, actor0: *PxRigidActor, actor1: *PxRigidActor, connector: *PxConstraintConnector, shaders: *PxConstraintShaderTable, dataSize: PxU32) -> *PxConstraint { return this.vtable.createConstraint(this, actor0, actor1, connector, shaders, dataSize); }

    PxPhysics_createArticulationReducedCoordinate :: inline (this: *PxPhysics) -> *PxArticulationReducedCoordinate { return this.vtable.createArticulationReducedCoordinate(this); }

    PxPhysics_createFEMCloth :: inline (this: *PxPhysics, cudaContextManager: *PxCudaContextManager) -> *PxFEMCloth { return this.vtable.createFEMCloth(this, cudaContextManager); }

    PxPhysics_createSoftBody :: inline (this: *PxPhysics, cudaContextManager: *PxCudaContextManager) -> *PxSoftBody { return this.vtable.createSoftBody(this, cudaContextManager); }

    PxPhysics_createHairSystem :: inline (this: *PxPhysics, cudaContextManager: *PxCudaContextManager) -> *PxHairSystem { return this.vtable.createHairSystem(this, cudaContextManager); }

    PxPhysics_createPBDParticleSystem :: inline (this: *PxPhysics, cudaContextManager: *PxCudaContextManager, maxNeighborhood: PxU32 = 96, neighborhoodScale: PxReal = 1.01) -> *PxPBDParticleSystem { return this.vtable.createPBDParticleSystem(this, cudaContextManager, maxNeighborhood, neighborhoodScale); }

    PxPhysics_createParticleBuffer :: inline (this: *PxPhysics, maxParticles: PxU32, maxVolumes: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleBuffer { return this.vtable.createParticleBuffer(this, maxParticles, maxVolumes, cudaContextManager); }

    PxPhysics_createParticleAndDiffuseBuffer :: inline (this: *PxPhysics, maxParticles: PxU32, maxVolumes: PxU32, maxDiffuseParticles: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleAndDiffuseBuffer { return this.vtable.createParticleAndDiffuseBuffer(this, maxParticles, maxVolumes, maxDiffuseParticles, cudaContextManager); }

    PxPhysics_createParticleClothBuffer :: inline (this: *PxPhysics, maxParticles: PxU32, maxNumVolumes: PxU32, maxNumCloths: PxU32, maxNumTriangles: PxU32, maxNumSprings: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleClothBuffer { return this.vtable.createParticleClothBuffer(this, maxParticles, maxNumVolumes, maxNumCloths, maxNumTriangles, maxNumSprings, cudaContextManager); }

    PxPhysics_createParticleRigidBuffer :: inline (this: *PxPhysics, maxParticles: PxU32, maxNumVolumes: PxU32, maxNumRigids: PxU32, cudaContextManager: *PxCudaContextManager) -> *PxParticleRigidBuffer { return this.vtable.createParticleRigidBuffer(this, maxParticles, maxNumVolumes, maxNumRigids, cudaContextManager); }

    PxPhysics_createMaterial :: inline (this: *PxPhysics, staticFriction: PxReal, dynamicFriction: PxReal, restitution: PxReal) -> *PxMaterial { return this.vtable.createMaterial(this, staticFriction, dynamicFriction, restitution); }

    PxPhysics_getNbMaterials :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbMaterials(this); }

    PxPhysics_getMaterials :: inline (this: *PxPhysics, userBuffer: **PxMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getMaterials(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createFEMSoftBodyMaterial :: inline (this: *PxPhysics, youngs: PxReal, poissons: PxReal, dynamicFriction: PxReal) -> *PxFEMSoftBodyMaterial { return this.vtable.createFEMSoftBodyMaterial(this, youngs, poissons, dynamicFriction); }

    PxPhysics_getNbFEMSoftBodyMaterials :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbFEMSoftBodyMaterials(this); }

    PxPhysics_getFEMSoftBodyMaterials :: inline (this: *PxPhysics, userBuffer: **PxFEMSoftBodyMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getFEMSoftBodyMaterials(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createFEMClothMaterial :: inline (this: *PxPhysics, youngs: PxReal, poissons: PxReal, dynamicFriction: PxReal, thickness: PxReal = 0.001) -> *PxFEMClothMaterial { return this.vtable.createFEMClothMaterial(this, youngs, poissons, dynamicFriction, thickness); }

    PxPhysics_getNbFEMClothMaterials :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbFEMClothMaterials(this); }

    PxPhysics_getFEMClothMaterials :: inline (this: *PxPhysics, userBuffer: **PxFEMClothMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getFEMClothMaterials(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_createPBDMaterial :: inline (this: *PxPhysics, friction: PxReal, damping: PxReal, adhesion: PxReal, viscosity: PxReal, vorticityConfinement: PxReal, surfaceTension: PxReal, cohesion: PxReal, lift: PxReal, drag: PxReal, cflCoefficient: PxReal = 1.0, gravityScale: PxReal = 1.0) -> *PxPBDMaterial { return this.vtable.createPBDMaterial(this, friction, damping, adhesion, viscosity, vorticityConfinement, surfaceTension, cohesion, lift, drag, cflCoefficient, gravityScale); }

    PxPhysics_getNbPBDMaterials :: inline (this: *PxPhysics) -> PxU32 { return this.vtable.getNbPBDMaterials(this); }

    PxPhysics_getPBDMaterials :: inline (this: *PxPhysics, userBuffer: **PxPBDMaterial, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getPBDMaterials(this, userBuffer, bufferSize, startIndex); }

    PxPhysics_registerDeletionListener :: inline (this: *PxPhysics, observer: *PxDeletionListener, deletionEvents: *PxDeletionEventFlags, restrictedObjectSet := false) { this.vtable.registerDeletionListener(this, observer, deletionEvents, restrictedObjectSet); }

    PxPhysics_unregisterDeletionListener :: inline (this: *PxPhysics, observer: *PxDeletionListener) { this.vtable.unregisterDeletionListener(this, observer); }

    PxPhysics_registerDeletionListenerObjects :: inline (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) { this.vtable.registerDeletionListenerObjects(this, observer, observables, observableCount); }

    PxPhysics_unregisterDeletionListenerObjects :: inline (this: *PxPhysics, observer: *PxDeletionListener, observables: **PxBase, observableCount: PxU32) { this.vtable.unregisterDeletionListenerObjects(this, observer, observables, observableCount); }

    PxPhysics_getPhysicsInsertionCallback :: inline (this: *PxPhysics) -> *PxInsertionCallback { return this.vtable.getPhysicsInsertionCallback(this); }

    vtable :: (obj: *PxPhysics) -> *PxPhysics_VTable { return obj.vtable; }


    /*
    \brief Combines a shape pointer and the actor the shape belongs to into one memory location.
    
    Serves as a base class for PxQueryHit.
    
    \see PxQueryHit
    */
    PxActorShape :: struct {
        Constructor :: (this: *PxActorShape) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxActorShape@physx@@QEAA@XZ";

        actor: *PxRigidActor;
        shape: *PxShape;
    }

    // Extends geom hits with Px object pointers
    PxRaycastHit :: struct {
        #as using pxgeomraycasthit: PxGeomRaycastHit;
        #as using pxactorshape: PxActorShape;
    }
    PxOverlapHit :: struct {
        #as using pxgeomoverlaphit: PxGeomOverlapHit;
        #as using pxactorshape: PxActorShape;
    }
    PxSweepHit :: struct {
        #as using pxgeomsweephit: PxGeomSweepHit;
        #as using pxactorshape: PxActorShape;
    }

    /*
    \brief Describes query behavior after returning a partial query result via a callback.
    
    If callback returns true, traversal will continue and callback can be issued again.
    If callback returns false, traversal will stop, callback will not be issued again.
    
    \see PxHitCallback
    */
    PxAgain :: bool;

    /*
    \brief	This callback class facilitates reporting scene query hits (intersections) to the user.
    
    User overrides the virtual processTouches function to receive hits in (possibly multiple) fixed size blocks.
    
    \note	PxHitBuffer derives from this class and is used to receive touching hits in a fixed size buffer.
    \note	Since the compiler doesn't look in template dependent base classes when looking for non-dependent names
    \note	with some compilers it will be necessary to use "this->hasBlock" notation to access a parent variable
    \note	in a child callback class.
    \note	Pre-made typedef shorthands, such as ::PxRaycastCallback can be used for raycast, overlap and sweep queries.
    
    \see PxHitBuffer PxRaycastHit PxSweepHit PxOverlapHit PxRaycastCallback PxOverlapCallback PxSweepCallback
    */
    PxHitCallback :: struct(HitType: Type) {
        #as pxquerythreadcontext: PxQueryThreadContext; // jai: no "using" to avoid name-clashes

        block:        HitType; //!< Holds the closest blocking hit result for the query. Invalid if hasBlock is false.
        hasBlock:     bool; //!< Set to true if there was a blocking hit during query.

        touches:      *HitType; //!< User specified buffer for touching hits.

        /*
        \brief	Size of the user specified touching hits buffer.
        \note	If set to 0 all hits will default to PxQueryHitType::eBLOCK, otherwise to PxQueryHitType::eTOUCH
        \note	Hit type returned from pre-filter overrides this default */
        maxNbTouches: PxU32;

        /*
        \brief	Number of touching hits returned by the query. Used with PxHitBuffer.
        \note	If true (PxAgain) is returned from the callback, nbTouches will be reset to 0. */
        nbTouches:    PxU32;
    }

    /*
    \brief	Returns scene query hits (intersections) to the user in a preallocated buffer.
    
    Will clip touch hits to maximum buffer capacity. When clipped, an arbitrary subset of touching hits will be discarded.
    Overflow does not trigger warnings or errors. block and hasBlock will be valid in finalizeQuery callback and after query completion.
    Touching hits are guaranteed to have closer or same distance ( <= condition) as the globally nearest blocking hit at the time any processTouches()
    callback is issued.
    
    \note	Pre-made typedef shorthands, such as ::PxRaycastBuffer can be used for raycast, overlap and sweep queries.
    
    \see PxHitCallback
    \see PxRaycastBuffer PxOverlapBuffer PxSweepBuffer PxRaycastBufferN PxOverlapBufferN PxSweepBufferN
    */
    PxHitBuffer :: struct(HitType: Type) {
        #as pxhitcallback: PxHitCallback(HitType); // jai: no "using" to avoid name-clashes
    }

    /* \brief Raycast query callback. */
    PxRaycastCallback :: PxHitCallback(PxRaycastHit);

    /* \brief Overlap query callback. */
    PxOverlapCallback :: PxHitCallback(PxOverlapHit);

    /* \brief Sweep query callback. */
    PxSweepCallback :: PxHitCallback(PxSweepHit);

    /* \brief Raycast query buffer. */
    PxRaycastBuffer :: PxHitBuffer(PxRaycastHit);

    /* \brief Overlap query buffer. */
    PxOverlapBuffer :: PxHitBuffer(PxOverlapHit);

    /* \brief Sweep query buffer. */
    PxSweepBuffer :: PxHitBuffer(PxSweepHit);

    /* \brief	Returns touching raycast hits to the user in a fixed size array embedded in the buffer class. **/
    PxRaycastBufferN :: struct(N: s32) {
        #as pxhitbuffer: PxHitBuffer(PxRaycastHit); // jai: no "using" to avoid name-clashes

        hits: [PxRaycastHit] PxRaycastHit;
    }

    /* \brief	Returns touching overlap hits to the user in a fixed size array embedded in the buffer class. **/
    PxOverlapBufferN :: struct(N: s32) {
        #as pxhitbuffer: PxHitBuffer(PxOverlapHit); // jai: no "using" to avoid name-clashes

        hits: [PxOverlapHit] PxOverlapHit;
    }

    /* \brief	Returns touching sweep hits to the user in a fixed size array embedded in the buffer class. **/
    PxSweepBufferN :: struct(N: s32) {
        #as pxhitbuffer: PxHitBuffer(PxSweepHit); // jai: no "using" to avoid name-clashes

        hits: [PxSweepHit] PxSweepHit;
    }

    /*
    \brief single hit cache for scene queries.
    
    If a cache object is supplied to a scene query, the cached actor/shape pair is checked for intersection first.
    \note Filters are not executed for the cached shape.
    \note If intersection is found, the hit is treated as blocking.
    \note Typically actor and shape from the last PxHitCallback.block query result is used as a cached actor/shape pair.
    \note Using past touching hits as cache will produce incorrect behavior since the cached hit will always be treated as blocking.
    \note Cache is only used if no touch buffer was provided, for single nearest blocking hit queries and queries using eANY_HIT flag.
    \note if non-zero touch buffer was provided, cache will be ignored
    
    \note It is the user's responsibility to ensure that the shape and actor are valid, so care must be taken
    when deleting shapes to invalidate cached references.
    
    The faceIndex field is an additional hint for a mesh or height field which is not currently used.
    
    \see PxScene.raycast
    */
    PxQueryCache :: struct {
        shape:     *PxShape; //!< Shape to test for intersection first
        actor:     *PxRigidActor; //!< Actor to which the shape belongs
        faceIndex: PxU32; //!< Triangle index to test first - NOT CURRENTLY SUPPORTED
    }

    /*
    \brief Filtering flags for scene queries.
    
    \see PxQueryFilterData.flags
    */
    PxQueryFlag :: struct {
        Enum :: enum s32 {
            STATIC                       :: 1;

            DYNAMIC                      :: 2;

            PREFILTER                    :: 4;

            POSTFILTER                   :: 8;

            ANY_HIT                      :: 16;

            NO_BLOCK                     :: 32;

            BATCH_QUERY_LEGACY_BEHAVIOUR :: 64;

            DISABLE_HARDCODED_FILTER     :: 64;

            RESERVED                     :: 32768;

            eSTATIC                       :: STATIC;

            eDYNAMIC                      :: DYNAMIC;

            ePREFILTER                    :: PREFILTER;

            ePOSTFILTER                   :: POSTFILTER;

            eANY_HIT                      :: ANY_HIT;

            eNO_BLOCK                     :: NO_BLOCK;

            eBATCH_QUERY_LEGACY_BEHAVIOUR :: BATCH_QUERY_LEGACY_BEHAVIOUR;

            eDISABLE_HARDCODED_FILTER     :: DISABLE_HARDCODED_FILTER;

            eRESERVED                     :: RESERVED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Flags typedef for the set of bits defined in PxQueryFlag.
    
    */
    PxQueryFlags :: PxFlags(PxQueryFlag.Enum, PxU16);
    operator| :: (a: PxQueryFlag.Enum, b: PxQueryFlag.Enum) -> PxFlags(PxQueryFlag.Enum, PxU16) #foreign physxcharacterkinematic_static "??Uphysx@@YA?AV?$PxFlags@W4Enum@PxQueryFlag@physx@@G@0@W4Enum@PxQueryFlag@0@0@Z";

    /*
    \brief Classification of scene query hits (intersections).
    
    - eNONE: Returning this hit type means that the hit should not be reported.
    - eBLOCK: For all raycast, sweep and overlap queries the nearest eBLOCK type hit will always be returned in PxHitCallback::block member.
    - eTOUCH: Whenever a raycast, sweep or overlap query was called with non-zero PxHitCallback::nbTouches and PxHitCallback::touches
    parameters, eTOUCH type hits that are closer or same distance (touchDistance <= blockDistance condition)
    as the globally nearest eBLOCK type hit, will be reported.
    - For example, to record all hits from a raycast query, always return eTOUCH.
    
    All hits in overlap() queries are treated as if the intersection distance were zero.
    This means the hits are unsorted and all eTOUCH hits are recorded by the callback even if an eBLOCK overlap hit was encountered.
    Even though all overlap() blocking hits have zero length, only one (arbitrary) eBLOCK overlap hit is recorded in PxHitCallback::block.
    All overlap() eTOUCH type hits are reported (zero touchDistance <= zero blockDistance condition).
    
    For raycast/sweep/overlap calls with zero touch buffer or PxHitCallback::nbTouches member,
    only the closest hit of type eBLOCK is returned. All eTOUCH hits are discarded.
    
    \see PxQueryFilterCallback.preFilter PxQueryFilterCallback.postFilter PxScene.raycast PxScene.sweep PxScene.overlap
    */
    PxQueryHitType :: struct {
        Enum :: enum s32 {
            NONE  :: 0;
            TOUCH :: 1;
            BLOCK :: 2;

            eNONE  :: NONE;
            eTOUCH :: TOUCH;
            eBLOCK :: BLOCK;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Scene query filtering data.
    
    Whenever the scene query intersects a shape, filtering is performed in the following order:
    
    \li For non-batched queries only:<br>If the data field is non-zero, and the bitwise-AND value of data AND the shape's
    queryFilterData is zero, the shape is skipped
    \li If filter callbacks are enabled in flags field (see #PxQueryFlags) they will get invoked accordingly.
    \li If neither #PxQueryFlag::ePREFILTER or #PxQueryFlag::ePOSTFILTER is set, the hit defaults
    to type #PxQueryHitType::eBLOCK when the value of PxHitCallback::nbTouches provided with the query is zero and to type
    #PxQueryHitType::eTOUCH when PxHitCallback::nbTouches is positive.
    
    \see PxScene.raycast PxScene.sweep PxScene.overlap PxQueryFlag::eANY_HIT
    */
    PxQueryFilterData :: struct {
        /* \brief constructor to set both filter data and filter flags */
        Constructor :: (this: *PxQueryFilterData, fd: *PxFilterData, f: PxQueryFlags) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxQueryFilterData@physx@@QEAA@AEBUPxFilterData@1@V?$PxFlags@W4Enum@PxQueryFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxQueryFilterData, fd: PxFilterData, f: PxQueryFlags) #no_context {
            Constructor(this, *fd, f);
        }

        /* \brief constructor to set filter flags only */
        Constructor :: (this: *PxQueryFilterData, f: PxQueryFlags) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxQueryFilterData@physx@@QEAA@V?$PxFlags@W4Enum@PxQueryFlag@physx@@G@1@@Z";

        data:  PxFilterData; //!< Filter data associated with the scene query
        flags: PxQueryFlags; //!< Filter flags (see #PxQueryFlags)
    }

    /*
    \brief Scene query filtering callbacks.
    
    Custom filtering logic for scene query intersection candidates. If an intersection candidate object passes the data based filter
    (see #PxQueryFilterData), filtering callbacks are executed if requested (see #PxQueryFilterData.flags)
    
    \li If #PxQueryFlag::ePREFILTER is set, the preFilter function runs before exact intersection tests.
    If this function returns #PxQueryHitType::eTOUCH or #PxQueryHitType::eBLOCK, exact testing is performed to
    determine the intersection location.
    
    The preFilter function may overwrite the copy of queryFlags it receives as an argument to specify any of #PxHitFlag::eMODIFIABLE_FLAGS
    on a per-shape basis. Changes apply only to the shape being filtered, and changes to other flags are ignored.
    
    \li If #PxQueryFlag::ePREFILTER is not set, precise intersection testing is performed using the original query's filterData.flags.
    
    \li If #PxQueryFlag::ePOSTFILTER is set, the postFilter function is called for each intersection to determine the touch/block status.
    This overrides any touch/block status previously returned from the preFilter function for this shape.
    
    Filtering calls are not guaranteed to be sorted along the ray or sweep direction.
    
    \see PxScene.raycast PxScene.sweep PxScene.overlap PxQueryFlags PxHitFlags
    */
    PxQueryFilterCallback :: struct {
        vtable: *PxQueryFilterCallback_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        /*
        \brief virtual destructor
        */
        virtual_Destructor :: (this: *PxQueryFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxQueryFilterCallback@physx@@UEAA@XZ";
    }
    PxQueryFilterCallback_VTable :: struct #type_info_none {
        preFilter: (this: *PxQueryFilterCallback, filterData: *PxFilterData, shape: *PxShape, actor: *PxRigidActor, queryFlags: *PxHitFlags) -> PxQueryHitType.Enum #cpp_method;

        postFilter: (this: *PxQueryFilterCallback, filterData: *PxFilterData, hit: *PxQueryHit, shape: *PxShape, actor: *PxRigidActor) -> PxQueryHitType.Enum #cpp_method;

        Destructor: (this: *PxQueryFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxQueryFilterCallback_preFilter :: inline (this: *PxQueryFilterCallback, filterData: *PxFilterData, shape: *PxShape, actor: *PxRigidActor, queryFlags: *PxHitFlags) -> PxQueryHitType.Enum { return this.vtable.preFilter(this, filterData, shape, actor, queryFlags); }

    PxQueryFilterCallback_postFilter :: inline (this: *PxQueryFilterCallback, filterData: *PxFilterData, hit: *PxQueryHit, shape: *PxShape, actor: *PxRigidActor) -> PxQueryHitType.Enum { return this.vtable.postFilter(this, filterData, hit, shape, actor); }

    PxQueryFilterCallback_Destructor :: inline (this: *PxQueryFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxQueryFilterCallback) -> *PxQueryFilterCallback_VTable { return obj.vtable; }


    /*
    \brief Collection of flags providing a mechanism to lock motion along/around a specific axis.
    
    \see PxRigidDynamic.setRigidDynamicLockFlag(), PxRigidBody.getRigidDynamicLockFlags()
    */
    PxRigidDynamicLockFlag :: struct {
        Enum :: enum s32 {
            LINEAR_X  :: 1;
            LINEAR_Y  :: 2;
            LINEAR_Z  :: 4;
            ANGULAR_X :: 8;
            ANGULAR_Y :: 16;
            ANGULAR_Z :: 32;

            eLOCK_LINEAR_X  :: LINEAR_X;
            eLOCK_LINEAR_Y  :: LINEAR_Y;
            eLOCK_LINEAR_Z  :: LINEAR_Z;
            eLOCK_ANGULAR_X :: ANGULAR_X;
            eLOCK_ANGULAR_Y :: ANGULAR_Y;
            eLOCK_ANGULAR_Z :: ANGULAR_Z;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxRigidDynamicLockFlags :: PxFlags(PxRigidDynamicLockFlag.Enum, PxU8);
    operator~ :: (a: PxRigidDynamicLockFlag.Enum) -> PxFlags(PxRigidDynamicLockFlag.Enum, PxU8) #foreign physx_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxRigidDynamicLockFlag@physx@@E@0@W4Enum@PxRigidDynamicLockFlag@0@@Z";

    /*
    \brief PxRigidDynamic represents a dynamic rigid simulation object in the physics SDK.
    
    <h3>Creation</h3>
    Instances of this class are created by calling #PxPhysics::createRigidDynamic() and deleted with #release().
    
    <h3>Visualizations</h3>
    \li #PxVisualizationParameter::eACTOR_AXES
    \li #PxVisualizationParameter::eBODY_AXES
    \li #PxVisualizationParameter::eBODY_MASS_AXES
    \li #PxVisualizationParameter::eBODY_LIN_VELOCITY
    \li #PxVisualizationParameter::eBODY_ANG_VELOCITY
    
    \see PxRigidBody  PxPhysics.createRigidDynamic()  release()
    */
    PxRigidDynamic :: struct {
        #as using pxrigidbody: PxRigidBody;

        Constructor :: (this: *PxRigidDynamic, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidDynamic@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxRigidDynamic, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidDynamic@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxrigidbody; pxrigiddynamic_vtable: *PxRigidDynamic_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxRigidDynamic) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxRigidDynamic@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxRigidDynamic, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxRigidDynamic@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxRigidDynamic, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxRigidDynamic@physx@@MEBA_NPEBD@Z";
    }
    PxRigidDynamic_VTable :: struct #type_info_none {
        using pxrigidbody: PxRigidBody_VTable;
        setKinematicTarget: (this: *PxRigidDynamic, destination: *PxTransform) -> void #cpp_method;

        getKinematicTarget: (this: *PxRigidDynamic, target: *PxTransform) -> bool #cpp_method;

        isSleeping: (this: *PxRigidDynamic) -> bool #cpp_method;

        setSleepThreshold: (this: *PxRigidDynamic, threshold: PxReal) -> void #cpp_method;

        getSleepThreshold: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        setStabilizationThreshold: (this: *PxRigidDynamic, threshold: PxReal) -> void #cpp_method;

        getStabilizationThreshold: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        setWakeCounter: (this: *PxRigidDynamic, wakeCounterValue: PxReal) -> void #cpp_method;

        getWakeCounter: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        wakeUp: (this: *PxRigidDynamic) -> void #cpp_method;

        putToSleep: (this: *PxRigidDynamic) -> void #cpp_method;

        getRigidDynamicLockFlags: (this: *PxRigidDynamic) -> PxRigidDynamicLockFlags #cpp_method;

        setRigidDynamicLockFlag: (this: *PxRigidDynamic, flag: PxRigidDynamicLockFlag.Enum, value: bool) -> void #cpp_method;

        setRigidDynamicLockFlags: (this: *PxRigidDynamic, flags: PxRigidDynamicLockFlags) -> void #cpp_method;

        setLinearVelocity: (this: *PxRigidDynamic, linVel: *PxVec3, autowake := true) -> void #cpp_method;

        setAngularVelocity: (this: *PxRigidDynamic, angVel: *PxVec3, autowake := true) -> void #cpp_method;

        setSolverIterationCounts: (this: *PxRigidDynamic, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) -> void #cpp_method;

        getSolverIterationCounts: (this: *PxRigidDynamic, minPositionIters: *PxU32, minVelocityIters: *PxU32) -> void #cpp_method;

        getContactReportThreshold: (this: *PxRigidDynamic) -> PxReal #cpp_method;

        setContactReportThreshold: (this: *PxRigidDynamic, threshold: PxReal) -> void #cpp_method;

        getGPUIndex: (this: *PxRigidDynamic) -> PxRigidDynamicGPUIndex #cpp_method;
    }

    PxRigidDynamic_setKinematicTarget :: inline (this: *PxRigidDynamic, destination: *PxTransform) { this.pxrigiddynamic_vtable.setKinematicTarget(this, destination); }

    PxRigidDynamic_getKinematicTarget :: inline (this: *PxRigidDynamic, target: *PxTransform) -> bool { return this.pxrigiddynamic_vtable.getKinematicTarget(this, target); }

    PxRigidDynamic_isSleeping :: inline (this: *PxRigidDynamic) -> bool { return this.pxrigiddynamic_vtable.isSleeping(this); }

    PxRigidDynamic_setSleepThreshold :: inline (this: *PxRigidDynamic, threshold: PxReal) { this.pxrigiddynamic_vtable.setSleepThreshold(this, threshold); }

    PxRigidDynamic_getSleepThreshold :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getSleepThreshold(this); }

    PxRigidDynamic_setStabilizationThreshold :: inline (this: *PxRigidDynamic, threshold: PxReal) { this.pxrigiddynamic_vtable.setStabilizationThreshold(this, threshold); }

    PxRigidDynamic_getStabilizationThreshold :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getStabilizationThreshold(this); }

    PxRigidDynamic_setWakeCounter :: inline (this: *PxRigidDynamic, wakeCounterValue: PxReal) { this.pxrigiddynamic_vtable.setWakeCounter(this, wakeCounterValue); }

    PxRigidDynamic_getWakeCounter :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getWakeCounter(this); }

    PxRigidDynamic_wakeUp :: inline (this: *PxRigidDynamic) { this.pxrigiddynamic_vtable.wakeUp(this); }

    PxRigidDynamic_putToSleep :: inline (this: *PxRigidDynamic) { this.pxrigiddynamic_vtable.putToSleep(this); }

    PxRigidDynamic_getRigidDynamicLockFlags :: inline (this: *PxRigidDynamic) -> PxRigidDynamicLockFlags { return this.pxrigiddynamic_vtable.getRigidDynamicLockFlags(this); }

    PxRigidDynamic_setRigidDynamicLockFlag :: inline (this: *PxRigidDynamic, flag: PxRigidDynamicLockFlag.Enum, value: bool) { this.pxrigiddynamic_vtable.setRigidDynamicLockFlag(this, flag, value); }

    PxRigidDynamic_setRigidDynamicLockFlags :: inline (this: *PxRigidDynamic, flags: PxRigidDynamicLockFlags) { this.pxrigiddynamic_vtable.setRigidDynamicLockFlags(this, flags); }

    PxRigidDynamic_setLinearVelocity :: inline (this: *PxRigidDynamic, linVel: *PxVec3, autowake := true) { this.pxrigiddynamic_vtable.setLinearVelocity(this, linVel, autowake); }

    PxRigidDynamic_setAngularVelocity :: inline (this: *PxRigidDynamic, angVel: *PxVec3, autowake := true) { this.pxrigiddynamic_vtable.setAngularVelocity(this, angVel, autowake); }

    PxRigidDynamic_setSolverIterationCounts :: inline (this: *PxRigidDynamic, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) { this.pxrigiddynamic_vtable.setSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxRigidDynamic_getSolverIterationCounts :: inline (this: *PxRigidDynamic, minPositionIters: *PxU32, minVelocityIters: *PxU32) { this.pxrigiddynamic_vtable.getSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxRigidDynamic_getContactReportThreshold :: inline (this: *PxRigidDynamic) -> PxReal { return this.pxrigiddynamic_vtable.getContactReportThreshold(this); }

    PxRigidDynamic_setContactReportThreshold :: inline (this: *PxRigidDynamic, threshold: PxReal) { this.pxrigiddynamic_vtable.setContactReportThreshold(this, threshold); }

    PxRigidDynamic_getGPUIndex :: inline (this: *PxRigidDynamic) -> PxRigidDynamicGPUIndex { return this.pxrigiddynamic_vtable.getGPUIndex(this); }

    vtable :: (obj: *PxRigidDynamic) -> *PxRigidDynamic_VTable { return obj.pxrigiddynamic_vtable; }


    /*
    \brief PxRigidStatic represents a static rigid body simulation object in the physics SDK.
    
    PxRigidStatic objects are static rigid physics entities. They shall be used to define solid objects which are fixed in the world.
    
    <h3>Creation</h3>
    Instances of this class are created by calling #PxPhysics::createRigidStatic() and deleted with #release().
    
    <h3>Visualizations</h3>
    \li #PxVisualizationParameter::eACTOR_AXES
    
    \see PxRigidActor  PxPhysics.createRigidStatic()  release()
    */
    PxRigidStatic :: struct {
        #as using pxrigidactor: PxRigidActor;

        Constructor :: (this: *PxRigidStatic, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidStatic@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxRigidStatic, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxRigidStatic@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxRigidStatic) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxRigidStatic@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxRigidStatic, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxRigidStatic@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxRigidStatic, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxRigidStatic@physx@@MEBA_NPEBD@Z";
    }

    /*
    \brief This flag specifies the type of data to get when calling PxDirectGPUAPI::getRigidDynamicData().
    */
    PxRigidDynamicGPUAPIReadType :: struct {
        Enum :: enum s32 {
            GLOBAL_POSE          :: 0;
            LINEAR_VELOCITY      :: 1;
            ANGULAR_VELOCITY     :: 2;

            LINEAR_ACCELERATION  :: 3;
            ANGULAR_ACCELERATION :: 4;

            eGLOBAL_POSE          :: GLOBAL_POSE;
            eLINEAR_VELOCITY      :: LINEAR_VELOCITY;
            eANGULAR_VELOCITY     :: ANGULAR_VELOCITY;

            eLINEAR_ACCELERATION  :: LINEAR_ACCELERATION;
            eANGULAR_ACCELERATION :: ANGULAR_ACCELERATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief This flag specifies the type of data to set when calling PxDirectGPUAPI::setRigidDynamicData().
    */
    PxRigidDynamicGPUAPIWriteType :: struct {
        Enum :: enum s32 {
            GLOBAL_POSE      :: 0;
            LINEAR_VELOCITY  :: 1;
            ANGULAR_VELOCITY :: 2;
            FORCE            :: 3;
            TORQUE           :: 4;

            eGLOBAL_POSE      :: GLOBAL_POSE;
            eLINEAR_VELOCITY  :: LINEAR_VELOCITY;
            eANGULAR_VELOCITY :: ANGULAR_VELOCITY;
            eFORCE            :: FORCE;
            eTORQUE           :: TORQUE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief This flag specifies the type of data to get when calling PxDirectGPUAPI::getArticulationData().
    */
    PxArticulationGPUAPIReadType :: struct {
        Enum :: enum s32 {
            JOINT_POSITION            :: 0;
            JOINT_VELOCITY            :: 1;
            JOINT_ACCELERATION        :: 2;
            JOINT_FORCE               :: 3;
            JOINT_TARGET_VELOCITY     :: 4;
            JOINT_TARGET_POSITION     :: 5;
            ROOT_GLOBAL_POSE          :: 6;
            ROOT_LINEAR_VELOCITY      :: 7;
            ROOT_ANGULAR_VELOCITY     :: 8;
            LINK_GLOBAL_POSE          :: 9;
            LINK_LINEAR_VELOCITY      :: 10;
            LINK_ANGULAR_VELOCITY     :: 11;
            LINK_LINEAR_ACCELERATION  :: 12;
            LINK_ANGULAR_ACCELERATION :: 13;
            LINK_INCOMING_JOINT_FORCE :: 14;

            eJOINT_POSITION            :: JOINT_POSITION;
            eJOINT_VELOCITY            :: JOINT_VELOCITY;
            eJOINT_ACCELERATION        :: JOINT_ACCELERATION;
            eJOINT_FORCE               :: JOINT_FORCE;
            eJOINT_TARGET_VELOCITY     :: JOINT_TARGET_VELOCITY;
            eJOINT_TARGET_POSITION     :: JOINT_TARGET_POSITION;
            eROOT_GLOBAL_POSE          :: ROOT_GLOBAL_POSE;
            eROOT_LINEAR_VELOCITY      :: ROOT_LINEAR_VELOCITY;
            eROOT_ANGULAR_VELOCITY     :: ROOT_ANGULAR_VELOCITY;
            eLINK_GLOBAL_POSE          :: LINK_GLOBAL_POSE;
            eLINK_LINEAR_VELOCITY      :: LINK_LINEAR_VELOCITY;
            eLINK_ANGULAR_VELOCITY     :: LINK_ANGULAR_VELOCITY;
            eLINK_LINEAR_ACCELERATION  :: LINK_LINEAR_ACCELERATION;
            eLINK_ANGULAR_ACCELERATION :: LINK_ANGULAR_ACCELERATION;
            eLINK_INCOMING_JOINT_FORCE :: LINK_INCOMING_JOINT_FORCE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief This flag specifies the type of data to set when calling PxDirectGPUAPI::setArticulationData().
    */
    PxArticulationGPUAPIWriteType :: struct {
        Enum :: enum s32 {
            JOINT_POSITION            :: 0;
            JOINT_VELOCITY            :: 1;
            JOINT_FORCE               :: 2;
            JOINT_TARGET_VELOCITY     :: 3;
            JOINT_TARGET_POSITION     :: 4;
            ROOT_GLOBAL_POSE          :: 5;
            ROOT_LINEAR_VELOCITY      :: 6;
            ROOT_ANGULAR_VELOCITY     :: 7;
            LINK_FORCE                :: 8;
            LINK_TORQUE               :: 9;
            FIXED_TENDON              :: 10;
            FIXED_TENDON_JOINT        :: 11;
            SPATIAL_TENDON            :: 12;
            SPATIAL_TENDON_ATTACHMENT :: 13;

            eJOINT_POSITION            :: JOINT_POSITION;
            eJOINT_VELOCITY            :: JOINT_VELOCITY;
            eJOINT_FORCE               :: JOINT_FORCE;
            eJOINT_TARGET_VELOCITY     :: JOINT_TARGET_VELOCITY;
            eJOINT_TARGET_POSITION     :: JOINT_TARGET_POSITION;
            eROOT_GLOBAL_POSE          :: ROOT_GLOBAL_POSE;
            eROOT_LINEAR_VELOCITY      :: ROOT_LINEAR_VELOCITY;
            eROOT_ANGULAR_VELOCITY     :: ROOT_ANGULAR_VELOCITY;
            eLINK_FORCE                :: LINK_FORCE;
            eLINK_TORQUE               :: LINK_TORQUE;
            eFIXED_TENDON              :: FIXED_TENDON;
            eFIXED_TENDON_JOINT        :: FIXED_TENDON_JOINT;
            eSPATIAL_TENDON            :: SPATIAL_TENDON;
            eSPATIAL_TENDON_ATTACHMENT :: SPATIAL_TENDON_ATTACHMENT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief This flag specifies the type of operation to perform when calling PxDirectGPUAPI::computeArticulationData.
    */
    PxArticulationGPUAPIComputeType :: struct {
        Enum :: enum s32 {
            UPDATE_KINEMATIC                :: 0;

            DENSE_JACOBIANS                 :: 1;

            GENERALIZED_MASS_MATRICES       :: 2;

            GENERALIZED_GRAVITY_FORCES      :: 3;

            CORIOLIS_AND_CENTRIFUGAL_FORCES :: 4;

            eUPDATE_KINEMATIC                :: UPDATE_KINEMATIC;

            eDENSE_JACOBIANS                 :: DENSE_JACOBIANS;

            eGENERALIZED_MASS_MATRICES       :: GENERALIZED_MASS_MATRICES;

            eGENERALIZED_GRAVITY_FORCES      :: GENERALIZED_GRAVITY_FORCES;

            eCORIOLIS_AND_CENTRIFUGAL_FORCES :: CORIOLIS_AND_CENTRIFUGAL_FORCES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Container to hold the results of PxDirectGPUAPI::getArticulationGPUAPIMaxCounts(). All the quantities are the maximum values
    for the PxScene associated with this instance of PxDirectGPUAPI.
    */
    PxArticulationGPUAPIMaxCounts :: struct {
        maxDofs:                     PxU32;
        maxLinks:                    PxU32;
        maxFixedTendons:             PxU32;
        maxFixedTendonJoints:        PxU32;
        maxSpatialTendons:           PxU32;
        maxSpatialTendonAttachments: PxU32;

        Constructor :: (this: *PxArticulationGPUAPIMaxCounts) -> void #cpp_method #foreign physx_static "??0PxArticulationGPUAPIMaxCounts@physx@@QEAA@XZ";
    }

    /*
    \brief PxDirectGPUAPI exposes an API that enables batched direct access to GPU data for a PxScene.
    
    The functions in this class allow batched direct access to GPU data for PxRigidDynamic, PxArticulationReducedCoordinate
    and PxShape types. This allows interoperation with GPU post- and preprocessing for users and allows the user
    to implement more efficient CPU-GPU data copies based on the specific needs of the application.
    
    Using this direct-API will disable the existing CPU-based API for all the data exposed in the direct-API. For any API function
    that does not have a counterpart in this direct-API, the existing API will continue to work.
    
    To use this API, PxSceneFlag::eENABLE_DIRECT_GPU_API needs to be raised, in combination with PxSceneFlag::eENABLE_GPU_DYNAMICS
    and PxBroadphaseType::eGPU. Note that these options are immutable and cannot be changed after the scene has been created.
    
    Due to the internal architecture of the GPU-accelerated parts of PhysX, using this API comes with caveats:
    
    1) All GPU-CPU copies for data exposed in this API will be disabled. This means that the existing CPU-based API will
    return outdated data, and any setters for data exposed in the interface will not work. On the other hand, significant
    speedups can be achieved because of the reduced amount of GPU-CPU memory copies.
    
    2) Due to the internal architecture of the GPU-accelerated PhysX, this API will only work after a first simulation step has been
    taken. The reason for this is that the PxScene first needs to know all the actors it will have to simulate, and setup the
    sizes of the GPU-based structures. For setup, the existing CPU API should be used.
    
    \note Due to the fact that this API is exposing low-level data, we do reserve the right to change this API without deprecation
    in case of changes in the internal implementations.
    */
    PxDirectGPUAPI :: struct {
        vtable: *PxDirectGPUAPI_VTable;
        Constructor :: (this: *PxDirectGPUAPI) -> void #cpp_method #foreign physx_static "??0PxDirectGPUAPI@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxDirectGPUAPI, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxDirectGPUAPI@physx@@MEAA@XZ";
    }
    PxDirectGPUAPI_VTable :: struct #type_info_none {
        Destructor: (this: *PxDirectGPUAPI, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        getRigidDynamicData: (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxRigidDynamicGPUIndex, dataType: PxRigidDynamicGPUAPIReadType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool #cpp_method;

        setRigidDynamicData: (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxRigidDynamicGPUIndex, dataType: PxRigidDynamicGPUAPIWriteType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool #cpp_method;

        getArticulationData: (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxArticulationGPUIndex, dataType: PxArticulationGPUAPIReadType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool #cpp_method;

        setArticulationData: (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxArticulationGPUIndex, dataType: PxArticulationGPUAPIWriteType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool #cpp_method;

        computeArticulationData: (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxArticulationGPUIndex, operation: PxArticulationGPUAPIComputeType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool #cpp_method;

        copyContactData: (this: *PxDirectGPUAPI, data: *void, nbContactPairs: *PxU32, maxPairs: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool #cpp_method;

        evaluateSDFDistances: (this: *PxDirectGPUAPI, localGradientAndSDFConcatenated: *PxVec4, shapeIndices: *PxShapeGPUIndex, localSamplePointsConcatenated: *PxVec4, samplePointCountPerShape: *PxU32, nbElements: PxU32, maxPointCount: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool #cpp_method;

        getArticulationGPUAPIMaxCounts: (this: *PxDirectGPUAPI) -> PxArticulationGPUAPIMaxCounts #cpp_method #cpp_return_type_is_non_pod;
    }

    PxDirectGPUAPI_Destructor :: inline (this: *PxDirectGPUAPI, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxDirectGPUAPI_getRigidDynamicData :: inline (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxRigidDynamicGPUIndex, dataType: PxRigidDynamicGPUAPIReadType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool { return this.vtable.getRigidDynamicData(this, data, gpuIndices, dataType, nbElements, startEvent, finishEvent); }

    PxDirectGPUAPI_setRigidDynamicData :: inline (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxRigidDynamicGPUIndex, dataType: PxRigidDynamicGPUAPIWriteType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool { return this.vtable.setRigidDynamicData(this, data, gpuIndices, dataType, nbElements, startEvent, finishEvent); }

    PxDirectGPUAPI_getArticulationData :: inline (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxArticulationGPUIndex, dataType: PxArticulationGPUAPIReadType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool { return this.vtable.getArticulationData(this, data, gpuIndices, dataType, nbElements, startEvent, finishEvent); }

    PxDirectGPUAPI_setArticulationData :: inline (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxArticulationGPUIndex, dataType: PxArticulationGPUAPIWriteType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool { return this.vtable.setArticulationData(this, data, gpuIndices, dataType, nbElements, startEvent, finishEvent); }

    PxDirectGPUAPI_computeArticulationData :: inline (this: *PxDirectGPUAPI, data: *void, gpuIndices: *PxArticulationGPUIndex, operation: PxArticulationGPUAPIComputeType.Enum, nbElements: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool { return this.vtable.computeArticulationData(this, data, gpuIndices, operation, nbElements, startEvent, finishEvent); }

    PxDirectGPUAPI_copyContactData :: inline (this: *PxDirectGPUAPI, data: *void, nbContactPairs: *PxU32, maxPairs: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool { return this.vtable.copyContactData(this, data, nbContactPairs, maxPairs, startEvent, finishEvent); }

    PxDirectGPUAPI_evaluateSDFDistances :: inline (this: *PxDirectGPUAPI, localGradientAndSDFConcatenated: *PxVec4, shapeIndices: *PxShapeGPUIndex, localSamplePointsConcatenated: *PxVec4, samplePointCountPerShape: *PxU32, nbElements: PxU32, maxPointCount: PxU32, startEvent: CUevent = null, finishEvent: CUevent = null) -> bool { return this.vtable.evaluateSDFDistances(this, localGradientAndSDFConcatenated, shapeIndices, localSamplePointsConcatenated, samplePointCountPerShape, nbElements, maxPointCount, startEvent, finishEvent); }

    PxDirectGPUAPI_getArticulationGPUAPIMaxCounts :: inline (this: *PxDirectGPUAPI) -> PxArticulationGPUAPIMaxCounts { return this.vtable.getArticulationGPUAPIMaxCounts(this); }

    vtable :: (obj: *PxDirectGPUAPI) -> *PxDirectGPUAPI_VTable { return obj.vtable; }


    /*
    \brief Pruning structure used to accelerate scene queries.
    
    eNONE uses a simple data structure that consumes less memory than the alternatives,
    but generally has slower query performance.
    
    eDYNAMIC_AABB_TREE usually provides the fastest queries. However there is a
    constant per-frame management cost associated with this structure. How much work should
    be done per frame can be tuned via the #PxSceneQueryDesc::dynamicTreeRebuildRateHint
    parameter.
    
    eSTATIC_AABB_TREE is typically used for static objects. It is the same as the
    dynamic AABB tree, without the per-frame overhead. This can be a good choice for static
    objects, if no static objects are added, moved or removed after the scene has been
    created. If there is no such guarantee (e.g. when streaming parts of the world in and out),
    then the dynamic version is a better choice even for static objects.
    */
    PxPruningStructureType :: struct {
        Enum :: enum s32 {
            NONE              :: 0;
            DYNAMIC_AABB_TREE :: 1;
            STATIC_AABB_TREE  :: 2;

            LAST              :: 3;

            eNONE              :: NONE;
            eDYNAMIC_AABB_TREE :: DYNAMIC_AABB_TREE;
            eSTATIC_AABB_TREE  :: STATIC_AABB_TREE;

            eLAST              :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Secondary pruning structure used for newly added objects in dynamic trees.
    
    Dynamic trees (PxPruningStructureType::eDYNAMIC_AABB_TREE) are slowly rebuilt
    over several frames. A secondary pruning structure holds and manages objects
    added to the scene while this rebuild is in progress.
    
    eNONE ignores newly added objects. This means that for a number of frames (roughly
    defined by PxSceneQueryDesc::dynamicTreeRebuildRateHint) newly added objects will
    be ignored by scene queries. This can be acceptable when streaming large worlds, e.g.
    when the objects added at the boundaries of the game world don't immediately need to be
    visible from scene queries (it would be equivalent to streaming that data in a few frames
    later). The advantage of this approach is that there is no CPU cost associated with
    inserting the new objects in the scene query data structures, and no extra runtime cost
    when performing queries.
    
    eBUCKET uses a structure similar to PxPruningStructureType::eNONE. Insertion is fast but
    query cost can be high.
    
    eINCREMENTAL uses an incremental AABB-tree, with no direct PxPruningStructureType equivalent.
    Query time is fast but insertion cost can be high.
    
    eBVH uses a PxBVH structure. This usually offers the best overall performance.
    */
    PxDynamicTreeSecondaryPruner :: struct {
        Enum :: enum s32 {
            NONE        :: 0;
            BUCKET      :: 1;
            INCREMENTAL :: 2;
            BVH         :: 3;

            LAST        :: 4;

            eNONE        :: NONE;
            eBUCKET      :: BUCKET;
            eINCREMENTAL :: INCREMENTAL;
            eBVH         :: BVH;

            eLAST        :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Scene query update mode
    
    This enum controls what work is done when the scene query system is updated. The updates traditionally happen when PxScene::fetchResults
    is called. This function then calls PxSceneQuerySystem::finalizeUpdates, where the update mode is used.
    
    fetchResults/finalizeUpdates will sync changed bounds during simulation and update the scene query bounds in pruners, this work is mandatory.
    
    eBUILD_ENABLED_COMMIT_ENABLED does allow to execute the new AABB tree build step during fetchResults/finalizeUpdates, additionally
    the pruner commit is called where any changes are applied. During commit PhysX refits the dynamic scene query tree and if a new tree
    was built and the build finished the tree is swapped with current AABB tree.
    
    eBUILD_ENABLED_COMMIT_DISABLED does allow to execute the new AABB tree build step during fetchResults/finalizeUpdates. Pruner commit
    is not called, this means that refit will then occur during the first scene query following fetchResults/finalizeUpdates, or may be forced
    by the method PxScene::flushQueryUpdates() / PxSceneQuerySystemBase::flushUpdates().
    
    eBUILD_DISABLED_COMMIT_DISABLED no further scene query work is executed. The scene queries update needs to be called manually, see
    PxScene::sceneQueriesUpdate (see that function's doc for the equivalent PxSceneQuerySystem sequence). It is recommended to call
    PxScene::sceneQueriesUpdate right after fetchResults/finalizeUpdates as the pruning structures are not updated.
    */
    PxSceneQueryUpdateMode :: struct {
        Enum :: enum s32 {
            ENABLED_COMMIT_ENABLED   :: 0;
            ENABLED_COMMIT_DISABLED  :: 1;
            DISABLED_COMMIT_DISABLED :: 2;

            eBUILD_ENABLED_COMMIT_ENABLED   :: ENABLED_COMMIT_ENABLED;
            eBUILD_ENABLED_COMMIT_DISABLED  :: ENABLED_COMMIT_DISABLED;
            eBUILD_DISABLED_COMMIT_DISABLED :: DISABLED_COMMIT_DISABLED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Descriptor class for scene query system. See #PxSceneQuerySystem.
    */
    PxSceneQueryDesc :: struct {
        /*
        \brief Defines the structure used to store static objects (PxRigidStatic actors).
        
        There are usually a lot more static actors than dynamic actors in a scene, so they are stored
        in a separate structure. The idea is that when dynamic actors move each frame, the static structure
        remains untouched and does not need updating.
        
        <b>Default:</b> PxPruningStructureType::eDYNAMIC_AABB_TREE
        
        \note Only PxPruningStructureType::eSTATIC_AABB_TREE and PxPruningStructureType::eDYNAMIC_AABB_TREE are allowed here.
        
        \see PxPruningStructureType PxSceneSQSystem.getStaticStructure()
        */
        staticStructure:            PxPruningStructureType.Enum;

        /*
        \brief Defines the structure used to store dynamic objects (non-PxRigidStatic actors).
        
        <b>Default:</b> PxPruningStructureType::eDYNAMIC_AABB_TREE
        
        \see PxPruningStructureType PxSceneSQSystem.getDynamicStructure()
        */
        dynamicStructure:           PxPruningStructureType.Enum;

        /*
        \brief Hint for how much work should be done per simulation frame to rebuild the pruning structures.
        
        This parameter gives a hint on the distribution of the workload for rebuilding the dynamic AABB tree
        pruning structure #PxPruningStructureType::eDYNAMIC_AABB_TREE. It specifies the desired number of simulation frames
        the rebuild process should take. Higher values will decrease the workload per frame but the pruning
        structure will get more and more outdated the longer the rebuild takes (which can make
        scene queries less efficient).
        
        \note Only used for #PxPruningStructureType::eDYNAMIC_AABB_TREE pruning structures.
        
        \note Both staticStructure & dynamicStructure can use a PxPruningStructureType::eDYNAMIC_AABB_TREE, in which case
        this parameter is used for both.
        
        \note This parameter gives only a hint. The rebuild process might still take more or less time depending on the
        number of objects involved.
        
        <b>Range:</b> [4, PX_MAX_U32)<br>
        <b>Default:</b> 100
        
        \see PxSceneQuerySystemBase.setDynamicTreeRebuildRateHint() PxSceneQuerySystemBase.getDynamicTreeRebuildRateHint()
        */
        dynamicTreeRebuildRateHint: PxU32;

        /*
        \brief Secondary pruner for dynamic tree.
        
        This is used for PxPruningStructureType::eDYNAMIC_AABB_TREE structures, to control how objects added to the system
        at runtime are managed.
        
        \note Both staticStructure & dynamicStructure can use a PxPruningStructureType::eDYNAMIC_AABB_TREE, in which case
        this parameter is used for both.
        
        <b>Default:</b> PxDynamicTreeSecondaryPruner::eINCREMENTAL
        
        \see PxDynamicTreeSecondaryPruner
        */
        dynamicTreeSecondaryPruner: PxDynamicTreeSecondaryPruner.Enum;

        /*
        \brief Build strategy for PxSceneQueryDesc::staticStructure.
        
        This parameter is used to refine / control the build strategy of PxSceneQueryDesc::staticStructure. This is only
        used with PxPruningStructureType::eDYNAMIC_AABB_TREE and PxPruningStructureType::eSTATIC_AABB_TREE.
        
        <b>Default:</b> PxBVHBuildStrategy::eFAST
        
        \see PxBVHBuildStrategy PxSceneQueryDesc::staticStructure
        */
        staticBVHBuildStrategy:     PxBVHBuildStrategy.Enum;

        /*
        \brief Build strategy for PxSceneQueryDesc::dynamicStructure.
        
        This parameter is used to refine / control the build strategy of PxSceneQueryDesc::dynamicStructure. This is only
        used with PxPruningStructureType::eDYNAMIC_AABB_TREE and PxPruningStructureType::eSTATIC_AABB_TREE.
        
        <b>Default:</b> PxBVHBuildStrategy::eFAST
        
        \see PxBVHBuildStrategy PxSceneQueryDesc::dynamicStructure
        */
        dynamicBVHBuildStrategy:    PxBVHBuildStrategy.Enum;

        /*
        \brief Number of objects per node for PxSceneQueryDesc::staticStructure.
        
        This parameter is used to refine / control the number of objects per node for PxSceneQueryDesc::staticStructure.
        This is only used with PxPruningStructureType::eDYNAMIC_AABB_TREE and PxPruningStructureType::eSTATIC_AABB_TREE.
        
        This parameter has an impact on how quickly the structure gets built, and on the per-frame cost of maintaining
        the structure. Increasing this value gives smaller AABB-trees that use less memory, are faster to build and
        update, but it can lead to slower queries.
        
        <b>Default:</b> 4
        
        \see PxSceneQueryDesc::staticStructure
        */
        staticNbObjectsPerNode:     PxU32;

        /*
        \brief Number of objects per node for PxSceneQueryDesc::dynamicStructure.
        
        This parameter is used to refine / control the number of objects per node for PxSceneQueryDesc::dynamicStructure.
        This is only used with PxPruningStructureType::eDYNAMIC_AABB_TREE and PxPruningStructureType::eSTATIC_AABB_TREE.
        
        This parameter has an impact on how quickly the structure gets built, and on the per-frame cost of maintaining
        the structure. Increasing this value gives smaller AABB-trees that use less memory, are faster to build and
        update, but it can lead to slower queries.
        
        <b>Default:</b> 4
        
        \see PxSceneQueryDesc::dynamicStructure
        */
        dynamicNbObjectsPerNode:    PxU32;

        /*
        \brief Defines the scene query update mode.
        
        <b>Default:</b> PxSceneQueryUpdateMode::eBUILD_ENABLED_COMMIT_ENABLED
        
        \see PxSceneQuerySystemBase.setUpdateMode() PxSceneQuerySystemBase.getUpdateMode()
        */
        sceneQueryUpdateMode:       PxSceneQueryUpdateMode.Enum;

        /*
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxSceneQueryDesc) -> void #cpp_method #foreign physx_static "??0PxSceneQueryDesc@physx@@QEAA@XZ";

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxSceneQueryDesc) -> bool #cpp_method #foreign physx_static "?isValid@PxSceneQueryDesc@physx@@QEBA_NXZ";
    }

    /*
    \brief Built-in enum for default PxScene pruners
    
    This is passed as a pruner index to various functions in the following APIs.
    
    \see PxSceneQuerySystemBase::forceRebuildDynamicTree PxSceneQuerySystem::preallocate
    \see PxSceneQuerySystem::visualize PxSceneQuerySystem::sync PxSceneQuerySystem::prepareSceneQueryBuildStep
    */
    PxScenePrunerIndex :: enum s32 {
        PRUNER_STATIC   :: 0;
        PRUNER_DYNAMIC  :: 1;
        COMPOUND_PRUNER :: -1;

        PX_SCENE_PRUNER_STATIC   :: PRUNER_STATIC;
        PX_SCENE_PRUNER_DYNAMIC  :: PRUNER_DYNAMIC;
        PX_SCENE_COMPOUND_PRUNER :: COMPOUND_PRUNER;
    }

    /*
    \brief Base class for the scene-query system.
    
    Methods defined here are common to both the traditional PxScene API and the PxSceneQuerySystem API.
    
    \see PxScene PxSceneQuerySystem
    */
    PxSceneQuerySystemBase :: struct {
        vtable: *PxSceneQuerySystemBase_VTable;
        Constructor :: (this: *PxSceneQuerySystemBase) -> void #cpp_method #foreign physx_static "??0PxSceneQuerySystemBase@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxSceneQuerySystemBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxSceneQuerySystemBase@physx@@MEAA@XZ";
    }
    PxSceneQuerySystemBase_VTable :: struct #type_info_none {
        Destructor: (this: *PxSceneQuerySystemBase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        setDynamicTreeRebuildRateHint: (this: *PxSceneQuerySystemBase, dynamicTreeRebuildRateHint: PxU32) -> void #cpp_method;

        getDynamicTreeRebuildRateHint: (this: *PxSceneQuerySystemBase) -> PxU32 #cpp_method;

        forceRebuildDynamicTree: (this: *PxSceneQuerySystemBase, prunerIndex: PxU32) -> void #cpp_method;

        setUpdateMode: (this: *PxSceneQuerySystemBase, updateMode: PxSceneQueryUpdateMode.Enum) -> void #cpp_method;

        getUpdateMode: (this: *PxSceneQuerySystemBase) -> PxSceneQueryUpdateMode.Enum #cpp_method;

        getStaticTimestamp: (this: *PxSceneQuerySystemBase) -> PxU32 #cpp_method;

        flushUpdates: (this: *PxSceneQuerySystemBase) -> void #cpp_method;

        raycast: (this: *PxSceneQuerySystemBase, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal, hitCall: *PxRaycastCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, queryFlags: PxGeometryQueryFlags) -> bool #cpp_method;
        raycast :: (this: *PxSceneQuerySystemBase, origin: PxVec3, unitDir: PxVec3, distance: PxReal, hitCall: *PxRaycastCallback, hitFlags: PxHitFlags, filterData: PxQueryFilterData = PxQueryFilterData.{}, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, queryFlags: PxGeometryQueryFlags) -> bool #no_context {
            return raycast(this, *origin, *unitDir, distance, hitCall, hitFlags, *filterData, filterCall, cache, queryFlags);
        }

        sweep: (this: *PxSceneQuerySystemBase, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, hitCall: *PxSweepCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0, queryFlags: PxGeometryQueryFlags) -> bool #cpp_method;
        sweep :: (this: *PxSceneQuerySystemBase, geometry: PxGeometry, pose: PxTransform, unitDir: PxVec3, distance: PxReal, hitCall: *PxSweepCallback, hitFlags: PxHitFlags, filterData: PxQueryFilterData = PxQueryFilterData.{}, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0, queryFlags: PxGeometryQueryFlags) -> bool #no_context {
            return sweep(this, *geometry, *pose, *unitDir, distance, hitCall, hitFlags, *filterData, filterCall, cache, inflation, queryFlags);
        }

        overlap: (this: *PxSceneQuerySystemBase, geometry: *PxGeometry, pose: *PxTransform, hitCall: *PxOverlapCallback, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, queryFlags: PxGeometryQueryFlags) -> bool #cpp_method;
        overlap :: (this: *PxSceneQuerySystemBase, geometry: PxGeometry, pose: PxTransform, hitCall: *PxOverlapCallback, filterData: PxQueryFilterData = PxQueryFilterData.{}, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, queryFlags: PxGeometryQueryFlags) -> bool #no_context {
            return overlap(this, *geometry, *pose, hitCall, *filterData, filterCall, cache, queryFlags);
        }
    }

    PxSceneQuerySystemBase_Destructor :: inline (this: *PxSceneQuerySystemBase, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxSceneQuerySystemBase_setDynamicTreeRebuildRateHint :: inline (this: *PxSceneQuerySystemBase, dynamicTreeRebuildRateHint: PxU32) { this.vtable.setDynamicTreeRebuildRateHint(this, dynamicTreeRebuildRateHint); }

    PxSceneQuerySystemBase_getDynamicTreeRebuildRateHint :: inline (this: *PxSceneQuerySystemBase) -> PxU32 { return this.vtable.getDynamicTreeRebuildRateHint(this); }

    PxSceneQuerySystemBase_forceRebuildDynamicTree :: inline (this: *PxSceneQuerySystemBase, prunerIndex: PxU32) { this.vtable.forceRebuildDynamicTree(this, prunerIndex); }

    PxSceneQuerySystemBase_setUpdateMode :: inline (this: *PxSceneQuerySystemBase, updateMode: PxSceneQueryUpdateMode.Enum) { this.vtable.setUpdateMode(this, updateMode); }

    PxSceneQuerySystemBase_getUpdateMode :: inline (this: *PxSceneQuerySystemBase) -> PxSceneQueryUpdateMode.Enum { return this.vtable.getUpdateMode(this); }

    PxSceneQuerySystemBase_getStaticTimestamp :: inline (this: *PxSceneQuerySystemBase) -> PxU32 { return this.vtable.getStaticTimestamp(this); }

    PxSceneQuerySystemBase_flushUpdates :: inline (this: *PxSceneQuerySystemBase) { this.vtable.flushUpdates(this); }

    PxSceneQuerySystemBase_raycast :: inline (this: *PxSceneQuerySystemBase, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal, hitCall: *PxRaycastCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, queryFlags: PxGeometryQueryFlags) -> bool { return this.vtable.raycast(this, origin, unitDir, distance, hitCall, hitFlags, filterData, filterCall, cache, queryFlags); }

    PxSceneQuerySystemBase_sweep :: inline (this: *PxSceneQuerySystemBase, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, hitCall: *PxSweepCallback, hitFlags: PxHitFlags, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, inflation: PxReal = 0.0, queryFlags: PxGeometryQueryFlags) -> bool { return this.vtable.sweep(this, geometry, pose, unitDir, distance, hitCall, hitFlags, filterData, filterCall, cache, inflation, queryFlags); }

    PxSceneQuerySystemBase_overlap :: inline (this: *PxSceneQuerySystemBase, geometry: *PxGeometry, pose: *PxTransform, hitCall: *PxOverlapCallback, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback = null, cache: *PxQueryCache = null, queryFlags: PxGeometryQueryFlags) -> bool { return this.vtable.overlap(this, geometry, pose, hitCall, filterData, filterCall, cache, queryFlags); }

    vtable :: (obj: *PxSceneQuerySystemBase) -> *PxSceneQuerySystemBase_VTable { return obj.vtable; }


    /*
    \brief Traditional SQ system for PxScene.
    
    Methods defined here are only available through the traditional PxScene API.
    Thus PxSceneSQSystem effectively captures the scene-query related part of the PxScene API.
    
    \see PxScene PxSceneQuerySystemBase
    */
    PxSceneSQSystem :: struct {
        #as using pxscenequerysystembase: PxSceneQuerySystemBase;

        Constructor :: (this: *PxSceneSQSystem) -> void #cpp_method #foreign physx_static "??0PxSceneSQSystem@physx@@IEAA@XZ";

        /*
        \brief Sets scene query update mode
        
        \param[in] updateMode	Scene query update mode.
        
        \see PxSceneQueryUpdateMode::Enum
        */
        setSceneQueryUpdateMode :: (this: *PxSceneSQSystem, updateMode: PxSceneQueryUpdateMode.Enum) -> void #cpp_method #foreign physx_static "?setSceneQueryUpdateMode@PxSceneSQSystem@physx@@QEAAXW4Enum@PxSceneQueryUpdateMode@2@@Z";

        /*
        \brief Gets scene query update mode
        
        \return Current scene query update mode.
        
        \see PxSceneQueryUpdateMode::Enum
        */
        getSceneQueryUpdateMode :: (this: *PxSceneSQSystem) -> PxSceneQueryUpdateMode.Enum #cpp_method #foreign physx_static "?getSceneQueryUpdateMode@PxSceneSQSystem@physx@@QEBA?AW4Enum@PxSceneQueryUpdateMode@2@XZ";

        /*
        \brief Retrieves the scene's internal scene query timestamp, increased each time a change to the
        static scene query structure is performed.
        
        \return scene query static timestamp
        */
        getSceneQueryStaticTimestamp :: (this: *PxSceneSQSystem) -> PxU32 #cpp_method #foreign physxcharacterkinematic_static "?getSceneQueryStaticTimestamp@PxSceneSQSystem@physx@@QEBAIXZ";
        #place pxscenequerysystembase; pxscenesqsystem_vtable: *PxSceneSQSystem_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxSceneSQSystem, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxSceneSQSystem@physx@@MEAA@XZ";
    }
    PxSceneSQSystem_VTable :: struct #type_info_none {
        using pxscenequerysystembase: PxSceneQuerySystemBase_VTable;
        getStaticStructure: (this: *PxSceneSQSystem) -> PxPruningStructureType.Enum #cpp_method;

        getDynamicStructure: (this: *PxSceneSQSystem) -> PxPruningStructureType.Enum #cpp_method;

        sceneQueriesUpdate: (this: *PxSceneSQSystem, completionTask: *PxBaseTask = null, controlSimulation := true) -> void #cpp_method;

        checkQueries: (this: *PxSceneSQSystem, block := false) -> bool #cpp_method;

        fetchQueries: (this: *PxSceneSQSystem, block := false) -> bool #cpp_method;
    }

    PxSceneSQSystem_getStaticStructure :: inline (this: *PxSceneSQSystem) -> PxPruningStructureType.Enum { return this.pxscenesqsystem_vtable.getStaticStructure(this); }

    PxSceneSQSystem_getDynamicStructure :: inline (this: *PxSceneSQSystem) -> PxPruningStructureType.Enum { return this.pxscenesqsystem_vtable.getDynamicStructure(this); }

    PxSceneSQSystem_sceneQueriesUpdate :: inline (this: *PxSceneSQSystem, completionTask: *PxBaseTask = null, controlSimulation := true) { this.pxscenesqsystem_vtable.sceneQueriesUpdate(this, completionTask, controlSimulation); }

    PxSceneSQSystem_checkQueries :: inline (this: *PxSceneSQSystem, block := false) -> bool { return this.pxscenesqsystem_vtable.checkQueries(this, block); }

    PxSceneSQSystem_fetchQueries :: inline (this: *PxSceneSQSystem, block := false) -> bool { return this.pxscenesqsystem_vtable.fetchQueries(this, block); }

    vtable :: (obj: *PxSceneSQSystem) -> *PxSceneSQSystem_VTable { return obj.pxscenesqsystem_vtable; }


    PxSQCompoundHandle :: PxU32;
    PxSQPrunerHandle :: PxU32;
    PxSQBuildStepHandle :: *void;

    /*
    \brief Scene-queries external sub-system for PxScene-based objects.
    
    The default PxScene has hardcoded support for 2 regular pruners + 1 compound pruner, but these interfaces
    should work with multiple pruners.
    
    Regular shapes are traditional PhysX shapes that belong to an actor. That actor can be a compound, i.e. it has
    more than one shape. *All of these go to the regular pruners*. This is important because it might be misleading:
    by default all shapes go to one of the two regular pruners, even shapes that belong to compound actors.
    
    For compound actors, adding all the actor's shapes individually to the SQ system can be costly, since all the
    corresponding bounds will always move together and remain close together - that can put a lot of stress on the
    code that updates the SQ spatial structures. In these cases it can be more efficient to add the compound's bounds
    (i.e. the actor's bounds) to the system, as the first level of a bounds hierarchy. The scene queries would then
    be performed against the actor's bounds first, and only visit the shapes' bounds second. This is only useful
    for actors that have more than one shape, i.e. compound actors. Such actors added to the SQ system are thus
    called "SQ compounds". These objects are managed by the "compound pruner", which is only used when an explicit
    SQ compound is added to the SQ system via the addSQCompound call. So in the end one has to distinguish between:
    
    - a "compound shape", which is added to regular pruners as its own individual entity.
    - an "SQ compound shape", which is added to the compound pruner as a subpart of an SQ compound actor.
    
    A compound shape has an invalid compound ID, since it does not belong to an SQ compound.
    An SQ compound shape has a valid compound ID, that identifies its SQ compound owner.
    
    \see PxScene PxSceneQuerySystemBase
    */
    PxSceneQuerySystem :: struct {
        #as using pxscenequerysystembase: PxSceneQuerySystemBase;

        Constructor :: (this: *PxSceneQuerySystem) -> void #cpp_method #foreign physx_static "??0PxSceneQuerySystem@physx@@IEAA@XZ";
        #place pxscenequerysystembase; pxscenequerysystem_vtable: *PxSceneQuerySystem_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxSceneQuerySystem, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxSceneQuerySystem@physx@@MEAA@XZ";
    }
    PxSceneQuerySystem_VTable :: struct #type_info_none {
        using pxscenequerysystembase: PxSceneQuerySystemBase_VTable;
        release: (this: *PxSceneQuerySystem) -> void #cpp_method;

        acquireReference: (this: *PxSceneQuerySystem) -> void #cpp_method;

        preallocate: (this: *PxSceneQuerySystem, prunerIndex: PxU32, nbShapes: PxU32) -> void #cpp_method;

        flushMemory: (this: *PxSceneQuerySystem) -> void #cpp_method;

        addSQShape: (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape, bounds: *PxBounds3, transform: *PxTransform, compoundHandle: *PxSQCompoundHandle = null, hasPruningStructure := false) -> void #cpp_method;

        removeSQShape: (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape) -> void #cpp_method;

        updateSQShape: (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape, transform: *PxTransform) -> void #cpp_method;

        addSQCompound: (this: *PxSceneQuerySystem, actor: *PxRigidActor, shapes: **PxShape, bvh: *PxBVH, transforms: *PxTransform) -> PxSQCompoundHandle #cpp_method;

        removeSQCompound: (this: *PxSceneQuerySystem, compoundHandle: PxSQCompoundHandle) -> void #cpp_method;

        updateSQCompound: (this: *PxSceneQuerySystem, compoundHandle: PxSQCompoundHandle, compoundTransform: *PxTransform) -> void #cpp_method;

        shiftOrigin: (this: *PxSceneQuerySystem, shift: *PxVec3) -> void #cpp_method;

        visualize: (this: *PxSceneQuerySystem, prunerIndex: PxU32, out: *PxRenderOutput) -> void #cpp_method;

        merge: (this: *PxSceneQuerySystem, pruningStructure: *PxPruningStructure) -> void #cpp_method;

        getHandle: (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape, prunerIndex: *PxU32) -> PxSQPrunerHandle #cpp_method;

        sync: (this: *PxSceneQuerySystem, prunerIndex: PxU32, handles: *PxSQPrunerHandle, indices: *PxU32, bounds: *PxBounds3, transforms: *PxTransform32, count: PxU32, ignoredIndices: *PxBitMap) -> void #cpp_method;

        finalizeUpdates: (this: *PxSceneQuerySystem) -> void #cpp_method;

        prepareSceneQueryBuildStep: (this: *PxSceneQuerySystem, prunerIndex: PxU32) -> PxSQBuildStepHandle #cpp_method;

        sceneQueryBuildStep: (this: *PxSceneQuerySystem, handle: PxSQBuildStepHandle) -> void #cpp_method;
    }

    PxSceneQuerySystem_release :: inline (this: *PxSceneQuerySystem) { this.pxscenequerysystem_vtable.release(this); }

    PxSceneQuerySystem_acquireReference :: inline (this: *PxSceneQuerySystem) { this.pxscenequerysystem_vtable.acquireReference(this); }

    PxSceneQuerySystem_preallocate :: inline (this: *PxSceneQuerySystem, prunerIndex: PxU32, nbShapes: PxU32) { this.pxscenequerysystem_vtable.preallocate(this, prunerIndex, nbShapes); }

    PxSceneQuerySystem_flushMemory :: inline (this: *PxSceneQuerySystem) { this.pxscenequerysystem_vtable.flushMemory(this); }

    PxSceneQuerySystem_addSQShape :: inline (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape, bounds: *PxBounds3, transform: *PxTransform, compoundHandle: *PxSQCompoundHandle = null, hasPruningStructure := false) { this.pxscenequerysystem_vtable.addSQShape(this, actor, shape, bounds, transform, compoundHandle, hasPruningStructure); }

    PxSceneQuerySystem_removeSQShape :: inline (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape) { this.pxscenequerysystem_vtable.removeSQShape(this, actor, shape); }

    PxSceneQuerySystem_updateSQShape :: inline (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape, transform: *PxTransform) { this.pxscenequerysystem_vtable.updateSQShape(this, actor, shape, transform); }

    PxSceneQuerySystem_addSQCompound :: inline (this: *PxSceneQuerySystem, actor: *PxRigidActor, shapes: **PxShape, bvh: *PxBVH, transforms: *PxTransform) -> PxSQCompoundHandle { return this.pxscenequerysystem_vtable.addSQCompound(this, actor, shapes, bvh, transforms); }

    PxSceneQuerySystem_removeSQCompound :: inline (this: *PxSceneQuerySystem, compoundHandle: PxSQCompoundHandle) { this.pxscenequerysystem_vtable.removeSQCompound(this, compoundHandle); }

    PxSceneQuerySystem_updateSQCompound :: inline (this: *PxSceneQuerySystem, compoundHandle: PxSQCompoundHandle, compoundTransform: *PxTransform) { this.pxscenequerysystem_vtable.updateSQCompound(this, compoundHandle, compoundTransform); }

    PxSceneQuerySystem_shiftOrigin :: inline (this: *PxSceneQuerySystem, shift: *PxVec3) { this.pxscenequerysystem_vtable.shiftOrigin(this, shift); }

    PxSceneQuerySystem_visualize :: inline (this: *PxSceneQuerySystem, prunerIndex: PxU32, out: *PxRenderOutput) { this.pxscenequerysystem_vtable.visualize(this, prunerIndex, out); }

    PxSceneQuerySystem_merge :: inline (this: *PxSceneQuerySystem, pruningStructure: *PxPruningStructure) { this.pxscenequerysystem_vtable.merge(this, pruningStructure); }

    PxSceneQuerySystem_getHandle :: inline (this: *PxSceneQuerySystem, actor: *PxRigidActor, shape: *PxShape, prunerIndex: *PxU32) -> PxSQPrunerHandle { return this.pxscenequerysystem_vtable.getHandle(this, actor, shape, prunerIndex); }

    PxSceneQuerySystem_sync :: inline (this: *PxSceneQuerySystem, prunerIndex: PxU32, handles: *PxSQPrunerHandle, indices: *PxU32, bounds: *PxBounds3, transforms: *PxTransform32, count: PxU32, ignoredIndices: *PxBitMap) { this.pxscenequerysystem_vtable.sync(this, prunerIndex, handles, indices, bounds, transforms, count, ignoredIndices); }

    PxSceneQuerySystem_finalizeUpdates :: inline (this: *PxSceneQuerySystem) { this.pxscenequerysystem_vtable.finalizeUpdates(this); }

    PxSceneQuerySystem_prepareSceneQueryBuildStep :: inline (this: *PxSceneQuerySystem, prunerIndex: PxU32) -> PxSQBuildStepHandle { return this.pxscenequerysystem_vtable.prepareSceneQueryBuildStep(this, prunerIndex); }

    PxSceneQuerySystem_sceneQueryBuildStep :: inline (this: *PxSceneQuerySystem, handle: PxSQBuildStepHandle) { this.pxscenequerysystem_vtable.sceneQueryBuildStep(this, handle); }

    vtable :: (obj: *PxSceneQuerySystem) -> *PxSceneQuerySystem_VTable { return obj.pxscenequerysystem_vtable; }


    /*
    \brief Broad phase algorithm used in the simulation
    
    eSAP is a good generic choice with great performance when many objects are sleeping. Performance
    can degrade significantly though, when all objects are moving, or when large numbers of objects
    are added to or removed from the broad phase. This algorithm does not need world bounds to be
    defined in order to work.
    
    eMBP is an alternative broad phase algorithm that does not suffer from the same performance
    issues as eSAP when all objects are moving or when inserting large numbers of objects. However
    its generic performance when many objects are sleeping might be inferior to eSAP, and it requires
    users to define world bounds in order to work.
    
    eABP is a revisited implementation of MBP, which automatically manages broad-phase regions.
    It offers the convenience of eSAP (no need to define world bounds or regions) and the performance
    of eMBP when a lot of objects are moving. While eSAP can remain faster when most objects are
    sleeping and eMBP can remain faster when it uses a large number of properly-defined regions,
    eABP often gives the best performance on average and the best memory usage.
    
    ePABP is a parallel implementation of ABP. It can often be the fastest (CPU) broadphase, but it
    can use more memory than ABP.
    
    eGPU is a GPU implementation of the incremental sweep and prune approach. Additionally, it uses a ABP-style
    initial pair generation approach to avoid large spikes when inserting shapes. It not only has the advantage
    of traditional SAP approch which is good for when many objects are sleeping, but due to being fully parallel,
    it also is great when lots of shapes are moving or for runtime pair insertion and removal. It can become a
    performance bottleneck if there are a very large number of shapes roughly projecting to the same values
    on a given axis. If the scene has a very large number of shapes in an actor, e.g. a humanoid, it is recommended
    to use an aggregate to represent multi-shape or multi-body actors to minimize stress placed on the broad phase.
    */
    PxBroadPhaseType :: struct {
        Enum :: enum s32 {
            SAP  :: 0;
            MBP  :: 1;
            ABP  :: 2;
            PABP :: 3;
            GPU  :: 4;
            LAST :: 5;

            eSAP  :: SAP;
            eMBP  :: MBP;
            eABP  :: ABP;
            ePABP :: PABP;
            eGPU  :: GPU;
            eLAST :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief "Region of interest" for the broad-phase.
    
    This is currently only used for the PxBroadPhaseType::eMBP broad-phase, which requires zones or regions to be defined
    when the simulation starts in order to work. Regions can overlap and be added or removed at runtime, but at least one
    region needs to be defined when the scene is created.
    
    If objects that do no overlap any region are inserted into the scene, they will not be added to the broad-phase and
    thus collisions will be disabled for them. A PxBroadPhaseCallback out-of-bounds notification will be sent for each one
    of those objects.
    
    The total number of regions is limited by PxBroadPhaseCaps::mMaxNbRegions.
    
    The number of regions has a direct impact on performance and memory usage, so it is recommended to experiment with
    various settings to find the best combination for your game. A good default setup is to start with global bounds
    around the whole world, and subdivide these bounds into 4*4 regions. The PxBroadPhaseExt::createRegionsFromWorldBounds
    function can do that for you.
    
    \see PxBroadPhaseCallback PxBroadPhaseExt.createRegionsFromWorldBounds
    */
    PxBroadPhaseRegion :: struct {
        mBounds:   PxBounds3; //!< Region's bounds
        mUserData: *void; //!< Region's user-provided data
    }

    /*
    \brief Information & stats structure for a region
    */
    PxBroadPhaseRegionInfo :: struct {
        mRegion:           PxBroadPhaseRegion; //!< User-provided region data
        mNbStaticObjects:  PxU32; //!< Number of static objects in the region
        mNbDynamicObjects: PxU32; //!< Number of dynamic objects in the region
        mActive:           bool; //!< True if region is currently used, i.e. it has not been removed
        mOverlap:          bool; //!< True if region overlaps other regions (regions that are just touching are not considering overlapping)
    }

    /*
    \brief Caps class for broad phase.
    */
    PxBroadPhaseCaps :: struct {
        mMaxNbRegions: PxU32; //!< Max number of regions supported by the broad-phase (0 = explicit regions not needed)
    }

    /*
    \brief Broadphase descriptor.
    
    This structure is used to create a standalone broadphase. It captures all the parameters needed to
    initialize a broadphase.
    
    For the GPU broadphase (PxBroadPhaseType::eGPU) it is necessary to provide a CUDA context manager.
    
    The kinematic filtering flags are currently not supported by the GPU broadphase. They are used to
    dismiss pairs that involve kinematic objects directly within the broadphase.
    
    \see	PxCreateBroadPhase
    */
    PxBroadPhaseDesc :: struct {
        mType:                        PxBroadPhaseType.Enum; //!< Desired broadphase implementation
        mContextID:                   PxU64; //!< Context ID for profiler. See PxProfilerCallback.

        mContextManager:              *PxCudaContextManager; //!< (GPU) CUDA context manager, must be provided for PxBroadPhaseType::eGPU.
        mFoundLostPairsCapacity:      PxU32; //!< (GPU) Capacity of found and lost buffers allocated in GPU global memory. This is used for the found/lost pair reports in the BP.

        mDiscardStaticVsKinematic:    bool; //!< Static-vs-kinematic filtering flag. Not supported by PxBroadPhaseType::eGPU.
        mDiscardKinematicVsKinematic: bool; //!< kinematic-vs-kinematic filtering flag. Not supported by PxBroadPhaseType::eGPU.

        isValid :: (this: *PxBroadPhaseDesc) -> bool #cpp_method #foreign physx_static "?isValid@PxBroadPhaseDesc@physx@@QEBA_NXZ";
    }

    PxBpIndex :: PxU32;
    PxBpFilterGroup :: PxU32;

    /*
    \brief Broadphase data update structure.
    
    This structure is used to update the low-level broadphase (PxBroadPhase). All added, updated and removed objects
    must be batched and submitted at once to the broadphase.
    
    Broadphase objects have bounds, a filtering group, and a distance. With the low-level broadphase the data must be
    externally managed by the clients of the broadphase API, and passed to the update function.
    
    The provided bounds are non-inflated "base" bounds that can be further extended by the broadphase using the passed
    distance value. These can be contact offsets, or dynamically updated distance values for e.g. speculative contacts.
    Either way they are optional and can be left to zero. The broadphase implementations efficiently combine the base
    bounds with the per-object distance values at runtime.
    
    The per-object filtering groups are used to discard some pairs directly within the broadphase, which is more
    efficient than reporting the pairs and culling them in a second pass.
    
    \see	PxBpFilterGroup PxBpIndex PxBounds3 PxBroadPhase::update
    */
    PxBroadPhaseUpdateData :: struct {
        Constructor :: (this: *PxBroadPhaseUpdateData, created: *PxBpIndex, nbCreated: PxU32, updated: *PxBpIndex, nbUpdated: PxU32, removed: *PxBpIndex, nbRemoved: PxU32, bounds: *PxBounds3, groups: *PxBpFilterGroup, distances: *float, capacity: PxU32) -> void #cpp_method #foreign physx_static "??0PxBroadPhaseUpdateData@physx@@QEAA@PEBII0I0IPEBVPxBounds3@1@0PEBMI@Z";

        mCreated:   *PxBpIndex; //!< Indices of created objects.
        mNbCreated: PxU32; //!< Number of created objects.

        mUpdated:   *PxBpIndex; //!< Indices of updated objects.
        mNbUpdated: PxU32; //!< Number of updated objects.

        mRemoved:   *PxBpIndex; //!< Indices of removed objects.
        mNbRemoved: PxU32; //!< Number of removed objects.

        mBounds:    *PxBounds3; //!< (Persistent) array of bounds.
        mGroups:    *PxBpFilterGroup; //!< (Persistent) array of groups.
        mDistances: *float; //!< (Persistent) array of distances.
        mCapacity:  PxU32; //!< Capacity of bounds / groups / distance buffers.
    }

    /*
    \brief Broadphase pair.
    
    A pair of indices returned by the broadphase for found or lost pairs.
    
    \see	PxBroadPhaseResults
    */
    PxBroadPhasePair :: struct {
        mID0: PxBpIndex; //!< Index of first object
        mID1: PxBpIndex; //!< Index of second object
    }

    /*
    \brief Broadphase results.
    
    Set of found and lost pairs after a broadphase update.
    
    \see	PxBroadPhasePair PxBroadPhase::fetchResults PxAABBManager::fetchResults
    */
    PxBroadPhaseResults :: struct {
        mNbCreatedPairs: PxU32; //!< Number of new/found/created pairs.
        mCreatedPairs:   *PxBroadPhasePair; //!< Array of new/found/created pairs.

        mNbDeletedPairs: PxU32; //!< Number of lost/deleted pairs.
        mDeletedPairs:   *PxBroadPhasePair; //!< Array of lost/deleted pairs.
    }

    /*
    \brief Broadphase regions.
    
    An API to manage broadphase regions. Only needed for the MBP broadphase (PxBroadPhaseType::eMBP).
    
    \see	PxBroadPhase::getRegions()
    */
    PxBroadPhaseRegions :: struct {
        vtable: *PxBroadPhaseRegions_VTable;
        Constructor :: (this: *PxBroadPhaseRegions) -> void #cpp_method #foreign physx_static "??0PxBroadPhaseRegions@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxBroadPhaseRegions, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxBroadPhaseRegions@physx@@MEAA@XZ";
    }
    PxBroadPhaseRegions_VTable :: struct #type_info_none {
        Destructor: (this: *PxBroadPhaseRegions, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        getNbRegions: (this: *PxBroadPhaseRegions) -> PxU32 #cpp_method;

        getRegions: (this: *PxBroadPhaseRegions, userBuffer: *PxBroadPhaseRegionInfo, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        addRegion: (this: *PxBroadPhaseRegions, region: *PxBroadPhaseRegion, populateRegion: bool, bounds: *PxBounds3, distances: *float) -> PxU32 #cpp_method;

        removeRegion: (this: *PxBroadPhaseRegions, handle: PxU32) -> bool #cpp_method;

        getNbOutOfBoundsObjects: (this: *PxBroadPhaseRegions) -> PxU32 #cpp_method;

        getOutOfBoundsObjects: (this: *PxBroadPhaseRegions) -> *PxU32 #cpp_method;
    }

    PxBroadPhaseRegions_Destructor :: inline (this: *PxBroadPhaseRegions, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBroadPhaseRegions_getNbRegions :: inline (this: *PxBroadPhaseRegions) -> PxU32 { return this.vtable.getNbRegions(this); }

    PxBroadPhaseRegions_getRegions :: inline (this: *PxBroadPhaseRegions, userBuffer: *PxBroadPhaseRegionInfo, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.vtable.getRegions(this, userBuffer, bufferSize, startIndex); }

    PxBroadPhaseRegions_addRegion :: inline (this: *PxBroadPhaseRegions, region: *PxBroadPhaseRegion, populateRegion: bool, bounds: *PxBounds3, distances: *float) -> PxU32 { return this.vtable.addRegion(this, region, populateRegion, bounds, distances); }

    PxBroadPhaseRegions_removeRegion :: inline (this: *PxBroadPhaseRegions, handle: PxU32) -> bool { return this.vtable.removeRegion(this, handle); }

    PxBroadPhaseRegions_getNbOutOfBoundsObjects :: inline (this: *PxBroadPhaseRegions) -> PxU32 { return this.vtable.getNbOutOfBoundsObjects(this); }

    PxBroadPhaseRegions_getOutOfBoundsObjects :: inline (this: *PxBroadPhaseRegions) -> *PxU32 { return this.vtable.getOutOfBoundsObjects(this); }

    vtable :: (obj: *PxBroadPhaseRegions) -> *PxBroadPhaseRegions_VTable { return obj.vtable; }


    /*
    \brief Low-level broadphase API.
    
    This low-level API only supports batched updates and leaves most of the data management to its clients.
    
    This is useful if you want to use the broadphase with your own memory buffers. Note however that the GPU broadphase
    works best with buffers allocated in CUDA memory. The getAllocator() function returns an allocator that is compatible
    with the selected broadphase. It is recommended to allocate and deallocate the broadphase data (bounds, groups, distances)
    using this allocator.
    
    Important note: it must be safe to load 4 bytes past the end of the provided bounds array.
    
    The high-level broadphase API (PxAABBManager) is an easier-to-use interface that automatically deals with these requirements.
    
    \see	PxCreateBroadPhase
    */
    PxBroadPhase :: struct {
        vtable: *PxBroadPhase_VTable;
        Constructor :: (this: *PxBroadPhase) -> void #cpp_method #foreign physx_static "??0PxBroadPhase@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxBroadPhase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxBroadPhase@physx@@MEAA@XZ";
    }
    PxBroadPhase_VTable :: struct #type_info_none {
        Destructor: (this: *PxBroadPhase, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        release: (this: *PxBroadPhase) -> void #cpp_method;

        getType: (this: *PxBroadPhase) -> PxBroadPhaseType.Enum #cpp_method;

        getCaps: (this: *PxBroadPhase, caps: *PxBroadPhaseCaps) -> void #cpp_method;

        getRegions: (this: *PxBroadPhase) -> *PxBroadPhaseRegions #cpp_method;

        getAllocator: (this: *PxBroadPhase) -> *PxAllocatorCallback #cpp_method;

        getContextID: (this: *PxBroadPhase) -> PxU64 #cpp_method;

        setScratchBlock: (this: *PxBroadPhase, scratchBlock: *void, size: PxU32) -> void #cpp_method;

        update: (this: *PxBroadPhase, updateData: *PxBroadPhaseUpdateData, continuation: *PxBaseTask = null) -> void #cpp_method;

        fetchResults: (this: *PxBroadPhase, results: *PxBroadPhaseResults) -> void #cpp_method;
    }

    PxBroadPhase_Destructor :: inline (this: *PxBroadPhase, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBroadPhase_release :: inline (this: *PxBroadPhase) { this.vtable.release(this); }

    PxBroadPhase_getType :: inline (this: *PxBroadPhase) -> PxBroadPhaseType.Enum { return this.vtable.getType(this); }

    PxBroadPhase_getCaps :: inline (this: *PxBroadPhase, caps: *PxBroadPhaseCaps) { this.vtable.getCaps(this, caps); }

    PxBroadPhase_getRegions :: inline (this: *PxBroadPhase) -> *PxBroadPhaseRegions { return this.vtable.getRegions(this); }

    PxBroadPhase_getAllocator :: inline (this: *PxBroadPhase) -> *PxAllocatorCallback { return this.vtable.getAllocator(this); }

    PxBroadPhase_getContextID :: inline (this: *PxBroadPhase) -> PxU64 { return this.vtable.getContextID(this); }

    PxBroadPhase_setScratchBlock :: inline (this: *PxBroadPhase, scratchBlock: *void, size: PxU32) { this.vtable.setScratchBlock(this, scratchBlock, size); }

    PxBroadPhase_update :: inline (this: *PxBroadPhase, updateData: *PxBroadPhaseUpdateData, continuation: *PxBaseTask = null) { this.vtable.update(this, updateData, continuation); }

    PxBroadPhase_fetchResults :: inline (this: *PxBroadPhase, results: *PxBroadPhaseResults) { this.vtable.fetchResults(this, results); }

    vtable :: (obj: *PxBroadPhase) -> *PxBroadPhase_VTable { return obj.vtable; }


    /*
    \brief High-level broadphase API.
    
    The low-level broadphase API (PxBroadPhase) only supports batched updates and has a few non-trivial
    requirements for managing the bounds data.
    
    The high-level broadphase API (PxAABBManager) is an easier-to-use one-object-at-a-time API that
    automatically deals with the quirks of the PxBroadPhase data management.
    
    \see	PxCreateAABBManager
    */
    PxAABBManager :: struct {
        vtable: *PxAABBManager_VTable;
        Constructor :: (this: *PxAABBManager) -> void #cpp_method #foreign physx_static "??0PxAABBManager@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxAABBManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxAABBManager@physx@@MEAA@XZ";
    }
    PxAABBManager_VTable :: struct #type_info_none {
        Destructor: (this: *PxAABBManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        release: (this: *PxAABBManager) -> void #cpp_method;

        getBroadPhase: (this: *PxAABBManager) -> *PxBroadPhase #cpp_method;

        getBounds: (this: *PxAABBManager) -> *PxBounds3 #cpp_method;

        getDistances: (this: *PxAABBManager) -> *float #cpp_method;

        getGroups: (this: *PxAABBManager) -> *PxBpFilterGroup #cpp_method;

        getCapacity: (this: *PxAABBManager) -> PxU32 #cpp_method;

        addObject: (this: *PxAABBManager, index: PxBpIndex, bounds: *PxBounds3, group: PxBpFilterGroup, distance: float = 0.0) -> void #cpp_method;

        removeObject: (this: *PxAABBManager, index: PxBpIndex) -> void #cpp_method;

        updateObject: (this: *PxAABBManager, index: PxBpIndex, bounds: *PxBounds3 = null, distance: *float = null) -> void #cpp_method;

        update: (this: *PxAABBManager, continuation: *PxBaseTask = null) -> void #cpp_method;

        fetchResults: (this: *PxAABBManager, results: *PxBroadPhaseResults) -> void #cpp_method;
    }

    PxAABBManager_Destructor :: inline (this: *PxAABBManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxAABBManager_release :: inline (this: *PxAABBManager) { this.vtable.release(this); }

    PxAABBManager_getBroadPhase :: inline (this: *PxAABBManager) -> *PxBroadPhase { return this.vtable.getBroadPhase(this); }

    PxAABBManager_getBounds :: inline (this: *PxAABBManager) -> *PxBounds3 { return this.vtable.getBounds(this); }

    PxAABBManager_getDistances :: inline (this: *PxAABBManager) -> *float { return this.vtable.getDistances(this); }

    PxAABBManager_getGroups :: inline (this: *PxAABBManager) -> *PxBpFilterGroup { return this.vtable.getGroups(this); }

    PxAABBManager_getCapacity :: inline (this: *PxAABBManager) -> PxU32 { return this.vtable.getCapacity(this); }

    PxAABBManager_addObject :: inline (this: *PxAABBManager, index: PxBpIndex, bounds: *PxBounds3, group: PxBpFilterGroup, distance: float = 0.0) { this.vtable.addObject(this, index, bounds, group, distance); }

    PxAABBManager_removeObject :: inline (this: *PxAABBManager, index: PxBpIndex) { this.vtable.removeObject(this, index); }

    PxAABBManager_updateObject :: inline (this: *PxAABBManager, index: PxBpIndex, bounds: *PxBounds3 = null, distance: *float = null) { this.vtable.updateObject(this, index, bounds, distance); }

    PxAABBManager_update :: inline (this: *PxAABBManager, continuation: *PxBaseTask = null) { this.vtable.update(this, continuation); }

    PxAABBManager_fetchResults :: inline (this: *PxAABBManager, results: *PxBroadPhaseResults) { this.vtable.fetchResults(this, results); }

    vtable :: (obj: *PxAABBManager) -> *PxAABBManager_VTable { return obj.vtable; }


    /*
    \brief Enum for selecting the friction algorithm used for simulation.
    
    #PxFrictionType::ePATCH is the default friction logic (Couloumb type friction model). Friction gets computed per contact patch.
    Up to two contact points lying in the contact patch area are selected as friction anchors to which friction impulses are applied. If there
    are more than two contact points, to select anchors from, the anchors are selected using a heuristic that tries to maximize the distance
    between the anchors within the contact patch area. For each contact patch, two perpendicular axes of the contact patch plane are selected.
    A 1D-constraint along each of the two axes is used to implement friction at a friction anchor point. Note that the two axes are processed
    separately when the PGS solver type is selected. This can lead to asymmetries when transitioning from dynamic to static friction and vice
    versa in certain edge cases. The TGS solver type, on the other hand, works with the combined impulse along the two axes and as such avoids
    this potential problem, but this is slightly more computationally expensive. Another difference between TGS and PGS is that TGS applies
    friction throughout all position and all velocity iterations, while PGS by default applies friction throughout the last 3 position iterations
    and all velocity iterations (unless #PxSceneFlag::eENABLE_FRICTION_EVERY_ITERATION is used).
    
    #PxFrictionType::eFRICTION_COUNT is the total number of friction models supported by the SDK.
    */
    PxFrictionType :: struct {
        Enum :: enum s32 {
            PATCH           :: 0;
            ONE_DIRECTIONAL :: 1;
            TWO_DIRECTIONAL :: 2;
            FRICTION_COUNT  :: 3;

            ePATCH           :: PATCH;
            eONE_DIRECTIONAL :: ONE_DIRECTIONAL;
            eTWO_DIRECTIONAL :: TWO_DIRECTIONAL;
            eFRICTION_COUNT  :: FRICTION_COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Enum for selecting the type of solver used for the simulation.
    
    #PxSolverType::ePGS selects the iterative sequential impulse solver. This is the same kind of solver used in PhysX 3.4 and earlier releases.
    
    #PxSolverType::eTGS selects a non linear iterative solver. This kind of solver can lead to improved convergence and handle large mass ratios, long chains and jointed systems better. It is slightly more expensive than the default solver and can introduce more energy to correct joint and contact errors.
    */
    PxSolverType :: struct {
        Enum :: enum s32 {
            PGS :: 0;
            TGS :: 1;

            ePGS :: PGS;
            eTGS :: TGS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief flags for configuring properties of the scene
    
    \see PxScene
    */
    PxSceneFlag :: struct {
        Enum :: enum s32 {
            ENABLE_ACTIVE_ACTORS                       :: 1;

            ENABLE_CCD                                 :: 2;

            DISABLE_CCD_RESWEEP                        :: 4;

            ENABLE_PCM                                 :: 64;

            DISABLE_CONTACT_REPORT_BUFFER_RESIZE       :: 128;

            DISABLE_CONTACT_CACHE                      :: 256;

            REQUIRE_RW_LOCK                            :: 512;

            ENABLE_STABILIZATION                       :: 1024;

            ENABLE_AVERAGE_POINT                       :: 2048;

            EXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS      :: 4096;

            ENABLE_GPU_DYNAMICS                        :: 8192;

            ENABLE_ENHANCED_DETERMINISM                :: 16384;

            ENABLE_FRICTION_EVERY_ITERATION            :: 32768;

            ENABLE_EXTERNAL_FORCES_EVERY_ITERATION_TGS :: 65536;

            ENABLE_DIRECT_GPU_API                      :: 131072;

            ENABLE_BODY_ACCELERATIONS                  :: 262144;

            ENABLE_SOLVER_RESIDUAL_REPORTING           :: 524288;

            MUTABLE_FLAGS                              :: 4097;

            eENABLE_ACTIVE_ACTORS                       :: ENABLE_ACTIVE_ACTORS;

            eENABLE_CCD                                 :: ENABLE_CCD;

            eDISABLE_CCD_RESWEEP                        :: DISABLE_CCD_RESWEEP;

            eENABLE_PCM                                 :: ENABLE_PCM;

            eDISABLE_CONTACT_REPORT_BUFFER_RESIZE       :: DISABLE_CONTACT_REPORT_BUFFER_RESIZE;

            eDISABLE_CONTACT_CACHE                      :: DISABLE_CONTACT_CACHE;

            eREQUIRE_RW_LOCK                            :: REQUIRE_RW_LOCK;

            eENABLE_STABILIZATION                       :: ENABLE_STABILIZATION;

            eENABLE_AVERAGE_POINT                       :: ENABLE_AVERAGE_POINT;

            eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS      :: EXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS;

            eENABLE_GPU_DYNAMICS                        :: ENABLE_GPU_DYNAMICS;

            eENABLE_ENHANCED_DETERMINISM                :: ENABLE_ENHANCED_DETERMINISM;

            eENABLE_FRICTION_EVERY_ITERATION            :: ENABLE_FRICTION_EVERY_ITERATION;

            eENABLE_EXTERNAL_FORCES_EVERY_ITERATION_TGS :: ENABLE_EXTERNAL_FORCES_EVERY_ITERATION_TGS;

            eENABLE_DIRECT_GPU_API                      :: ENABLE_DIRECT_GPU_API;

            eENABLE_BODY_ACCELERATIONS                  :: ENABLE_BODY_ACCELERATIONS;

            eENABLE_SOLVER_RESIDUAL_REPORTING           :: ENABLE_SOLVER_RESIDUAL_REPORTING;

            eMUTABLE_FLAGS                              :: MUTABLE_FLAGS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxSceneFlag.
    
    \see PxSceneFlag
    */
    PxSceneFlags :: PxFlags(PxSceneFlag.Enum, PxU32);

    /*
    \brief Class used to retrieve limits(e.g. maximum number of bodies) for a scene. The limits
    are used as a hint to the size of the scene, not as a hard limit (i.e. it will be possible
    to create more objects than specified in the scene limits).
    
    0 indicates no limit. Using limits allows the SDK to preallocate various arrays, leading to
    less re-allocations and faster code at runtime.
    */
    PxSceneLimits :: struct {
        maxNbActors:             PxU32; //!< Expected maximum number of actors
        maxNbBodies:             PxU32; //!< Expected maximum number of dynamic rigid bodies
        maxNbStaticShapes:       PxU32; //!< Expected maximum number of static shapes
        maxNbDynamicShapes:      PxU32; //!< Expected maximum number of dynamic shapes
        maxNbAggregates:         PxU32; //!< Expected maximum number of aggregates
        maxNbConstraints:        PxU32; //!< Expected maximum number of constraint shaders
        maxNbRegions:            PxU32; //!< Expected maximum number of broad-phase regions
        maxNbBroadPhaseOverlaps: PxU32; //!< Expected maximum number of broad-phase overlaps

        /*
        \brief constructor sets to default
        */
        Constructor :: (this: *PxSceneLimits) -> void #cpp_method #foreign physx_static "??0PxSceneLimits@physx@@QEAA@XZ";
    }

    //#if PX_SUPPORT_GPU_PHYSX
    /*
    \brief Sizes of pre-allocated buffers use for GPU dynamics
    */
    PxGpuDynamicsMemoryConfig :: struct {
        tempBufferCapacity:              PxU64; //!< Initial capacity of temp solver buffer allocated in pinned host memory. This buffer will grow if more memory is needed than specified here.
        maxRigidContactCount:            PxU32; //!< Size of contact stream buffer allocated in pinned host memory. This is double-buffered so total allocation size = 2* contactStreamCapacity * sizeof(PxContact).
        maxRigidPatchCount:              PxU32; //!< Size of the contact patch stream buffer allocated in pinned host memory. This is double-buffered so total allocation size = 2 * patchStreamCapacity * sizeof(PxContactPatch).
        heapCapacity:                    PxU32; //!< Initial capacity of the GPU and pinned host memory heaps. Additional memory will be allocated if more memory is required.
        foundLostPairsCapacity:          PxU32; //!< Capacity of found and lost buffers allocated in GPU global memory. This is used for the found/lost pair reports in the BP. 
        foundLostAggregatePairsCapacity: PxU32; //!< Capacity of found and lost buffers in aggregate system allocated in GPU global memory. This is used for the found/lost pair reports in AABB manager.
        totalAggregatePairsCapacity:     PxU32; //!< Capacity of aggregate pair buffer allocated in GPU global memory.
        maxSoftBodyContacts:             PxU32; //!< Capacity of softbody contact buffer allocated in GPU global memory.
        maxFemClothContacts:             PxU32; //!< Capacity of femCloth contact buffer allocated in GPU global memory.
        maxParticleContacts:             PxU32; //!< Capacity of particle contact buffer allocated in GPU global memory.
        collisionStackSize:              PxU32; //!< Capacity of the collision stack buffer, used as scratch space during narrowphase collision detection.
        maxHairContacts:                 PxU32; //!< Capacity of hair system contact buffer allocated in GPU global memory.

        Constructor :: (this: *PxGpuDynamicsMemoryConfig) -> void #cpp_method #foreign physx_static "??0PxGpuDynamicsMemoryConfig@physx@@QEAA@XZ";

        isValid :: (this: *PxGpuDynamicsMemoryConfig) -> bool #cpp_method #foreign physx_static "?isValid@PxGpuDynamicsMemoryConfig@physx@@QEBA_NXZ";
    }

    /*
    \brief Descriptor class for scenes. See #PxScene.
    
    This struct must be initialized with the same PxTolerancesScale values used to initialize PxPhysics.
    
    \see PxScene PxPhysics.createScene PxTolerancesScale
    */
    PxSceneDesc :: struct {
        #as using pxscenequerydesc: PxSceneQueryDesc;

        /*
        \brief Gravity vector.
        
        <b>Range:</b> force vector<br>
        <b>Default:</b> Zero
        
        \see PxScene.setGravity() PxScene.getGravity()
        
        When setting gravity, you should probably also set bounce threshold.
        */
        gravity:                       PxVec3;

        /*
        \brief Possible notification callback.
        
        <b>Default:</b> NULL
        
        \see PxSimulationEventCallback PxScene.setSimulationEventCallback() PxScene.getSimulationEventCallback()
        */
        simulationEventCallback:       *PxSimulationEventCallback;

        /*
        \brief Possible asynchronous callback for contact modification.
        
        <b>Default:</b> NULL
        
        \see PxContactModifyCallback PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
        */
        contactModifyCallback:         *PxContactModifyCallback;

        /*
        \brief Possible asynchronous callback for contact modification.
        
        <b>Default:</b> NULL
        
        \see PxContactModifyCallback PxScene.setContactModifyCallback() PxScene.getContactModifyCallback()
        */
        ccdContactModifyCallback:      *PxCCDContactModifyCallback;

        /*
        \brief Shared global filter data which will get passed into the filter shader.
        
        \note The provided data will get copied to internal buffers and this copy will be used for filtering calls.
        
        <b>Default:</b> NULL
        
        \see PxSimulationFilterShader PxScene.setFilterShaderData() PxScene.getFilterShaderData()
        */
        filterShaderData:              *void;

        /*
        \brief Size (in bytes) of the shared global filter data #filterShaderData.
        
        <b>Default:</b> 0
        
        \see PxSimulationFilterShader filterShaderData PxScene.getFilterShaderDataSize()
        */
        filterShaderDataSize:          PxU32;

        /*
        \brief The custom filter shader to use for collision filtering.
        
        \note This parameter is compulsory. If you don't want to define your own filter shader you can
        use the default shader #PxDefaultSimulationFilterShader which can be found in the PhysX extensions
        library.
        
        \see PxSimulationFilterShader PxScene.getFilterShader()
        */
        filterShader:                  PxSimulationFilterShader;

        /*
        \brief A custom collision filter callback which can be used to implement more complex filtering operations which need
        access to the simulation state, for example.
        
        <b>Default:</b> NULL
        
        \see PxSimulationFilterCallback PxScene.getFilterCallback()
        */
        filterCallback:                *PxSimulationFilterCallback;

        /*
        \brief Filtering mode for kinematic-kinematic pairs in the broadphase.
        
        <b>Default:</b> PxPairFilteringMode::eDEFAULT
        
        \see PxPairFilteringMode PxScene.getKinematicKinematicFilteringMode()
        */
        kineKineFilteringMode:         PxPairFilteringMode.Enum;

        /*
        \brief Filtering mode for static-kinematic pairs in the broadphase.
        
        <b>Default:</b> PxPairFilteringMode::eDEFAULT
        
        \see PxPairFilteringMode PxScene.getStaticKinematicFilteringMode()
        */
        staticKineFilteringMode:       PxPairFilteringMode.Enum;

        /*
        \brief Selects the broad-phase algorithm to use.
        
        <b>Default:</b> PxBroadPhaseType::ePABP
        
        \see PxBroadPhaseType PxScene.getBroadPhaseType()
        */
        broadPhaseType:                PxBroadPhaseType.Enum;

        /*
        \brief Broad-phase callback
        
        <b>Default:</b> NULL
        
        \see PxBroadPhaseCallback PxScene.getBroadPhaseCallback() PxScene.setBroadPhaseCallback()
        */
        broadPhaseCallback:            *PxBroadPhaseCallback;

        /*
        \brief Expected scene limits.
        
        \see PxSceneLimits PxScene.getLimits()
        */
        limits:                        PxSceneLimits;

        /*
        \brief Selects the friction algorithm to use for simulation.
        
        \note frictionType cannot be modified after the first call to any of PxScene::simulate, PxScene::solve and PxScene::collide
        
        <b>Default:</b> PxFrictionType::ePATCH
        
        \see PxFrictionType PxScene.setFrictionType(), PxScene.getFrictionType()
        */
        frictionType:                  PxFrictionType.Enum;

        /*
        \brief Selects the solver algorithm to use.
        
        <b>Default:</b> PxSolverType::ePGS
        
        \see PxSolverType PxScene.getSolverType()
        */
        solverType:                    PxSolverType.Enum;

        /*
        \brief A contact with a relative velocity below this will not bounce. A typical value for simulation.
        stability is about 0.2 * gravity.
        
        <b>Range:</b> (0, PX_MAX_F32)<br>
        <b>Default:</b> 0.2 * PxTolerancesScale::speed
        
        \see PxMaterial PxScene.setBounceThresholdVelocity() PxScene.getBounceThresholdVelocity()
        */
        bounceThresholdVelocity:       PxReal;

        /*
        \brief A threshold of contact separation distance used to decide if a contact point will experience friction forces.
        
        \note If the separation distance of a contact point is greater than the threshold then the contact point will not experience friction forces.
        
        \note If the aggregated contact offset of a pair of shapes is large it might be desirable to neglect friction
        for contact points whose separation distance is sufficiently large that the shape surfaces are clearly separated.
        
        \note This parameter can be used to tune the separation distance of contact points at which friction starts to have an effect.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.04 * PxTolerancesScale::length
        
        \see PxScene.setFrictionOffsetThreshold() PxScene.getFrictionOffsetThreshold()
        */
        frictionOffsetThreshold:       PxReal;

        /*
        \brief Friction correlation distance used to decide whether contacts are close enough to be merged into a single friction anchor point or not.
        
        \note If the correlation distance is larger than the distance between contact points generated between a pair of shapes, some of the contacts may not experience frictional forces.
        
        \note This parameter can be used to tune the correlation distance used in the solver. Contact points can be merged into a single friction anchor if the distance between the contacts is smaller than correlation distance.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.025f * PxTolerancesScale::length
        
        \see PxScene.setFrictionCorrelationDistance() PxScene.getFrictionCorrelationDistance()
        */
        frictionCorrelationDistance:   PxReal;

        /*
        \brief Flags used to select scene options.
        
        <b>Default:</b> PxSceneFlag::eENABLE_PCM
        
        \see PxSceneFlag PxSceneFlags PxScene.getFlags() PxScene.setFlag()
        */
        flags:                         PxSceneFlags;

        /*
        \brief The CPU task dispatcher for the scene.
        
        \see PxCpuDispatcher, PxScene::getCpuDispatcher
        */
        cpuDispatcher:                 *PxCpuDispatcher;

        /*
        \brief The CUDA context manager for the scene.
        
        <b>Platform specific:</b> Applies to PC GPU only.
        
        \see PxCudaContextManager, PxScene::getCudaContextManager
        */
        cudaContextManager:            *PxCudaContextManager;

        /*
        \brief Will be copied to PxScene::userData.
        
        <b>Default:</b> NULL
        */
        userData:                      *void;

        /*
        \brief Defines the number of actors required to spawn a separate rigid body solver island task chain.
        
        This parameter defines the minimum number of actors required to spawn a separate rigid body solver task chain. Setting a low value
        will potentially cause more task chains to be generated. This may result in the overhead of spawning tasks can become a limiting performance factor.
        Setting a high value will potentially cause fewer islands to be generated. This may reduce thread scaling (fewer task chains spawned) and may
        detrimentally affect performance if some bodies in the scene have large solver iteration counts because all constraints in a given island are solved by the
        maximum number of solver iterations requested by any body in the island.
        
        Note that a rigid body solver task chain is spawned as soon as either a sufficient number of rigid bodies or articulations are batched together.
        
        <b>Default:</b> 128
        
        \see PxScene.setSolverBatchSize() PxScene.getSolverBatchSize()
        */
        solverBatchSize:               PxU32;

        /*
        \brief Defines the number of articulations required to spawn a separate rigid body solver island task chain.
        
        This parameter defines the minimum number of articulations required to spawn a separate rigid body solver task chain. Setting a low value
        will potentially cause more task chains to be generated. This may result in the overhead of spawning tasks can become a limiting performance factor.
        Setting a high value will potentially cause fewer islands to be generated. This may reduce thread scaling (fewer task chains spawned) and may
        detrimentally affect performance if some bodies in the scene have large solver iteration counts because all constraints in a given island are solved by the
        maximum number of solver iterations requested by any body in the island.
        
        Note that a rigid body solver task chain is spawned as soon as either a sufficient number of rigid bodies or articulations are batched together.
        
        <b>Default:</b> 16
        
        \see PxScene.setSolverArticulationBatchSize() PxScene.getSolverArticulationBatchSize()
        */
        solverArticulationBatchSize:   PxU32;

        /*
        \brief Setting to define the number of 16K blocks that will be initially reserved to store contact, friction, and contact cache data.
        This is the number of 16K memory blocks that will be automatically allocated from the user allocator when the scene is instantiated. Further 16k
        memory blocks may be allocated during the simulation up to maxNbContactDataBlocks.
        
        \note This value cannot be larger than maxNbContactDataBlocks because that defines the maximum number of 16k blocks that can be allocated by the SDK.
        
        <b>Default:</b> 0
        
        <b>Range:</b> [0, PX_MAX_U32]<br>
        
        \see PxPhysics::createScene PxScene::setNbContactDataBlocks
        */
        nbContactDataBlocks:           PxU32;

        /*
        \brief Setting to define the maximum number of 16K blocks that can be allocated to store contact, friction, and contact cache data.
        As the complexity of a scene increases, the SDK may require to allocate new 16k blocks in addition to the blocks it has already
        allocated. This variable controls the maximum number of blocks that the SDK can allocate.
        
        In the case that the scene is sufficiently complex that all the permitted 16K blocks are used, contacts will be dropped and
        a warning passed to the error stream.
        
        If a warning is reported to the error stream to indicate the number of 16K blocks is insufficient for the scene complexity
        then the choices are either (i) re-tune the number of 16K data blocks until a number is found that is sufficient for the scene complexity,
        (ii) to simplify the scene or (iii) to opt to not increase the memory requirements of physx and accept some dropped contacts.
        
        <b>Default:</b> 65536
        
        <b>Range:</b> [0, PX_MAX_U32]<br>
        
        \see nbContactDataBlocks PxScene.setNbContactDataBlocks()
        */
        maxNbContactDataBlocks:        PxU32;

        /*
        \brief The maximum bias coefficient used in the constraint solver
        
        When geometric errors are found in the constraint solver, either as a result of shapes penetrating
        or joints becoming separated or violating limits, a bias is introduced in the solver position iterations
        to correct these errors. This bias is proportional to 1/dt, meaning that the bias becomes increasingly
        strong as the time-step passed to PxScene::simulate(...) becomes smaller. This coefficient allows the
        application to restrict how large the bias coefficient is, to reduce how violent error corrections are.
        This can improve simulation quality in cases where either variable time-steps or extremely small time-steps
        are used.
        
        <b>Default:</b> PX_MAX_F32
        
        <b> Range</b> [0, PX_MAX_F32] <br>
        
        \see PxScene.setMaxBiasCoefficient() PxScene.getMaxBiasCoefficient()
        */
        maxBiasCoefficient:            PxReal;

        /*
        \brief Size of the contact report stream (in bytes).
        
        The contact report stream buffer is used during the simulation to store all the contact reports.
        If the size is not sufficient, the buffer will grow by a factor of two.
        It is possible to disable the buffer growth by setting the flag PxSceneFlag::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE.
        In that case the buffer will not grow but contact reports not stored in the buffer will not get sent in the contact report callbacks.
        
        <b>Default:</b> 8192
        
        <b>Range:</b> (0, PX_MAX_U32]<br>
        
        \see PxScene.getContactReportStreamBufferSize()
        */
        contactReportStreamBufferSize: PxU32;

        /*
        \brief Maximum number of CCD passes
        
        The CCD performs multiple passes, where each pass every object advances to its time of first impact. This value defines how many passes the CCD system should perform.
        
        \note The CCD system is a multi-pass best-effort conservative advancement approach. After the defined number of passes has been completed, any remaining time is dropped.
        \note This defines the maximum number of passes the CCD can perform. It may perform fewer if additional passes are not necessary.
        
        <b>Default:</b> 1
        <b>Range:</b> [1, PX_MAX_U32]<br>
        
        \see PxScene.setCCDMaxPasses() PxScene.getCCDMaxPasses()
        */
        ccdMaxPasses:                  PxU32;

        /*
        \brief CCD threshold
        
        CCD performs sweeps against shapes if and only if the relative motion of the shapes is fast-enough that a collision would be missed
        by the discrete contact generation. However, in some circumstances, e.g. when the environment is constructed from large convex shapes, this
        approach may produce undesired simulation artefacts. This parameter defines the minimum relative motion that would be required to force CCD between shapes.
        The smaller of this value and the sum of the thresholds calculated for the shapes involved will be used.
        
        \note It is not advisable to set this to a very small value as this may lead to CCD "jamming" and detrimentally effect performance. This value should be at least larger than the translation caused by a single frame's gravitational effect
        
        <b>Default:</b> PX_MAX_F32
        <b>Range:</b> [Eps, PX_MAX_F32]<br>
        
        \see PxScene.setCCDThreshold() PxScene.getCCDThreshold()
        */
        ccdThreshold:                  PxReal;

        /*
        \brief A threshold for speculative CCD. Used to control whether bias, restitution or a combination of the two are used to resolve the contacts.
        
        \note This only has any effect on contacting pairs where one of the bodies has PxRigidBodyFlag::eENABLE_SPECULATIVE_CCD raised.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.04 * PxTolerancesScale::length
        
        \see PxScene.setCCDMaxSeparation() PxScene.getCCDMaxSeparation()
        */
        ccdMaxSeparation:              PxReal;

        /*
        \brief The wake counter reset value
        
        Calling wakeUp() on objects which support sleeping will set their wake counter value to the specified reset value.
        
        <b>Range:</b> (0, PX_MAX_F32)<br>
        <b>Default:</b> 0.4 (which corresponds to 20 frames for a time step of 0.02)
        
        \see PxRigidDynamic::wakeUp() PxArticulationReducedCoordinate::wakeUp() PxScene.getWakeCounterResetValue()
        */
        wakeCounterResetValue:         PxReal;

        /*
        \brief The bounds used to sanity check user-set positions of actors and articulation links
        
        These bounds are used to check the position values of rigid actors inserted into the scene, and positions set for rigid actors
        already within the scene.
        
        <b>Range:</b> any valid PxBounds3 <br>
        <b>Default:</b> (-PX_MAX_BOUNDS_EXTENTS, PX_MAX_BOUNDS_EXTENTS) on each axis
        */
        sanityBounds:                  PxBounds3;

        /*
        \brief The pre-allocations performed in the GPU dynamics pipeline.
        */
        gpuDynamicsConfig:             PxGpuDynamicsMemoryConfig;

        /*
        \brief Limitation for the partitions in the GPU dynamics pipeline.
        This variable must be power of 2.
        A value greater than 32 is currently not supported.
        <b>Range:</b> (1, 32)<br>
        */
        gpuMaxNumPartitions:           PxU32;

        /*
        \brief Limitation for the number of static rigid body partitions in the GPU dynamics pipeline.
        <b>Range:</b> (1, 255)<br>
        <b>Default:</b> 16
        */
        gpuMaxNumStaticPartitions:     PxU32;

        /*
        \brief Defines which compute version the GPU dynamics should target. DO NOT MODIFY
        */
        gpuComputeVersion:             PxU32;

        /*
        \brief Defines the size of a contact pool slab.
        Contact pairs and associated data are allocated using a pool allocator. Increasing the slab size can trade
        off some performance spikes when a large number of new contacts are found for an increase in overall memory
        usage.
        
        <b>Range:</b>(1, PX_MAX_U32)<br>
        <b>Default:</b> 256
        */
        contactPairSlabSize:           PxU32;

        /*
        \brief The scene query sub-system for the scene.
        
        If left to NULL, PxScene will use its usual internal sub-system. If non-NULL, all SQ-related calls
        will be re-routed to the user-provided implementation. An external SQ implementation is available
        in the Extensions library (see PxCreateExternalSceneQuerySystem). This can also be fully re-implemented by users if needed.
        
        \see PxSceneQuerySystem
        */
        sceneQuerySystem:              *PxSceneQuerySystem;

        /*
        \cond
        */
        // For internal use only
        tolerancesScale:               PxTolerancesScale;

        /*
        \brief constructor sets to default.
        
        \param[in] scale scale values for the tolerances in the scene, these must be the same values passed into
        PxCreatePhysics(). The affected tolerances are bounceThresholdVelocity and frictionOffsetThreshold.
        
        \see PxCreatePhysics() PxTolerancesScale bounceThresholdVelocity frictionOffsetThreshold
        */
        Constructor :: (this: *PxSceneDesc, scale: *PxTolerancesScale) -> void #cpp_method #foreign physx_static "??0PxSceneDesc@physx@@QEAA@AEBVPxTolerancesScale@1@@Z";
        Constructor :: (this: *PxSceneDesc, scale: PxTolerancesScale) #no_context {
            Constructor(this, *scale);
        }

        /*
        \brief (re)sets the structure to the default.
        
        \param[in] scale scale values for the tolerances in the scene, these must be the same values passed into
        PxCreatePhysics(). The affected tolerances are bounceThresholdVelocity and frictionOffsetThreshold.
        
        \see PxCreatePhysics() PxTolerancesScale bounceThresholdVelocity frictionOffsetThreshold
        */
        setToDefault :: (this: *PxSceneDesc, scale: *PxTolerancesScale) -> void #cpp_method #foreign physx_static "?setToDefault@PxSceneDesc@physx@@QEAAXAEBVPxTolerancesScale@2@@Z";
        setToDefault :: (this: *PxSceneDesc, scale: PxTolerancesScale) #no_context {
            setToDefault(this, *scale);
        }

        /*
        \cond
        */
        // For internal use only
        getTolerancesScale :: (this: *PxSceneDesc) -> *PxTolerancesScale #cpp_method #foreign physx_static "?getTolerancesScale@PxSceneDesc@physx@@QEBAAEBVPxTolerancesScale@2@XZ";
    }

    /*
    \brief Debug visualization parameters.
    
    #PxVisualizationParameter::eSCALE is the master switch for enabling visualization, please read the corresponding documentation
    for further details.
    
    \see PxScene.setVisualizationParameter() PxScene.getVisualizationParameter() PxScene.getRenderBuffer()
    */
    PxVisualizationParameter :: struct {
        Enum :: enum s32 {
            SCALE               :: 0;

            WORLD_AXES          :: 1;

            BODY_AXES           :: 2;

            BODY_MASS_AXES      :: 3;

            BODY_LIN_VELOCITY   :: 4;

            BODY_ANG_VELOCITY   :: 5;

            CONTACT_POINT       :: 6;

            CONTACT_NORMAL      :: 7;

            CONTACT_ERROR       :: 8;

            CONTACT_FORCE       :: 9;

            ACTOR_AXES          :: 10;

            COLLISION_AABBS     :: 11;

            COLLISION_SHAPES    :: 12;

            COLLISION_AXES      :: 13;

            COLLISION_COMPOUNDS :: 14;

            COLLISION_FNORMALS  :: 15;

            COLLISION_EDGES     :: 16;

            COLLISION_STATIC    :: 17;

            COLLISION_DYNAMIC   :: 18;

            JOINT_LOCAL_FRAMES  :: 19;

            JOINT_LIMITS        :: 20;

            CULL_BOX            :: 21;

            MBP_REGIONS         :: 22;

            SIMULATION_MESH     :: 23;

            SDF                 :: 24;

            NUM_VALUES          :: 25;

            FORCE_DWORD         :: 2147483647;

            eSCALE               :: SCALE;

            eWORLD_AXES          :: WORLD_AXES;

            eBODY_AXES           :: BODY_AXES;

            eBODY_MASS_AXES      :: BODY_MASS_AXES;

            eBODY_LIN_VELOCITY   :: BODY_LIN_VELOCITY;

            eBODY_ANG_VELOCITY   :: BODY_ANG_VELOCITY;

            eCONTACT_POINT       :: CONTACT_POINT;

            eCONTACT_NORMAL      :: CONTACT_NORMAL;

            eCONTACT_ERROR       :: CONTACT_ERROR;

            eCONTACT_FORCE       :: CONTACT_FORCE;

            eACTOR_AXES          :: ACTOR_AXES;

            eCOLLISION_AABBS     :: COLLISION_AABBS;

            eCOLLISION_SHAPES    :: COLLISION_SHAPES;

            eCOLLISION_AXES      :: COLLISION_AXES;

            eCOLLISION_COMPOUNDS :: COLLISION_COMPOUNDS;

            eCOLLISION_FNORMALS  :: COLLISION_FNORMALS;

            eCOLLISION_EDGES     :: COLLISION_EDGES;

            eCOLLISION_STATIC    :: COLLISION_STATIC;

            eCOLLISION_DYNAMIC   :: COLLISION_DYNAMIC;

            eJOINT_LOCAL_FRAMES  :: JOINT_LOCAL_FRAMES;

            eJOINT_LIMITS        :: JOINT_LIMITS;

            eCULL_BOX            :: CULL_BOX;

            eMBP_REGIONS         :: MBP_REGIONS;

            eSIMULATION_MESH     :: SIMULATION_MESH;

            eSDF                 :: SDF;

            eNUM_VALUES          :: NUM_VALUES;

            eFORCE_DWORD         :: FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Structure used to retrieve actual sizes/counts for the configuration parameters provided in PxGpuDynamicsMemoryConfig.
    
    \note All the values in this structure are reported as the maximum over the lifetime of a PxScene.
    
    \see PxScene::getSimulationStatistics(), PxSimulationStatistics, PxSceneDesc::PxGpuDynamicsMemoryConfig
    */
    PxGpuDynamicsMemoryConfigStatistics :: struct {
        tempBufferCapacity:      PxU64; //!< actual size needed (bytes) for PxGpuDynamicsMemoryConfig::tempBufferCapacity.
        rigidContactCount:       PxU32; //!< actual number of rigid contacts needed - see PxGpuDynamicsMemoryConfig::maxRigidContactCount.
        rigidPatchCount:         PxU32; //!< actual number of rigid contact patches needed - see PxGpuDynamicsMemoryConfig::maxRigidPatchCount.
        foundLostPairs:          PxU32; //!< actual number of lost/found pairs needed - see PxGpuDynamicsMemoryConfig::foundLostPairsCapacity.
        foundLostAggregatePairs: PxU32; //!< actual number of lost/found aggregate pairs needed - see PxGpuDynamicsMemoryConfig::foundLostAggregatePairsCapacity.
        totalAggregatePairs:     PxU32; //!< actual number of aggregate pairs needed - see PxGpuDynamicsMemoryConfig::totalAggregatePairsCapacity.
        softbodyContacts:        PxU32; //!< actual number of soft body contact needed - see PxGpuDynamicsMemoryConfig::maxSoftBodyContacts.
        femClothContacts:        PxU32; //!< actual number of FEM cloth contacts needed - see PxGpuDynamicsMemoryConfig::maxFemClothContacts.
        particleContacts:        PxU32; //!< actual number of particle contacts needed - see PxGpuDynamicsMemoryConfig::maxParticleContacts.
        collisionStackSize:      PxU32; //!< actual size (bytes) needed for the collision stack - see PxGpuDynamicsMemoryConfig::collisionStackSize.
        hairContacts:            PxU32; //!< actual number of hair contacts needed - NOTE not implemented right now.

        Constructor :: (this: *PxGpuDynamicsMemoryConfigStatistics) -> void #cpp_method #foreign physx_static "??0PxGpuDynamicsMemoryConfigStatistics@physx@@QEAA@XZ";
    }

    /*
    \brief Class used to retrieve statistics for a simulation step.
    
    \see PxScene::getSimulationStatistics()
    */
    PxSimulationStatistics :: struct {
        /*
        \brief Different types of rigid body collision pair statistics.
        \see getRbPairStats
        */
        RbPairStatsType :: enum s32 {
            DISCRETE_CONTACT_PAIRS :: 0;

            CCD_PAIRS              :: 1;

            MODIFIED_CONTACT_PAIRS :: 2;

            TRIGGER_PAIRS          :: 3;

            eDISCRETE_CONTACT_PAIRS :: DISCRETE_CONTACT_PAIRS;

            eCCD_PAIRS              :: CCD_PAIRS;

            eMODIFIED_CONTACT_PAIRS :: MODIFIED_CONTACT_PAIRS;

            eTRIGGER_PAIRS          :: TRIGGER_PAIRS;
        }

        //objects:
        /*
        \brief Number of active PxConstraint objects (joints etc.) for the current simulation step.
        */
        nbActiveConstraints:                 PxU32;

        /*
        \brief Number of active dynamic bodies for the current simulation step.
        
        \note Does not include active kinematic bodies
        */
        nbActiveDynamicBodies:               PxU32;

        /*
        \brief Number of active kinematic bodies for the current simulation step.
        
        \note Kinematic deactivation occurs at the end of the frame after the last call to PxRigidDynamic::setKinematicTarget() was called so kinematics that are
        deactivated in a given frame will be included by this counter.
        */
        nbActiveKinematicBodies:             PxU32;

        /*
        \brief Number of static bodies for the current simulation step.
        */
        nbStaticBodies:                      PxU32;

        /*
        \brief Number of dynamic bodies for the current simulation step.
        
        \note Includes inactive bodies and articulation links
        \note Does not include kinematic bodies
        */
        nbDynamicBodies:                     PxU32;

        /*
        \brief Number of kinematic bodies for the current simulation step.
        
        \note Includes inactive bodies
        */
        nbKinematicBodies:                   PxU32;

        /*
        \brief Number of shapes of each geometry type.
        */
        nbShapes:                            [11] PxU32;

        /*
        \brief Number of aggregates in the scene.
        */
        nbAggregates:                        PxU32;

        /*
        \brief Number of articulations in the scene.
        */
        nbArticulations:                     PxU32;

        //solver:
        /*
        \brief The number of 1D axis constraints(joints+contact) present in the current simulation step.
        */
        nbAxisSolverConstraints:             PxU32;

        /*
        \brief The size (in bytes) of the compressed contact stream in the current simulation step
        */
        compressedContactSize:               PxU32;

        /*
        \brief The total required size (in bytes) of the contact constraints in the current simulation step
        */
        requiredContactConstraintMemory:     PxU32;

        /*
        \brief The peak amount of memory (in bytes) that was allocated for constraints (this includes joints) in the current simulation step
        */
        peakConstraintMemory:                PxU32;

        /*
        \brief Total number of (non CCD) pairs reaching narrow phase
        */
        nbDiscreteContactPairsTotal:         PxU32;

        /*
        \brief Total number of (non CCD) pairs for which contacts are successfully cached (<=nbDiscreteContactPairsTotal)
        \note This includes pairs for which no contacts are generated, it still counts as a cache hit.
        */
        nbDiscreteContactPairsWithCacheHits: PxU32;

        /*
        \brief Total number of (non CCD) pairs for which at least 1 contact was generated (<=nbDiscreteContactPairsTotal)
        */
        nbDiscreteContactPairsWithContacts:  PxU32;

        /*
        \brief Number of new pairs found by BP this frame
        */
        nbNewPairs:                          PxU32;

        /*
        \brief Number of lost pairs from BP this frame
        */
        nbLostPairs:                         PxU32;

        /*
        \brief Number of new touches found by NP this frame
        */
        nbNewTouches:                        PxU32;

        /*
        \brief Number of lost touches from NP this frame
        */
        nbLostTouches:                       PxU32;

        /*
        \brief Number of partitions used by the solver this frame
        */
        nbPartitions:                        PxU32;

        /*
        \brief GPU device memory in bytes allocated for particle state accessible through API
        */
        gpuMemParticles:                     PxU64;

        /*
        \brief GPU device memory in bytes allocated for FEM-based soft body state accessible through API
        */
        gpuMemSoftBodies:                    PxU64;

        /*
        \brief GPU device memory in bytes allocated for FEM-based cloth state accessible through API
        */
        gpuMemFEMCloths:                     PxU64;

        /*
        \brief GPU device memory in bytes allocated for hairsystem state accessible through API
        */
        gpuMemHairSystems:                   PxU64;

        /*
        \brief GPU device memory in bytes allocated for internal heap allocation
        */
        gpuMemHeap:                          PxU64;

        /*
        \brief GPU device heap memory used for broad phase in bytes
        */
        gpuMemHeapBroadPhase:                PxU64;

        /*
        \brief GPU device heap memory used for narrow phase in bytes
        */
        gpuMemHeapNarrowPhase:               PxU64;

        /*
        \brief GPU device heap memory used for solver in bytes
        */
        gpuMemHeapSolver:                    PxU64;

        /*
        \brief GPU device heap memory used for articulations in bytes
        */
        gpuMemHeapArticulation:              PxU64;

        /*
        \brief GPU device heap memory used for simulation pipeline in bytes
        */
        gpuMemHeapSimulation:                PxU64;

        /*
        \brief GPU device heap memory used for articulations in the simulation pipeline in bytes
        */
        gpuMemHeapSimulationArticulation:    PxU64;

        /*
        \brief GPU device heap memory used for particles in the simulation pipeline in bytes
        */
        gpuMemHeapSimulationParticles:       PxU64;

        /*
        \brief GPU device heap memory used for soft bodies in the simulation pipeline in bytes
        */
        gpuMemHeapSimulationSoftBody:        PxU64;

        /*
        \brief GPU device heap memory used for FEM-cloth in the simulation pipeline in bytes
        */
        gpuMemHeapSimulationFEMCloth:        PxU64;

        /*
        \brief GPU device heap memory used for hairsystem in the simulation pipeline in bytes
        */
        gpuMemHeapSimulationHairSystem:      PxU64;

        /*
        \brief GPU device heap memory used for shared buffers in the particles pipeline in bytes
        */
        gpuMemHeapParticles:                 PxU64;

        /*
        \brief GPU device heap memory used for shared buffers in the FEM-based soft body pipeline in bytes
        */
        gpuMemHeapSoftBodies:                PxU64;

        /*
        \brief GPU device heap memory used for shared buffers in the FEM-based cloth pipeline in bytes
        */
        gpuMemHeapFEMCloths:                 PxU64;

        /*
        \brief GPU device heap memory used for shared buffers in the hairsystem pipeline in bytes
        */
        gpuMemHeapHairSystems:               PxU64;

        /*
        \brief GPU device heap memory not covered by other stats in bytes
        */
        gpuMemHeapOther:                     PxU64;

        /*
        \brief Structure containing statistics about actual count/sizes used for the configuration parameters in PxGpuDynamicsMemoryConfig
        */
        gpuDynamicsMemoryConfigStatistics:   PxGpuDynamicsMemoryConfigStatistics;

        Constructor :: (this: *PxSimulationStatistics) -> void #cpp_method #foreign physx_static "??0PxSimulationStatistics@physx@@QEAA@XZ";

        //
        // We advise to not access these members directly. Use the provided accessor methods instead.
        //
        //broadphase:
        nbBroadPhaseAdds:                    PxU32;
        nbBroadPhaseRemoves:                 PxU32;

        //collisions:
        nbDiscreteContactPairs:              [11] [11] PxU32;
        nbCCDPairs:                          [11] [11] PxU32;
        nbModifiedContactPairs:              [11] [11] PxU32;
        nbTriggerPairs:                      [11] [11] PxU32;
    }

    /*
    \brief Identifies the buffers of a PxSoftBody.
    
    \see PxSoftBody::markDirty()
    */
    PxSoftBodyDataFlag :: struct {
        Enum :: enum s32 {
            NONE                  :: 0;

            POSITION_INVMASS      :: 1;
            SIM_POSITION_INVMASS  :: 2;
            SIM_VELOCITY          :: 4;
            REST_POSITION_INVMASS :: 8;

            ALL                   :: 15;

            eNONE                  :: NONE;

            ePOSITION_INVMASS      :: POSITION_INVMASS;
            eSIM_POSITION_INVMASS  :: SIM_POSITION_INVMASS;
            eSIM_VELOCITY          :: SIM_VELOCITY;
            eREST_POSITION_INVMASS :: REST_POSITION_INVMASS;

            eALL                   :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxSoftBodyDataFlags :: PxFlags(PxSoftBodyDataFlag.Enum, PxU32);

    /*
    \brief These flags determine what data is read or written when using PxScene::copySoftBodyData()
    or PxScene::applySoftBodyData.
    
    \see PxScene::copySoftBodyData, PxScene::applySoftBodyData
    
    \deprecated There is no direct replacement. The data is exposed in the PxSoftBody interface, accessible directly from GPU.
    There is no replacement for eTET_REST_POSES, as the data is constant and can be derived from the input collision mesh.
    */
    PxSoftBodyGpuDataFlag :: struct {
        Enum :: enum s32 {
            TET_INDICES           :: 0;
            TET_REST_POSES        :: 1;
            TET_ROTATIONS         :: 2;
            TET_POSITION_INV_MASS :: 3;
            SIM_TET_INDICES       :: 4;
            SIM_TET_ROTATIONS     :: 5;
            SIM_VELOCITY_INV_MASS :: 6;
            SIM_POSITION_INV_MASS :: 7;

            eTET_INDICES           :: TET_INDICES;
            eTET_REST_POSES        :: TET_REST_POSES;
            eTET_ROTATIONS         :: TET_ROTATIONS;
            eTET_POSITION_INV_MASS :: TET_POSITION_INV_MASS;
            eSIM_TET_INDICES       :: SIM_TET_INDICES;
            eSIM_TET_ROTATIONS     :: SIM_TET_ROTATIONS;
            eSIM_VELOCITY_INV_MASS :: SIM_VELOCITY_INV_MASS;
            eSIM_POSITION_INV_MASS :: SIM_POSITION_INV_MASS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Identifies input and output buffers for PxHairSystem
    */
    PxHairSystemData :: struct {
        Enum :: enum s32 {
            NONE             :: 0;
            POSITION_INVMASS :: 1;
            VELOCITY         :: 2;
            ALL              :: 3;

            eNONE             :: NONE;
            ePOSITION_INVMASS :: POSITION_INVMASS;
            eVELOCITY         :: VELOCITY;
            eALL              :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxHairSystemDataFlags :: PxFlags(PxHairSystemData.Enum, PxU32);

    /*
    \brief Binary settings for hair system simulation
    */
    PxHairSystemFlag :: struct {
        Enum :: enum s32 {
            SELF_COLLISION      :: 1;
            EXTERNAL_COLLISION  :: 2;
            TWOSIDED_ATTACHMENT :: 4;

            eDISABLE_SELF_COLLISION      :: SELF_COLLISION;
            eDISABLE_EXTERNAL_COLLISION  :: EXTERNAL_COLLISION;
            eDISABLE_TWOSIDED_ATTACHMENT :: TWOSIDED_ATTACHMENT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxHairSystemFlags :: PxFlags(PxHairSystemFlag.Enum, PxU32);

    /*
    \brief Identifies each type of information for retrieving from actor.
    \see PxScene::applyActorData
    
    \deprecated Only used in the deprecated function PxScene::applyActorData(). Use PxDirectGPUAPI::setRigidDynamicData() instead.
    */
    PxActorCacheFlag :: struct {
        Enum :: enum s32 {
            ACTOR_DATA :: 1;
            FORCE      :: 4;
            TORQUE     :: 8;

            eACTOR_DATA :: ACTOR_DATA;
            eFORCE      :: FORCE;
            eTORQUE     :: TORQUE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Collection of set bits defined in PxActorCacheFlag.
    
    \see PxActorCacheFlag
    */
    PxActorCacheFlags :: PxFlags(PxActorCacheFlag.Enum, PxU16);

    /*
    \brief State of a body used when interfacing with the GPU rigid body pipeline
    \see PxScene.copyBodyData()
    
    \deprecated Only used in the deprecated function PxScene::copyBodyData().
    Use PxDirectGPUAPI::getRigidDynamicData() instead.
    */
    PxGpuBodyData :: struct {
        quat:   PxQuat; /*!< actor global pose quaternion in world frame */
        pos:    PxVec4; /*!< (x,y,z members): actor global pose position in world frame */
        linVel: PxVec4; /*!< (x,y,z members): linear velocity at center of gravity in world frame */
        angVel: PxVec4; /*!< (x,y,z members): angular velocity in world frame */
    }

    /*
    \brief Pair correspondence used for matching array indices with body node indices
    
    \deprecated Only used in the deprecated functions PxScene::copyBodyData() and PxScene::applyActorData().
    Use PxDirectGPUAPI::getRigidDynamicData() and PxDirectGPUAPI::setRigidDynamicData() instead.
    */
    PxGpuActorPair :: struct {
        srcIndex:  PxU32; //Defines which index in src array we read
        nodeIndex: PxNodeIndex; //Defines which actor this entry in src array is updating
    }

    /*
    \brief Maps numeric index to a data pointer.
    
    \see PxScene::computeDenseJacobians(), PxScene::computeGeneralizedMassMatrices(), PxScene::computeGeneralizedGravityForces(), PxScene::computeCoriolisAndCentrifugalForces()
    
    \deprecated Only used in the deprecated functions PxScene::computeDenseJacobians(), PxScene::computeGeneralizedMassMatrices(), PxScene::computeGeneralizedGravityForces(), PxScene::computeCoriolisAndCentrifugalForces().
    Use PxDirectGPUAPI::computeArticulationData() instead.
    */
    PxIndexDataPair :: struct {
        index: PxU32;
        data:  *void;
    }

    /*
    \brief PVD scene Flags. They are disabled by default, and only works if PxPvdInstrumentationFlag::eDEBUG is set.
    */
    PxPvdSceneFlag :: struct {
        Enum :: enum s32 {
            CONTACTS     :: 1;
            SCENEQUERIES :: 2;
            CONSTRAINTS  :: 4;

            eTRANSMIT_CONTACTS     :: CONTACTS;
            eTRANSMIT_SCENEQUERIES :: SCENEQUERIES;
            eTRANSMIT_CONSTRAINTS  :: CONSTRAINTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxPvdSceneFlag.
    
    \see PxPvdSceneFlag
    */
    PxPvdSceneFlags :: PxFlags(PxPvdSceneFlag.Enum, PxU8);

    /*
    \brief Special client for PxScene.
    It provides access to the PxPvdSceneFlag.
    It also provides simple user debug services that associated scene position such as immediate rendering and camera updates.
    */
    PxPvdSceneClient :: struct {
        vtable: *PxPvdSceneClient_VTable;
    }
    PxPvdSceneClient_VTable :: struct #type_info_none {
        setScenePvdFlag: (this: *PxPvdSceneClient, flag: PxPvdSceneFlag.Enum, value: bool) -> void #cpp_method;

        setScenePvdFlags: (this: *PxPvdSceneClient, flags: PxPvdSceneFlags) -> void #cpp_method;

        getScenePvdFlags: (this: *PxPvdSceneClient) -> PxPvdSceneFlags #cpp_method;

        updateCamera: (this: *PxPvdSceneClient, name: *u8, origin: *PxVec3, up: *PxVec3, target: *PxVec3) -> void #cpp_method;

        drawPoints: (this: *PxPvdSceneClient, points: *PxDebugPoint, count: PxU32) -> void #cpp_method;

        drawLines: (this: *PxPvdSceneClient, lines: *PxDebugLine, count: PxU32) -> void #cpp_method;

        drawTriangles: (this: *PxPvdSceneClient, triangles: *PxDebugTriangle, count: PxU32) -> void #cpp_method;

        drawText: (this: *PxPvdSceneClient, text: *PxDebugText) -> void #cpp_method;

        getClientInternal: (this: *PxPvdSceneClient) -> *pvdsdk.PvdClient #cpp_method;

        Destructor: (this: *PxPvdSceneClient, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxPvdSceneClient_setScenePvdFlag :: inline (this: *PxPvdSceneClient, flag: PxPvdSceneFlag.Enum, value: bool) { this.vtable.setScenePvdFlag(this, flag, value); }

    PxPvdSceneClient_setScenePvdFlags :: inline (this: *PxPvdSceneClient, flags: PxPvdSceneFlags) { this.vtable.setScenePvdFlags(this, flags); }

    PxPvdSceneClient_getScenePvdFlags :: inline (this: *PxPvdSceneClient) -> PxPvdSceneFlags { return this.vtable.getScenePvdFlags(this); }

    PxPvdSceneClient_updateCamera :: inline (this: *PxPvdSceneClient, name: *u8, origin: *PxVec3, up: *PxVec3, target: *PxVec3) { this.vtable.updateCamera(this, name, origin, up, target); }

    PxPvdSceneClient_drawPoints :: inline (this: *PxPvdSceneClient, points: *PxDebugPoint, count: PxU32) { this.vtable.drawPoints(this, points, count); }

    PxPvdSceneClient_drawLines :: inline (this: *PxPvdSceneClient, lines: *PxDebugLine, count: PxU32) { this.vtable.drawLines(this, lines, count); }

    PxPvdSceneClient_drawTriangles :: inline (this: *PxPvdSceneClient, triangles: *PxDebugTriangle, count: PxU32) { this.vtable.drawTriangles(this, triangles, count); }

    PxPvdSceneClient_drawText :: inline (this: *PxPvdSceneClient, text: *PxDebugText) { this.vtable.drawText(this, text); }

    PxPvdSceneClient_getClientInternal :: inline (this: *PxPvdSceneClient) -> *pvdsdk.PvdClient { return this.vtable.getClientInternal(this); }

    PxPvdSceneClient_Destructor :: inline (this: *PxPvdSceneClient, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxPvdSceneClient) -> *PxPvdSceneClient_VTable { return obj.vtable; }


    /*
    \brief Expresses the dominance relationship of a contact.
    For the time being only three settings are permitted:
    
    (1, 1), (0, 1), and (1, 0).
    
    \see getDominanceGroup() PxDominanceGroup PxScene::setDominanceGroupPair()
    */
    PxDominanceGroupPair :: struct {
        Constructor :: (this: *PxDominanceGroupPair, a: PxU8, b: PxU8) -> void #cpp_method #foreign physx_static "??0PxDominanceGroupPair@physx@@QEAA@EE@Z";

        dominance0: PxU8;
        dominance1: PxU8;
    }

    /*
    \brief Identifies each type of actor for retrieving actors from a scene.
    
    \note #PxArticulationLink objects are not supported. Use the #PxArticulationReducedCoordinate object to retrieve all its links.
    
    \see PxScene::getActors(), PxScene::getNbActors()
    */
    PxActorTypeFlag :: struct {
        Enum :: enum s32 {
            STATIC  :: 1;

            DYNAMIC :: 2;

            eRIGID_STATIC  :: STATIC;

            eRIGID_DYNAMIC :: DYNAMIC;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Collection of set bits defined in PxActorTypeFlag.
    
    \see PxActorTypeFlag
    */
    PxActorTypeFlags :: PxFlags(PxActorTypeFlag.Enum, PxU16);

    /*
    \brief Broad-phase callback to receive broad-phase related events.
    
    Each broadphase callback object is associated with a PxClientID. It is possible to register different
    callbacks for different clients. The callback functions are called this way:
    - for shapes/actors, the callback assigned to the actors' clients are used
    - for aggregates, the callbacks assigned to clients from aggregated actors  are used
    
    \note SDK state should not be modified from within the callbacks. In particular objects should not
    be created or destroyed. If state modification is needed then the changes should be stored to a buffer
    and performed after the simulation step.
    
    <b>Threading:</b> It is not necessary to make this class thread safe as it will only be called in the context of the
    user thread.
    
    \see PxSceneDesc PxScene.setBroadPhaseCallback() PxScene.getBroadPhaseCallback()
    */
    PxBroadPhaseCallback :: struct {
        vtable: *PxBroadPhaseCallback_VTable;
    }
    PxBroadPhaseCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxBroadPhaseCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        onObjectOutOfBounds: (this: *PxBroadPhaseCallback, aggregate: *PxAggregate) -> void #cpp_method;

        onObjectOutOfBounds_1: (this: *PxBroadPhaseCallback, shape: /*reference*/ *PxShape, actor: /*reference*/ *PxActor) -> void #cpp_method;
    }

    PxBroadPhaseCallback_Destructor :: inline (this: *PxBroadPhaseCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxBroadPhaseCallback_onObjectOutOfBounds :: inline (this: *PxBroadPhaseCallback, aggregate: /*reference*/ *PxAggregate) { this.vtable.onObjectOutOfBounds(this, aggregate); }

    PxBroadPhaseCallback_onObjectOutOfBounds_1 :: inline (this: *PxBroadPhaseCallback, shape: /*reference*/ *PxShape, actor: /*reference*/ *PxActor) { this.vtable.onObjectOutOfBounds_1(this, shape, actor); }

    vtable :: (obj: *PxBroadPhaseCallback) -> *PxBroadPhaseCallback_VTable { return obj.vtable; }


    /*
    \brief A scene is a collection of bodies and constraints which can interact.
    
    The scene simulates the behavior of these objects over time. Several scenes may exist
    at the same time, but each body or constraint is specific to a scene
    -- they may not be shared.
    
    \see PxSceneDesc PxPhysics.createScene() release()
    */
    PxScene :: struct {
        #as using pxscenesqsystem: PxSceneSQSystem;

        /* \name Basics
        */
        //\{
        Constructor :: (this: *PxScene) -> void #cpp_method #foreign physx_static "??0PxScene@physx@@IEAA@XZ";

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
        #place pxscenesqsystem; pxscene_vtable: *PxScene_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxScene, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxScene@physx@@MEAA@XZ";
    }
    PxScene_VTable :: struct #type_info_none {
        using pxscenesqsystem: PxSceneSQSystem_VTable;
        release: (this: *PxScene) -> void #cpp_method;

        setFlag: (this: *PxScene, flag: PxSceneFlag.Enum, value: bool) -> void #cpp_method;

        getFlags: (this: *PxScene) -> PxSceneFlags #cpp_method;

        setLimits: (this: *PxScene, limits: *PxSceneLimits) -> void #cpp_method;

        getLimits: (this: *PxScene) -> PxSceneLimits #cpp_method #cpp_return_type_is_non_pod;

        getPhysics: (this: *PxScene) -> *PxPhysics #cpp_method;

        getTimestamp: (this: *PxScene) -> PxU32 #cpp_method;

        setName: (this: *PxScene, name: *u8) -> void #cpp_method;

        getName: (this: *PxScene) -> *u8 #cpp_method;

        addArticulation: (this: *PxScene, articulation: *PxArticulationReducedCoordinate) -> bool #cpp_method;

        removeArticulation: (this: *PxScene, articulation: *PxArticulationReducedCoordinate, wakeOnLostTouch := true) -> void #cpp_method;

        addActor: (this: *PxScene, actor: *PxActor, bvh: *PxBVH = null) -> bool #cpp_method;

        addActors: (this: *PxScene, pruningStructure: *PxPruningStructure) -> bool #cpp_method;

        addActors_1: (this: *PxScene, actors: /*const*/ **PxActor, nbActors: PxU32) -> bool #cpp_method;

        removeActor: (this: *PxScene, actor: *PxActor, wakeOnLostTouch := true) -> void #cpp_method;

        removeActors: (this: *PxScene, actors: **PxActor, nbActors: PxU32, wakeOnLostTouch := true) -> void #cpp_method;

        addAggregate: (this: *PxScene, aggregate: *PxAggregate) -> bool #cpp_method;

        removeAggregate: (this: *PxScene, aggregate: *PxAggregate, wakeOnLostTouch := true) -> void #cpp_method;

        addCollection: (this: *PxScene, collection: *PxCollection) -> bool #cpp_method;

        getNbActors: (this: *PxScene, types: PxActorTypeFlags) -> PxU32 #cpp_method;

        getActors: (this: *PxScene, types: PxActorTypeFlags, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getActiveActors: (this: *PxScene, nbActorsOut: *PxU32) -> **PxActor #cpp_method;

        getNbSoftBodies: (this: *PxScene) -> PxU32 #cpp_method;

        getSoftBodies: (this: *PxScene, userBuffer: **PxSoftBody, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbParticleSystems: (this: *PxScene, type: PxParticleSolverType.Enum) -> PxU32 #cpp_method;

        getParticleSystems: (this: *PxScene, type: PxParticleSolverType.Enum, userBuffer: **PxPBDParticleSystem, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbPBDParticleSystems: (this: *PxScene) -> PxU32 #cpp_method;

        getPBDParticleSystems: (this: *PxScene, userBuffer: **PxPBDParticleSystem, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbFEMCloths: (this: *PxScene) -> PxU32 #cpp_method;

        getFEMCloths: (this: *PxScene, userBuffer: **PxFEMCloth, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbHairSystems: (this: *PxScene) -> PxU32 #cpp_method;

        getHairSystems: (this: *PxScene, userBuffer: **PxHairSystem, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbArticulations: (this: *PxScene) -> PxU32 #cpp_method;

        getArticulations: (this: *PxScene, userBuffer: **PxArticulationReducedCoordinate, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbConstraints: (this: *PxScene) -> PxU32 #cpp_method;

        getConstraints: (this: *PxScene, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbAggregates: (this: *PxScene) -> PxU32 #cpp_method;

        getAggregates: (this: *PxScene, userBuffer: **PxAggregate, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        setDominanceGroupPair: (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup, dominance: *PxDominanceGroupPair) -> void #cpp_method;

        getDominanceGroupPair: (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup) -> PxDominanceGroupPair #cpp_method #cpp_return_type_is_non_pod;

        getCpuDispatcher: (this: *PxScene) -> *PxCpuDispatcher #cpp_method;

        getCudaContextManager: (this: *PxScene) -> *PxCudaContextManager #cpp_method;

        createClient: (this: *PxScene) -> PxClientID #cpp_method;

        setSimulationEventCallback: (this: *PxScene, callback: *PxSimulationEventCallback) -> void #cpp_method;

        getSimulationEventCallback: (this: *PxScene) -> *PxSimulationEventCallback #cpp_method;

        setContactModifyCallback: (this: *PxScene, callback: *PxContactModifyCallback) -> void #cpp_method;

        setCCDContactModifyCallback: (this: *PxScene, callback: *PxCCDContactModifyCallback) -> void #cpp_method;

        getContactModifyCallback: (this: *PxScene) -> *PxContactModifyCallback #cpp_method;

        getCCDContactModifyCallback: (this: *PxScene) -> *PxCCDContactModifyCallback #cpp_method;

        setBroadPhaseCallback: (this: *PxScene, callback: *PxBroadPhaseCallback) -> void #cpp_method;

        getBroadPhaseCallback: (this: *PxScene) -> *PxBroadPhaseCallback #cpp_method;

        setFilterShaderData: (this: *PxScene, data: *void, dataSize: PxU32) -> void #cpp_method;

        getFilterShaderData: (this: *PxScene) -> *void #cpp_method;

        getFilterShaderDataSize: (this: *PxScene) -> PxU32 #cpp_method;

        getFilterShader: (this: *PxScene) -> PxSimulationFilterShader #cpp_method;

        getFilterCallback: (this: *PxScene) -> *PxSimulationFilterCallback #cpp_method;

        resetFiltering: (this: *PxScene, actor: *PxRigidActor, shapes: **PxShape, shapeCount: PxU32) -> bool #cpp_method;

        resetFiltering_1: (this: *PxScene, actor: /*reference*/ *PxActor) -> bool #cpp_method;

        getKinematicKinematicFilteringMode: (this: *PxScene) -> PxPairFilteringMode.Enum #cpp_method;

        getStaticKinematicFilteringMode: (this: *PxScene) -> PxPairFilteringMode.Enum #cpp_method;

        simulate: (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) -> bool #cpp_method;

        advance: (this: *PxScene, completionTask: *PxBaseTask = null) -> bool #cpp_method;

        collide: (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) -> bool #cpp_method;

        checkResults: (this: *PxScene, block := false) -> bool #cpp_method;

        fetchCollision: (this: *PxScene, block := false) -> bool #cpp_method;

        fetchResults: (this: *PxScene, block := false, errorState: *PxU32 = null) -> bool #cpp_method;

        fetchResultsStart: (this: *PxScene, contactPairs: **PxContactPairHeader, nbContactPairs: *PxU32, block := false) -> bool #cpp_method;

        processCallbacks: (this: *PxScene, continuation: *PxBaseTask) -> void #cpp_method;

        fetchResultsFinish: (this: *PxScene, errorState: *PxU32 = null) -> void #cpp_method;

        fetchResultsParticleSystem: (this: *PxScene) -> void #cpp_method;

        flushSimulation: (this: *PxScene, sendPendingReports := false) -> void #cpp_method;

        setGravity: (this: *PxScene, vec: *PxVec3) -> void #cpp_method;

        getGravity: (this: *PxScene) -> PxVec3 #cpp_method;

        setBounceThresholdVelocity: (this: *PxScene, t: PxReal) -> void #cpp_method;

        getBounceThresholdVelocity: (this: *PxScene) -> PxReal #cpp_method;

        setCCDMaxPasses: (this: *PxScene, ccdMaxPasses: PxU32) -> void #cpp_method;

        getCCDMaxPasses: (this: *PxScene) -> PxU32 #cpp_method;

        setCCDMaxSeparation: (this: *PxScene, t: PxReal) -> void #cpp_method;

        getCCDMaxSeparation: (this: *PxScene) -> PxReal #cpp_method;

        setCCDThreshold: (this: *PxScene, t: PxReal) -> void #cpp_method;

        getCCDThreshold: (this: *PxScene) -> PxReal #cpp_method;

        setMaxBiasCoefficient: (this: *PxScene, t: PxReal) -> void #cpp_method;

        getMaxBiasCoefficient: (this: *PxScene) -> PxReal #cpp_method;

        setFrictionOffsetThreshold: (this: *PxScene, t: PxReal) -> void #cpp_method;

        getFrictionOffsetThreshold: (this: *PxScene) -> PxReal #cpp_method;

        setFrictionCorrelationDistance: (this: *PxScene, t: PxReal) -> void #cpp_method;

        getFrictionCorrelationDistance: (this: *PxScene) -> PxReal #cpp_method;

        getFrictionType: (this: *PxScene) -> PxFrictionType.Enum #cpp_method;

        getSolverType: (this: *PxScene) -> PxSolverType.Enum #cpp_method;

        setVisualizationParameter: (this: *PxScene, param: PxVisualizationParameter.Enum, value: PxReal) -> bool #cpp_method;

        getVisualizationParameter: (this: *PxScene, paramEnum: PxVisualizationParameter.Enum) -> PxReal #cpp_method;

        setVisualizationCullingBox: (this: *PxScene, box: *PxBounds3) -> void #cpp_method;

        getVisualizationCullingBox: (this: *PxScene) -> PxBounds3 #cpp_method #cpp_return_type_is_non_pod;

        getRenderBuffer: (this: *PxScene) -> *PxRenderBuffer #cpp_method;

        getSimulationStatistics: (this: *PxScene, stats: *PxSimulationStatistics) -> void #cpp_method;

        getBroadPhaseType: (this: *PxScene) -> PxBroadPhaseType.Enum #cpp_method;

        getBroadPhaseCaps: (this: *PxScene, caps: *PxBroadPhaseCaps) -> bool #cpp_method;

        getNbBroadPhaseRegions: (this: *PxScene) -> PxU32 #cpp_method;

        getBroadPhaseRegions: (this: *PxScene, userBuffer: *PxBroadPhaseRegionInfo, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        addBroadPhaseRegion: (this: *PxScene, region: *PxBroadPhaseRegion, populateRegion := false) -> PxU32 #cpp_method;

        removeBroadPhaseRegion: (this: *PxScene, handle: PxU32) -> bool #cpp_method;

        getTaskManager: (this: *PxScene) -> *PxTaskManager #cpp_method;

        lockRead: (this: *PxScene, file: *u8 = null, line: PxU32 = 0) -> void #cpp_method;

        unlockRead: (this: *PxScene) -> void #cpp_method;

        lockWrite: (this: *PxScene, file: *u8 = null, line: PxU32 = 0) -> void #cpp_method;

        unlockWrite: (this: *PxScene) -> void #cpp_method;

        setNbContactDataBlocks: (this: *PxScene, numBlocks: PxU32) -> void #cpp_method;

        getNbContactDataBlocksUsed: (this: *PxScene) -> PxU32 #cpp_method;

        getMaxNbContactDataBlocksUsed: (this: *PxScene) -> PxU32 #cpp_method;

        getContactReportStreamBufferSize: (this: *PxScene) -> PxU32 #cpp_method;

        setSolverBatchSize: (this: *PxScene, solverBatchSize: PxU32) -> void #cpp_method;

        getSolverBatchSize: (this: *PxScene) -> PxU32 #cpp_method;

        setSolverArticulationBatchSize: (this: *PxScene, solverBatchSize: PxU32) -> void #cpp_method;

        getSolverArticulationBatchSize: (this: *PxScene) -> PxU32 #cpp_method;

        getWakeCounterResetValue: (this: *PxScene) -> PxReal #cpp_method;

        shiftOrigin: (this: *PxScene, shift: *PxVec3) -> void #cpp_method;

        getScenePvdClient: (this: *PxScene) -> *PxPvdSceneClient #cpp_method;

        getGpuDynamicsConfig: (this: *PxScene) -> PxGpuDynamicsMemoryConfig #cpp_method #cpp_return_type_is_non_pod;

        getDirectGPUAPI: (this: *PxScene) -> *PxDirectGPUAPI #cpp_method;

        getSolverResidual: (this: *PxScene) -> PxSceneResidual #cpp_method;

        copyArticulationData: (this: *PxScene, data: *void, index: *void, dataType: PxArticulationGpuDataType.Enum, nbCopyArticulations: PxU32, copyEvent: CUevent = null) -> void #cpp_method;

        applyArticulationData: (this: *PxScene, data: *void, index: *void, dataType: PxArticulationGpuDataType.Enum, nbUpdatedArticulations: PxU32, waitEvent: CUevent = null, signalEvent: CUevent = null) -> void #cpp_method;

        updateArticulationsKinematic: (this: *PxScene, signalEvent: CUevent = null) -> void #cpp_method;

        copySoftBodyData: (this: *PxScene, data: **void, dataSizes: *void, softBodyIndices: *void, flag: PxSoftBodyGpuDataFlag.Enum, nbCopySoftBodies: PxU32, maxSize: PxU32, copyEvent: CUevent = null) -> void #cpp_method;

        applySoftBodyData: (this: *PxScene, data: **void, dataSizes: *void, softBodyIndices: *void, flag: PxSoftBodyGpuDataFlag.Enum, nbUpdatedSoftBodies: PxU32, maxSize: PxU32, applyEvent: CUevent = null, signalEvent: CUevent = null) -> void #cpp_method;

        copyContactData: (this: *PxScene, data: *void, maxContactPairs: PxU32, numContactPairs: *void, copyEvent: CUevent = null) -> void #cpp_method;

        copyBodyData: (this: *PxScene, data: *PxGpuBodyData, index: *PxGpuActorPair, nbCopyActors: PxU32, copyEvent: CUevent = null) -> void #cpp_method;

        applyActorData: (this: *PxScene, data: *void, index: *PxGpuActorPair, flag: PxActorCacheFlag.Enum, nbUpdatedActors: PxU32, waitEvent: CUevent = null, signalEvent: CUevent = null) -> void #cpp_method;

        evaluateSDFDistances: (this: *PxScene, sdfShapeIds: *PxU32, nbShapes: PxU32, localSamplePointsConcatenated: *PxVec4, samplePointCountPerShape: *PxU32, maxPointCount: PxU32, localGradientAndSDFConcatenated: *PxVec4, event: CUevent = null) -> void #cpp_method;

        computeDenseJacobians: (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) -> void #cpp_method;

        computeGeneralizedMassMatrices: (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) -> void #cpp_method;

        computeGeneralizedGravityForces: (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) -> void #cpp_method;

        computeCoriolisAndCentrifugalForces: (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) -> void #cpp_method;

        applyParticleBufferData: (this: *PxScene, indices: *PxU32, bufferIndexPair: *PxGpuParticleBufferIndexPair, flags: *PxParticleBufferFlags, nbUpdatedBuffers: PxU32, waitEvent: CUevent = null, signalEvent: CUevent = null) -> void #cpp_method;
    }

    PxScene_release :: inline (this: *PxScene) { this.pxscene_vtable.release(this); }

    PxScene_setFlag :: inline (this: *PxScene, flag: PxSceneFlag.Enum, value: bool) { this.pxscene_vtable.setFlag(this, flag, value); }

    PxScene_getFlags :: inline (this: *PxScene) -> PxSceneFlags { return this.pxscene_vtable.getFlags(this); }

    PxScene_setLimits :: inline (this: *PxScene, limits: *PxSceneLimits) { this.pxscene_vtable.setLimits(this, limits); }

    PxScene_getLimits :: inline (this: *PxScene) -> PxSceneLimits { return this.pxscene_vtable.getLimits(this); }

    PxScene_getPhysics :: inline (this: *PxScene) -> *PxPhysics { return this.pxscene_vtable.getPhysics(this); }

    PxScene_getTimestamp :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getTimestamp(this); }

    PxScene_setName :: inline (this: *PxScene, name: *u8) { this.pxscene_vtable.setName(this, name); }

    PxScene_getName :: inline (this: *PxScene) -> *u8 { return this.pxscene_vtable.getName(this); }

    PxScene_addArticulation :: inline (this: *PxScene, articulation: *PxArticulationReducedCoordinate) -> bool { return this.pxscene_vtable.addArticulation(this, articulation); }

    PxScene_removeArticulation :: inline (this: *PxScene, articulation: *PxArticulationReducedCoordinate, wakeOnLostTouch := true) { this.pxscene_vtable.removeArticulation(this, articulation, wakeOnLostTouch); }

    PxScene_addActor :: inline (this: *PxScene, actor: *PxActor, bvh: *PxBVH = null) -> bool { return this.pxscene_vtable.addActor(this, actor, bvh); }

    PxScene_addActors :: inline (this: *PxScene, pruningStructure: /*const reference*/ *PxPruningStructure) -> bool { return this.pxscene_vtable.addActors(this, pruningStructure); }

    PxScene_addActors_1 :: inline (this: *PxScene, actors: /*const*/ **PxActor, nbActors: PxU32) -> bool { return this.pxscene_vtable.addActors_1(this, actors, nbActors); }

    PxScene_removeActor :: inline (this: *PxScene, actor: *PxActor, wakeOnLostTouch := true) { this.pxscene_vtable.removeActor(this, actor, wakeOnLostTouch); }

    PxScene_removeActors :: inline (this: *PxScene, actors: **PxActor, nbActors: PxU32, wakeOnLostTouch := true) { this.pxscene_vtable.removeActors(this, actors, nbActors, wakeOnLostTouch); }

    PxScene_addAggregate :: inline (this: *PxScene, aggregate: *PxAggregate) -> bool { return this.pxscene_vtable.addAggregate(this, aggregate); }

    PxScene_removeAggregate :: inline (this: *PxScene, aggregate: *PxAggregate, wakeOnLostTouch := true) { this.pxscene_vtable.removeAggregate(this, aggregate, wakeOnLostTouch); }

    PxScene_addCollection :: inline (this: *PxScene, collection: *PxCollection) -> bool { return this.pxscene_vtable.addCollection(this, collection); }

    PxScene_getNbActors :: inline (this: *PxScene, types: PxActorTypeFlags) -> PxU32 { return this.pxscene_vtable.getNbActors(this, types); }

    PxScene_getActors :: inline (this: *PxScene, types: PxActorTypeFlags, userBuffer: **PxActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getActors(this, types, userBuffer, bufferSize, startIndex); }

    PxScene_getActiveActors :: inline (this: *PxScene, nbActorsOut: *PxU32) -> **PxActor { return this.pxscene_vtable.getActiveActors(this, nbActorsOut); }

    PxScene_getNbSoftBodies :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbSoftBodies(this); }

    PxScene_getSoftBodies :: inline (this: *PxScene, userBuffer: **PxSoftBody, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getSoftBodies(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbParticleSystems :: inline (this: *PxScene, type: PxParticleSolverType.Enum) -> PxU32 { return this.pxscene_vtable.getNbParticleSystems(this, type); }

    PxScene_getParticleSystems :: inline (this: *PxScene, type: PxParticleSolverType.Enum, userBuffer: **PxPBDParticleSystem, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getParticleSystems(this, type, userBuffer, bufferSize, startIndex); }

    PxScene_getNbPBDParticleSystems :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbPBDParticleSystems(this); }

    PxScene_getPBDParticleSystems :: inline (this: *PxScene, userBuffer: **PxPBDParticleSystem, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getPBDParticleSystems(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbFEMCloths :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbFEMCloths(this); }

    PxScene_getFEMCloths :: inline (this: *PxScene, userBuffer: **PxFEMCloth, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getFEMCloths(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbHairSystems :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbHairSystems(this); }

    PxScene_getHairSystems :: inline (this: *PxScene, userBuffer: **PxHairSystem, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getHairSystems(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbArticulations :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbArticulations(this); }

    PxScene_getArticulations :: inline (this: *PxScene, userBuffer: **PxArticulationReducedCoordinate, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getArticulations(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbConstraints :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbConstraints(this); }

    PxScene_getConstraints :: inline (this: *PxScene, userBuffer: **PxConstraint, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getConstraints(this, userBuffer, bufferSize, startIndex); }

    PxScene_getNbAggregates :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbAggregates(this); }

    PxScene_getAggregates :: inline (this: *PxScene, userBuffer: **PxAggregate, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getAggregates(this, userBuffer, bufferSize, startIndex); }

    PxScene_setDominanceGroupPair :: inline (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup, dominance: *PxDominanceGroupPair) { this.pxscene_vtable.setDominanceGroupPair(this, group1, group2, dominance); }

    PxScene_getDominanceGroupPair :: inline (this: *PxScene, group1: PxDominanceGroup, group2: PxDominanceGroup) -> PxDominanceGroupPair { return this.pxscene_vtable.getDominanceGroupPair(this, group1, group2); }

    PxScene_getCpuDispatcher :: inline (this: *PxScene) -> *PxCpuDispatcher { return this.pxscene_vtable.getCpuDispatcher(this); }

    PxScene_getCudaContextManager :: inline (this: *PxScene) -> *PxCudaContextManager { return this.pxscene_vtable.getCudaContextManager(this); }

    PxScene_createClient :: inline (this: *PxScene) -> PxClientID { return this.pxscene_vtable.createClient(this); }

    PxScene_setSimulationEventCallback :: inline (this: *PxScene, callback: *PxSimulationEventCallback) { this.pxscene_vtable.setSimulationEventCallback(this, callback); }

    PxScene_getSimulationEventCallback :: inline (this: *PxScene) -> *PxSimulationEventCallback { return this.pxscene_vtable.getSimulationEventCallback(this); }

    PxScene_setContactModifyCallback :: inline (this: *PxScene, callback: *PxContactModifyCallback) { this.pxscene_vtable.setContactModifyCallback(this, callback); }

    PxScene_setCCDContactModifyCallback :: inline (this: *PxScene, callback: *PxCCDContactModifyCallback) { this.pxscene_vtable.setCCDContactModifyCallback(this, callback); }

    PxScene_getContactModifyCallback :: inline (this: *PxScene) -> *PxContactModifyCallback { return this.pxscene_vtable.getContactModifyCallback(this); }

    PxScene_getCCDContactModifyCallback :: inline (this: *PxScene) -> *PxCCDContactModifyCallback { return this.pxscene_vtable.getCCDContactModifyCallback(this); }

    PxScene_setBroadPhaseCallback :: inline (this: *PxScene, callback: *PxBroadPhaseCallback) { this.pxscene_vtable.setBroadPhaseCallback(this, callback); }

    PxScene_getBroadPhaseCallback :: inline (this: *PxScene) -> *PxBroadPhaseCallback { return this.pxscene_vtable.getBroadPhaseCallback(this); }

    PxScene_setFilterShaderData :: inline (this: *PxScene, data: *void, dataSize: PxU32) { this.pxscene_vtable.setFilterShaderData(this, data, dataSize); }

    PxScene_getFilterShaderData :: inline (this: *PxScene) -> *void { return this.pxscene_vtable.getFilterShaderData(this); }

    PxScene_getFilterShaderDataSize :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getFilterShaderDataSize(this); }

    PxScene_getFilterShader :: inline (this: *PxScene) -> PxSimulationFilterShader { return this.pxscene_vtable.getFilterShader(this); }

    PxScene_getFilterCallback :: inline (this: *PxScene) -> *PxSimulationFilterCallback { return this.pxscene_vtable.getFilterCallback(this); }

    PxScene_resetFiltering :: inline (this: *PxScene, actor: /*reference*/ *PxRigidActor, shapes: /*const*/ **PxShape, shapeCount: PxU32) -> bool { return this.pxscene_vtable.resetFiltering(this, actor, shapes, shapeCount); }

    PxScene_resetFiltering_1 :: inline (this: *PxScene, actor: /*reference*/ *PxActor) -> bool { return this.pxscene_vtable.resetFiltering_1(this, actor); }

    PxScene_getKinematicKinematicFilteringMode :: inline (this: *PxScene) -> PxPairFilteringMode.Enum { return this.pxscene_vtable.getKinematicKinematicFilteringMode(this); }

    PxScene_getStaticKinematicFilteringMode :: inline (this: *PxScene) -> PxPairFilteringMode.Enum { return this.pxscene_vtable.getStaticKinematicFilteringMode(this); }

    PxScene_simulate :: inline (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) -> bool { return this.pxscene_vtable.simulate(this, elapsedTime, completionTask, scratchMemBlock, scratchMemBlockSize, controlSimulation); }

    PxScene_advance :: inline (this: *PxScene, completionTask: *PxBaseTask = null) -> bool { return this.pxscene_vtable.advance(this, completionTask); }

    PxScene_collide :: inline (this: *PxScene, elapsedTime: PxReal, completionTask: *PxBaseTask = null, scratchMemBlock: *void = null, scratchMemBlockSize: PxU32 = 0, controlSimulation := true) -> bool { return this.pxscene_vtable.collide(this, elapsedTime, completionTask, scratchMemBlock, scratchMemBlockSize, controlSimulation); }

    PxScene_checkResults :: inline (this: *PxScene, block := false) -> bool { return this.pxscene_vtable.checkResults(this, block); }

    PxScene_fetchCollision :: inline (this: *PxScene, block := false) -> bool { return this.pxscene_vtable.fetchCollision(this, block); }

    PxScene_fetchResults :: inline (this: *PxScene, block := false, errorState: *PxU32 = null) -> bool { return this.pxscene_vtable.fetchResults(this, block, errorState); }

    PxScene_fetchResultsStart :: inline (this: *PxScene, contactPairs: **PxContactPairHeader, nbContactPairs: *PxU32, block := false) -> bool { return this.pxscene_vtable.fetchResultsStart(this, contactPairs, nbContactPairs, block); }

    PxScene_processCallbacks :: inline (this: *PxScene, continuation: *PxBaseTask) { this.pxscene_vtable.processCallbacks(this, continuation); }

    PxScene_fetchResultsFinish :: inline (this: *PxScene, errorState: *PxU32 = null) { this.pxscene_vtable.fetchResultsFinish(this, errorState); }

    PxScene_fetchResultsParticleSystem :: inline (this: *PxScene) { this.pxscene_vtable.fetchResultsParticleSystem(this); }

    PxScene_flushSimulation :: inline (this: *PxScene, sendPendingReports := false) { this.pxscene_vtable.flushSimulation(this, sendPendingReports); }

    PxScene_setGravity :: inline (this: *PxScene, vec: *PxVec3) { this.pxscene_vtable.setGravity(this, vec); }

    PxScene_getGravity :: inline (this: *PxScene) -> PxVec3 { return this.pxscene_vtable.getGravity(this); }

    PxScene_setBounceThresholdVelocity :: inline (this: *PxScene, t: PxReal) { this.pxscene_vtable.setBounceThresholdVelocity(this, t); }

    PxScene_getBounceThresholdVelocity :: inline (this: *PxScene) -> PxReal { return this.pxscene_vtable.getBounceThresholdVelocity(this); }

    PxScene_setCCDMaxPasses :: inline (this: *PxScene, ccdMaxPasses: PxU32) { this.pxscene_vtable.setCCDMaxPasses(this, ccdMaxPasses); }

    PxScene_getCCDMaxPasses :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getCCDMaxPasses(this); }

    PxScene_setCCDMaxSeparation :: inline (this: *PxScene, t: PxReal) { this.pxscene_vtable.setCCDMaxSeparation(this, t); }

    PxScene_getCCDMaxSeparation :: inline (this: *PxScene) -> PxReal { return this.pxscene_vtable.getCCDMaxSeparation(this); }

    PxScene_setCCDThreshold :: inline (this: *PxScene, t: PxReal) { this.pxscene_vtable.setCCDThreshold(this, t); }

    PxScene_getCCDThreshold :: inline (this: *PxScene) -> PxReal { return this.pxscene_vtable.getCCDThreshold(this); }

    PxScene_setMaxBiasCoefficient :: inline (this: *PxScene, t: PxReal) { this.pxscene_vtable.setMaxBiasCoefficient(this, t); }

    PxScene_getMaxBiasCoefficient :: inline (this: *PxScene) -> PxReal { return this.pxscene_vtable.getMaxBiasCoefficient(this); }

    PxScene_setFrictionOffsetThreshold :: inline (this: *PxScene, t: PxReal) { this.pxscene_vtable.setFrictionOffsetThreshold(this, t); }

    PxScene_getFrictionOffsetThreshold :: inline (this: *PxScene) -> PxReal { return this.pxscene_vtable.getFrictionOffsetThreshold(this); }

    PxScene_setFrictionCorrelationDistance :: inline (this: *PxScene, t: PxReal) { this.pxscene_vtable.setFrictionCorrelationDistance(this, t); }

    PxScene_getFrictionCorrelationDistance :: inline (this: *PxScene) -> PxReal { return this.pxscene_vtable.getFrictionCorrelationDistance(this); }

    PxScene_getFrictionType :: inline (this: *PxScene) -> PxFrictionType.Enum { return this.pxscene_vtable.getFrictionType(this); }

    PxScene_getSolverType :: inline (this: *PxScene) -> PxSolverType.Enum { return this.pxscene_vtable.getSolverType(this); }

    PxScene_setVisualizationParameter :: inline (this: *PxScene, param: PxVisualizationParameter.Enum, value: PxReal) -> bool { return this.pxscene_vtable.setVisualizationParameter(this, param, value); }

    PxScene_getVisualizationParameter :: inline (this: *PxScene, paramEnum: PxVisualizationParameter.Enum) -> PxReal { return this.pxscene_vtable.getVisualizationParameter(this, paramEnum); }

    PxScene_setVisualizationCullingBox :: inline (this: *PxScene, box: *PxBounds3) { this.pxscene_vtable.setVisualizationCullingBox(this, box); }

    PxScene_getVisualizationCullingBox :: inline (this: *PxScene) -> PxBounds3 { return this.pxscene_vtable.getVisualizationCullingBox(this); }

    PxScene_getRenderBuffer :: inline (this: *PxScene) -> *PxRenderBuffer { return this.pxscene_vtable.getRenderBuffer(this); }

    PxScene_getSimulationStatistics :: inline (this: *PxScene, stats: *PxSimulationStatistics) { this.pxscene_vtable.getSimulationStatistics(this, stats); }

    PxScene_getBroadPhaseType :: inline (this: *PxScene) -> PxBroadPhaseType.Enum { return this.pxscene_vtable.getBroadPhaseType(this); }

    PxScene_getBroadPhaseCaps :: inline (this: *PxScene, caps: *PxBroadPhaseCaps) -> bool { return this.pxscene_vtable.getBroadPhaseCaps(this, caps); }

    PxScene_getNbBroadPhaseRegions :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbBroadPhaseRegions(this); }

    PxScene_getBroadPhaseRegions :: inline (this: *PxScene, userBuffer: *PxBroadPhaseRegionInfo, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxscene_vtable.getBroadPhaseRegions(this, userBuffer, bufferSize, startIndex); }

    PxScene_addBroadPhaseRegion :: inline (this: *PxScene, region: *PxBroadPhaseRegion, populateRegion := false) -> PxU32 { return this.pxscene_vtable.addBroadPhaseRegion(this, region, populateRegion); }

    PxScene_removeBroadPhaseRegion :: inline (this: *PxScene, handle: PxU32) -> bool { return this.pxscene_vtable.removeBroadPhaseRegion(this, handle); }

    PxScene_getTaskManager :: inline (this: *PxScene) -> *PxTaskManager { return this.pxscene_vtable.getTaskManager(this); }

    PxScene_lockRead :: inline (this: *PxScene, file: *u8 = null, line: PxU32 = 0) { this.pxscene_vtable.lockRead(this, file, line); }

    PxScene_unlockRead :: inline (this: *PxScene) { this.pxscene_vtable.unlockRead(this); }

    PxScene_lockWrite :: inline (this: *PxScene, file: *u8 = null, line: PxU32 = 0) { this.pxscene_vtable.lockWrite(this, file, line); }

    PxScene_unlockWrite :: inline (this: *PxScene) { this.pxscene_vtable.unlockWrite(this); }

    PxScene_setNbContactDataBlocks :: inline (this: *PxScene, numBlocks: PxU32) { this.pxscene_vtable.setNbContactDataBlocks(this, numBlocks); }

    PxScene_getNbContactDataBlocksUsed :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getNbContactDataBlocksUsed(this); }

    PxScene_getMaxNbContactDataBlocksUsed :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getMaxNbContactDataBlocksUsed(this); }

    PxScene_getContactReportStreamBufferSize :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getContactReportStreamBufferSize(this); }

    PxScene_setSolverBatchSize :: inline (this: *PxScene, solverBatchSize: PxU32) { this.pxscene_vtable.setSolverBatchSize(this, solverBatchSize); }

    PxScene_getSolverBatchSize :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getSolverBatchSize(this); }

    PxScene_setSolverArticulationBatchSize :: inline (this: *PxScene, solverBatchSize: PxU32) { this.pxscene_vtable.setSolverArticulationBatchSize(this, solverBatchSize); }

    PxScene_getSolverArticulationBatchSize :: inline (this: *PxScene) -> PxU32 { return this.pxscene_vtable.getSolverArticulationBatchSize(this); }

    PxScene_getWakeCounterResetValue :: inline (this: *PxScene) -> PxReal { return this.pxscene_vtable.getWakeCounterResetValue(this); }

    PxScene_shiftOrigin :: inline (this: *PxScene, shift: *PxVec3) { this.pxscene_vtable.shiftOrigin(this, shift); }

    PxScene_getScenePvdClient :: inline (this: *PxScene) -> *PxPvdSceneClient { return this.pxscene_vtable.getScenePvdClient(this); }

    PxScene_getGpuDynamicsConfig :: inline (this: *PxScene) -> PxGpuDynamicsMemoryConfig { return this.pxscene_vtable.getGpuDynamicsConfig(this); }

    PxScene_getDirectGPUAPI :: inline (this: *PxScene) -> *PxDirectGPUAPI { return this.pxscene_vtable.getDirectGPUAPI(this); }

    PxScene_getSolverResidual :: inline (this: *PxScene) -> PxSceneResidual { return this.pxscene_vtable.getSolverResidual(this); }

    PxScene_copyArticulationData :: inline (this: *PxScene, data: *void, index: *void, dataType: PxArticulationGpuDataType.Enum, nbCopyArticulations: PxU32, copyEvent: CUevent = null) { this.pxscene_vtable.copyArticulationData(this, data, index, dataType, nbCopyArticulations, copyEvent); }

    PxScene_applyArticulationData :: inline (this: *PxScene, data: *void, index: *void, dataType: PxArticulationGpuDataType.Enum, nbUpdatedArticulations: PxU32, waitEvent: CUevent = null, signalEvent: CUevent = null) { this.pxscene_vtable.applyArticulationData(this, data, index, dataType, nbUpdatedArticulations, waitEvent, signalEvent); }

    PxScene_updateArticulationsKinematic :: inline (this: *PxScene, signalEvent: CUevent = null) { this.pxscene_vtable.updateArticulationsKinematic(this, signalEvent); }

    PxScene_copySoftBodyData :: inline (this: *PxScene, data: **void, dataSizes: *void, softBodyIndices: *void, flag: PxSoftBodyGpuDataFlag.Enum, nbCopySoftBodies: PxU32, maxSize: PxU32, copyEvent: CUevent = null) { this.pxscene_vtable.copySoftBodyData(this, data, dataSizes, softBodyIndices, flag, nbCopySoftBodies, maxSize, copyEvent); }

    PxScene_applySoftBodyData :: inline (this: *PxScene, data: **void, dataSizes: *void, softBodyIndices: *void, flag: PxSoftBodyGpuDataFlag.Enum, nbUpdatedSoftBodies: PxU32, maxSize: PxU32, applyEvent: CUevent = null, signalEvent: CUevent = null) { this.pxscene_vtable.applySoftBodyData(this, data, dataSizes, softBodyIndices, flag, nbUpdatedSoftBodies, maxSize, applyEvent, signalEvent); }

    PxScene_copyContactData :: inline (this: *PxScene, data: *void, maxContactPairs: PxU32, numContactPairs: *void, copyEvent: CUevent = null) { this.pxscene_vtable.copyContactData(this, data, maxContactPairs, numContactPairs, copyEvent); }

    PxScene_copyBodyData :: inline (this: *PxScene, data: *PxGpuBodyData, index: *PxGpuActorPair, nbCopyActors: PxU32, copyEvent: CUevent = null) { this.pxscene_vtable.copyBodyData(this, data, index, nbCopyActors, copyEvent); }

    PxScene_applyActorData :: inline (this: *PxScene, data: *void, index: *PxGpuActorPair, flag: PxActorCacheFlag.Enum, nbUpdatedActors: PxU32, waitEvent: CUevent = null, signalEvent: CUevent = null) { this.pxscene_vtable.applyActorData(this, data, index, flag, nbUpdatedActors, waitEvent, signalEvent); }

    PxScene_evaluateSDFDistances :: inline (this: *PxScene, sdfShapeIds: *PxU32, nbShapes: PxU32, localSamplePointsConcatenated: *PxVec4, samplePointCountPerShape: *PxU32, maxPointCount: PxU32, localGradientAndSDFConcatenated: *PxVec4, event: CUevent = null) { this.pxscene_vtable.evaluateSDFDistances(this, sdfShapeIds, nbShapes, localSamplePointsConcatenated, samplePointCountPerShape, maxPointCount, localGradientAndSDFConcatenated, event); }

    PxScene_computeDenseJacobians :: inline (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) { this.pxscene_vtable.computeDenseJacobians(this, indices, nbIndices, computeEvent); }

    PxScene_computeGeneralizedMassMatrices :: inline (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) { this.pxscene_vtable.computeGeneralizedMassMatrices(this, indices, nbIndices, computeEvent); }

    PxScene_computeGeneralizedGravityForces :: inline (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) { this.pxscene_vtable.computeGeneralizedGravityForces(this, indices, nbIndices, computeEvent); }

    PxScene_computeCoriolisAndCentrifugalForces :: inline (this: *PxScene, indices: *PxIndexDataPair, nbIndices: PxU32, computeEvent: CUevent = null) { this.pxscene_vtable.computeCoriolisAndCentrifugalForces(this, indices, nbIndices, computeEvent); }

    PxScene_applyParticleBufferData :: inline (this: *PxScene, indices: *PxU32, bufferIndexPair: *PxGpuParticleBufferIndexPair, flags: *PxParticleBufferFlags, nbUpdatedBuffers: PxU32, waitEvent: CUevent = null, signalEvent: CUevent = null) { this.pxscene_vtable.applyParticleBufferData(this, indices, bufferIndexPair, flags, nbUpdatedBuffers, waitEvent, signalEvent); }

    vtable :: (obj: *PxScene) -> *PxScene_VTable { return obj.pxscene_vtable; }


    /*
    \brief RAII wrapper for the PxScene read lock.
    
    Use this class as follows to lock the scene for reading by the current thread
    for the duration of the enclosing scope:
    
    PxSceneReadLock lock(sceneRef);
    
    \see PxScene::lockRead(), PxScene::unlockRead(), PxSceneFlag::eREQUIRE_RW_LOCK
    */
    PxSceneReadLock :: struct {
        mScene: *PxScene;
    }

    /*
    \brief RAII wrapper for the PxScene write lock.
    
    Use this class as follows to lock the scene for writing by the current thread
    for the duration of the enclosing scope:
    
    PxSceneWriteLock lock(sceneRef);
    
    \see PxScene::lockWrite(), PxScene::unlockWrite(), PxSceneFlag::eREQUIRE_RW_LOCK
    */
    PxSceneWriteLock :: struct {
        mScene: *PxScene;
    }

    /*
    \brief Extra data item types for contact pairs.
    
    \see PxContactPairExtraDataItem.type
    */
    PxContactPairExtraDataType :: struct {
        Enum :: enum s32 {
            PRE_SOLVER_VELOCITY  :: 0;
            POST_SOLVER_VELOCITY :: 1;
            CONTACT_EVENT_POSE   :: 2;
            CONTACT_PAIR_INDEX   :: 3;

            ePRE_SOLVER_VELOCITY  :: PRE_SOLVER_VELOCITY;
            ePOST_SOLVER_VELOCITY :: POST_SOLVER_VELOCITY;
            eCONTACT_EVENT_POSE   :: CONTACT_EVENT_POSE;
            eCONTACT_PAIR_INDEX   :: CONTACT_PAIR_INDEX;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Base class for items in the extra data stream of contact pairs
    
    \see PxContactPairHeader.extraDataStream
    */
    PxContactPairExtraDataItem :: struct {
        /*
        \brief The type of the extra data stream item
        */
        type: PxU8;
    }

    /*
    \brief Velocities of the contact pair rigid bodies
    
    This struct is shared by multiple types of extra data items. The #type field allows to distinguish between them:
    \li PxContactPairExtraDataType::ePRE_SOLVER_VELOCITY: see #PxPairFlag::ePRE_SOLVER_VELOCITY
    \li PxContactPairExtraDataType::ePOST_SOLVER_VELOCITY: see #PxPairFlag::ePOST_SOLVER_VELOCITY
    
    \note For static rigid bodies, the velocities will be set to zero.
    
    \see PxContactPairHeader.extraDataStream
    */
    PxContactPairVelocity :: struct {
        #as using pxcontactpairextradataitem: PxContactPairExtraDataItem;

        /*
        \brief The linear velocity of the rigid bodies
        */
        linearVelocity:  [2] PxVec3;

        /*
        \brief The angular velocity of the rigid bodies
        */
        angularVelocity: [2] PxVec3;
    }

    /*
    \brief World space actor poses of the contact pair rigid bodies
    
    \see PxContactPairHeader.extraDataStream PxPairFlag::eCONTACT_EVENT_POSE
    */
    PxContactPairPose :: struct {
        #as using pxcontactpairextradataitem: PxContactPairExtraDataItem;

        /*
        \brief The world space pose of the rigid bodies
        */
        globalPose: [2] PxTransform;
    }

    /*
    \brief Marker for the beginning of a new item set in the extra data stream.
    
    If CCD with multiple passes is enabled, then a fast moving object might bounce on and off the same
    object multiple times. Also, different shapes of the same actor might gain and lose contact with an other
    object over multiple passes. This marker allows to separate the extra data items for each collision case, as well as
    distinguish the shape pair reports of different CCD passes.
    
    Example:
    Let us assume that an actor a0 with shapes s0_0 and s0_1 hits another actor a1 with shape s1.
    First s0_0 will hit s1, then a0 will slightly rotate and s0_1 will hit s1 while s0_0 will lose contact with s1.
    Furthermore, let us say that contact event pose information is requested as extra data.
    The extra data stream will look like this:
    
    PxContactPairIndexA | PxContactPairPoseA | PxContactPairIndexB | PxContactPairPoseB
    
    The corresponding array of PxContactPair events (see #PxSimulationEventCallback.onContact()) will look like this:
    
    PxContactPair(touch_found: s0_0, s1) | PxContactPair(touch_lost: s0_0, s1) | PxContactPair(touch_found: s0_1, s1)
    
    The #index of PxContactPairIndexA will point to the first entry in the PxContactPair array, for PxContactPairIndexB,
    #index will point to the third entry.
    
    \see PxContactPairHeader.extraDataStream
    */
    PxContactPairIndex :: struct {
        #as using pxcontactpairextradataitem: PxContactPairExtraDataItem;

        /*
        \brief The next item set in the extra data stream refers to the contact pairs starting at #index in the reported PxContactPair array.
        */
        index: PxU16;
    }

    /*
    \brief A class to iterate over a contact pair extra data stream.
    
    \see PxContactPairHeader.extraDataStream
    */
    PxContactPairExtraDataIterator :: struct {
        /*
        \brief Current pointer in the stream.
        */
        currPtr:            *PxU8;

        /*
        \brief Pointer to the end of the stream.
        */
        endPtr:             *PxU8;

        /*
        \brief Pointer to the current pre solver velocity item in the stream. NULL if there is none.
        
        \see PxContactPairVelocity
        */
        preSolverVelocity:  *PxContactPairVelocity;

        /*
        \brief Pointer to the current post solver velocity item in the stream. NULL if there is none.
        
        \see PxContactPairVelocity
        */
        postSolverVelocity: *PxContactPairVelocity;

        /*
        \brief Pointer to the current contact event pose item in the stream. NULL if there is none.
        
        \see PxContactPairPose
        */
        eventPose:          *PxContactPairPose;

        /*
        \brief The contact pair index of the current item set in the stream.
        
        \see PxContactPairIndex
        */
        contactPairIndex:   PxU32;
    }

    /*
    \brief Collection of flags providing information on contact report pairs.
    
    \see PxContactPairHeader
    */
    PxContactPairHeaderFlag :: struct {
        Enum :: enum s32 {
            _0 :: 1;
            _1 :: 2;

            eREMOVED_ACTOR_0 :: _0;
            eREMOVED_ACTOR_1 :: _1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxContactPairHeaderFlag.
    
    \see PxContactPairHeaderFlag
    */
    PxContactPairHeaderFlags :: PxFlags(PxContactPairHeaderFlag.Enum, PxU16);

    /*
    \brief An Instance of this class is passed to PxSimulationEventCallback.onContact().
    
    \see PxSimulationEventCallback.onContact()
    */
    PxContactPairHeader :: struct {
        Constructor :: (this: *PxContactPairHeader) -> void #cpp_method #foreign physx_static "??0PxContactPairHeader@physx@@QEAA@XZ";

        /*
        \brief The two actors of the notification shape pairs.
        
        \note The actor pointers might reference deleted actors. This will be the case if PxPairFlag::eNOTIFY_TOUCH_LOST
        or PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST events were requested for the pair and one of the involved actors
        gets deleted or removed from the scene. Check the #flags member to see whether that is the case.
        Do not dereference a pointer to a deleted actor. The pointer to a deleted actor is only provided
        such that user data structures which might depend on the pointer value can be updated.
        
        \see PxActor
        */
        actors:              [2] *PxActor;

        /*
        \brief Stream containing extra data as requested in the PxPairFlag flags of the simulation filter.
        
        This pointer is only valid if any kind of extra data information has been requested for the contact report pair (see #PxPairFlag::ePOST_SOLVER_VELOCITY etc.),
        else it will be NULL.
        
        \see PxPairFlag
        */
        extraDataStream:     *PxU8;

        /*
        \brief Size of the extra data stream [bytes]
        */
        extraDataStreamSize: PxU16;

        /*
        \brief Additional information on the contact report pair.
        
        \see PxContactPairHeaderFlag
        */
        flags:               PxContactPairHeaderFlags;

        /*
        \brief pointer to the contact pairs
        */
        pairs:               *PxContactPair;

        /*
        \brief number of contact pairs
        */
        nbPairs:             PxU32;
    }

    /*
    \brief Collection of flags providing information on contact report pairs.
    
    \see PxContactPair
    */
    PxContactPairFlag :: struct {
        Enum :: enum s32 {
            REMOVED_SHAPE_0               :: 1;

            REMOVED_SHAPE_1               :: 2;

            ACTOR_PAIR_HAS_FIRST_TOUCH    :: 4;

            ACTOR_PAIR_LOST_TOUCH         :: 8;

            INTERNAL_HAS_IMPULSES         :: 16;

            INTERNAL_CONTACTS_ARE_FLIPPED :: 32;

            eREMOVED_SHAPE_0               :: REMOVED_SHAPE_0;

            eREMOVED_SHAPE_1               :: REMOVED_SHAPE_1;

            eACTOR_PAIR_HAS_FIRST_TOUCH    :: ACTOR_PAIR_HAS_FIRST_TOUCH;

            eACTOR_PAIR_LOST_TOUCH         :: ACTOR_PAIR_LOST_TOUCH;

            eINTERNAL_HAS_IMPULSES         :: INTERNAL_HAS_IMPULSES;

            eINTERNAL_CONTACTS_ARE_FLIPPED :: INTERNAL_CONTACTS_ARE_FLIPPED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxContactPairFlag.
    
    \see PxContactPairFlag
    */
    PxContactPairFlags :: PxFlags(PxContactPairFlag.Enum, PxU16);

    /*
    \brief A contact point as used by contact notification
    */
    PxContactPairPoint :: struct {
        /*
        \brief The position of the contact point between the shapes, in world space.
        */
        position:           PxVec3;

        /*
        \brief The separation of the shapes at the contact point.  A negative separation denotes a penetration.
        */
        separation:         PxReal;

        /*
        \brief The normal of the contacting surfaces at the contact point. The normal direction points from the second shape to the first shape.
        */
        normal:             PxVec3;

        /*
        \brief The surface index of shape 0 at the contact point.  This is used to identify the surface material.
        */
        internalFaceIndex0: PxU32;

        /*
        \brief The impulse applied at the contact point, in world space. Divide by the simulation time step to get a force value.
        */
        impulse:            PxVec3;

        /*
        \brief The surface index of shape 1 at the contact point.  This is used to identify the surface material.
        */
        internalFaceIndex1: PxU32;
    }

    /*
    \brief A friction anchor as used by contact notification
    */
    PxContactPairFrictionAnchor :: struct {
        /*
        \brief The position of the friction anchor in world space.
        */
        position: PxVec3;

        /*
        \brief The impulse applied at the friction anchor, in world space. Divide by the simulation time step to get a force value.
        */
        impulse:  PxVec3;
    }

    /*
    \brief Contact report pair information.
    
    Instances of this class are passed to PxSimulationEventCallback.onContact(). If contact reports have been requested for a pair of shapes (see #PxPairFlag),
    then the corresponding contact information will be provided through this structure.
    
    \see PxSimulationEventCallback.onContact()
    */
    PxContactPair :: struct {
        /*
        \brief The two shapes that make up the pair.
        
        \note The shape pointers might reference deleted shapes. This will be the case if #PxPairFlag::eNOTIFY_TOUCH_LOST
        or #PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST events were requested for the pair and one of the involved shapes
        gets deleted. Check the #flags member to see whether that is the case. Do not dereference a pointer to a
        deleted shape. The pointer to a deleted shape is only provided such that user data structures which might
        depend on the pointer value can be updated.
        
        \see PxShape
        */
        shapes:             [2] *PxShape;

        /*
        \brief Pointer to first patch header in contact stream containing contact patch data
        
        This pointer is only valid if contact point information has been requested for the contact report pair (see #PxPairFlag::eNOTIFY_CONTACT_POINTS).
        Use #extractContacts() as a reference for the data layout of the stream.
        */
        contactPatches:     *PxU8;

        /*
        \brief Pointer to first contact point in contact stream containing contact data
        
        This pointer is only valid if contact point information has been requested for the contact report pair (see #PxPairFlag::eNOTIFY_CONTACT_POINTS).
        Use #extractContacts() as a reference for the data layout of the stream.
        */
        contactPoints:      *PxU8;

        /*
        \brief Buffer containing applied impulse data.
        
        This pointer is only valid if contact point information has been requested for the contact report pair (see #PxPairFlag::eNOTIFY_CONTACT_POINTS).
        Use #extractContacts() as a reference for the data layout of the stream.
        */
        contactImpulses:    *PxReal;

        /*
        \brief Buffer containing contact patches friction information.
        */
        frictionPatches:    *PxU8;

        /*
        \brief Size of the contact stream [bytes] including force buffer
        */
        requiredBufferSize: PxU32;

        /*
        \brief Number of contact points stored in the contact stream
        */
        contactCount:       PxU8;

        /*
        \brief Number of contact patches stored in the contact stream
        */
        patchCount:         PxU8;

        /*
        \brief Size of the contact stream [bytes] not including force buffer
        */
        contactStreamSize:  PxU16;

        /*
        \brief Additional information on the contact report pair.
        
        \see PxContactPairFlag
        */
        flags:              PxContactPairFlags;

        /*
        \brief Flags raised due to the contact.
        
        The events field is a combination of:
        
        <ul>
        <li>PxPairFlag::eNOTIFY_TOUCH_FOUND,</li>
        <li>PxPairFlag::eNOTIFY_TOUCH_PERSISTS,</li>
        <li>PxPairFlag::eNOTIFY_TOUCH_LOST,</li>
        <li>PxPairFlag::eNOTIFY_TOUCH_CCD,</li>
        <li>PxPairFlag::eNOTIFY_THRESHOLD_FORCE_FOUND,</li>
        <li>PxPairFlag::eNOTIFY_THRESHOLD_FORCE_PERSISTS,</li>
        <li>PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST</li>
        </ul>
        
        See the documentation of #PxPairFlag for an explanation of each.
        
        \note eNOTIFY_TOUCH_CCD can get raised even if the pair did not request this event. However, in such a case it will only get
        raised in combination with one of the other flags to point out that the other event occured during a CCD pass.
        
        \see PxPairFlag
        */
        events:             PxPairFlags;

        internalData:       [2] PxU32; // For internal use only
    }

    /*
    \brief Collection of flags providing information on trigger report pairs.
    
    \see PxTriggerPair
    */
    PxTriggerPairFlag :: struct {
        Enum :: enum s32 {
            REMOVED_SHAPE_TRIGGER :: 1;
            REMOVED_SHAPE_OTHER   :: 2;
            NEXT_FREE             :: 4;

            eREMOVED_SHAPE_TRIGGER :: REMOVED_SHAPE_TRIGGER;
            eREMOVED_SHAPE_OTHER   :: REMOVED_SHAPE_OTHER;
            eNEXT_FREE             :: NEXT_FREE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxTriggerPairFlag.
    
    \see PxTriggerPairFlag
    */
    PxTriggerPairFlags :: PxFlags(PxTriggerPairFlag.Enum, PxU8);

    /*
    \brief Descriptor for a trigger pair.
    
    An array of these structs gets passed to the PxSimulationEventCallback::onTrigger() report.
    
    \note The shape pointers might reference deleted shapes. This will be the case if #PxPairFlag::eNOTIFY_TOUCH_LOST
    events were requested for the pair and one of the involved shapes gets deleted. Check the #flags member to see
    whether that is the case. Do not dereference a pointer to a deleted shape. The pointer to a deleted shape is
    only provided such that user data structures which might depend on the pointer value can be updated.
    
    \see PxSimulationEventCallback.onTrigger()
    */
    PxTriggerPair :: struct {
        Constructor :: (this: *PxTriggerPair) -> void #cpp_method #foreign physx_static "??0PxTriggerPair@physx@@QEAA@XZ";

        triggerShape: *PxShape; //!< The shape that has been marked as a trigger.
        triggerActor: *PxActor; //!< The actor to which triggerShape is attached
        otherShape:   *PxShape; //!< The shape causing the trigger event. \deprecated (see #PxSimulationEventCallback::onTrigger()) If collision between trigger shapes is enabled, then this member might point to a trigger shape as well.
        otherActor:   *PxActor; //!< The actor to which otherShape is attached
        status:       PxPairFlag.Enum; //!< Type of trigger event (eNOTIFY_TOUCH_FOUND or eNOTIFY_TOUCH_LOST). eNOTIFY_TOUCH_PERSISTS events are not supported.
        flags:        PxTriggerPairFlags; //!< Additional information on the pair (see #PxTriggerPairFlag)
    }

    /*
    \brief Descriptor for a broken constraint.
    
    An array of these structs gets passed to the PxSimulationEventCallback::onConstraintBreak() report.
    
    \see PxConstraint PxSimulationEventCallback.onConstraintBreak()
    */
    PxConstraintInfo :: struct {
        Constructor :: (this: *PxConstraintInfo, c: *PxConstraint, extRef: *void, t: PxU32) -> void #cpp_method #foreign physx_static "??0PxConstraintInfo@physx@@QEAA@PEAVPxConstraint@1@PEAXI@Z";

        constraint:        *PxConstraint; //!< The broken constraint.
        externalReference: *void; //!< The external object which owns the constraint (see #PxConstraintConnector::getExternalReference())
        type:              PxU32; //!< Unique type ID of the external object. Allows to cast the provided external reference to the appropriate type
    }

    /*
    \brief An interface class that the user can implement in order to receive simulation events.
    
    With the exception of onAdvance(), the events get sent during the call to either #PxScene::fetchResults() or
    #PxScene::flushSimulation() with sendPendingReports=true. onAdvance() gets called while the simulation
    is running (that is between PxScene::simulate() or PxScene::advance() and PxScene::fetchResults()).
    
    \note SDK state should not be modified from within the callbacks. In particular objects should not
    be created or destroyed. If state modification is needed then the changes should be stored to a buffer
    and performed after the simulation step.
    
    <b>Threading:</b> With the exception of onAdvance(), it is not necessary to make these callbacks thread safe as
    they will only be called in the context of the user thread.
    
    \see PxScene.setSimulationEventCallback() PxScene.getSimulationEventCallback()
    */
    PxSimulationEventCallback :: struct {
        vtable: *PxSimulationEventCallback_VTable;
    }
    PxSimulationEventCallback_VTable :: struct #type_info_none {
        onConstraintBreak: (this: *PxSimulationEventCallback, constraints: *PxConstraintInfo, count: PxU32) -> void #cpp_method;

        onWake: (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) -> void #cpp_method;

        onSleep: (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) -> void #cpp_method;

        onContact: (this: *PxSimulationEventCallback, pairHeader: *PxContactPairHeader, pairs: *PxContactPair, nbPairs: PxU32) -> void #cpp_method;

        onTrigger: (this: *PxSimulationEventCallback, pairs: *PxTriggerPair, count: PxU32) -> void #cpp_method;

        onAdvance: (this: *PxSimulationEventCallback, bodyBuffer: **PxRigidBody, poseBuffer: *PxTransform, count: PxU32) -> void #cpp_method;

        Destructor: (this: *PxSimulationEventCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxSimulationEventCallback_onConstraintBreak :: inline (this: *PxSimulationEventCallback, constraints: *PxConstraintInfo, count: PxU32) { this.vtable.onConstraintBreak(this, constraints, count); }

    PxSimulationEventCallback_onWake :: inline (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) { this.vtable.onWake(this, actors, count); }

    PxSimulationEventCallback_onSleep :: inline (this: *PxSimulationEventCallback, actors: **PxActor, count: PxU32) { this.vtable.onSleep(this, actors, count); }

    PxSimulationEventCallback_onContact :: inline (this: *PxSimulationEventCallback, pairHeader: *PxContactPairHeader, pairs: *PxContactPair, nbPairs: PxU32) { this.vtable.onContact(this, pairHeader, pairs, nbPairs); }

    PxSimulationEventCallback_onTrigger :: inline (this: *PxSimulationEventCallback, pairs: *PxTriggerPair, count: PxU32) { this.vtable.onTrigger(this, pairs, count); }

    PxSimulationEventCallback_onAdvance :: inline (this: *PxSimulationEventCallback, bodyBuffer: **PxRigidBody, poseBuffer: *PxTransform, count: PxU32) { this.vtable.onAdvance(this, bodyBuffer, poseBuffer, count); }

    PxSimulationEventCallback_Destructor :: inline (this: *PxSimulationEventCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxSimulationEventCallback) -> *PxSimulationEventCallback_VTable { return obj.vtable; }


    /*
    \brief Set of parameters to control the sleeping and collision behavior of FEM based objects
    */
    PxFEMParameters :: struct {
        /*
        \brief Velocity damping value. After every timestep the velocity is reduced while the magnitude of the reduction depends on velocityDamping
        <b>Default:</b> 0.05
        */
        velocityDamping:              PxReal;

        /*
        \brief Threshold that defines the maximal magnitude of the linear motion a fem body can move in one second before it becomes a candidate for sleeping
        <b>Default:</b> 0.1
        */
        settlingThreshold:            PxReal;

        /*
        \brief Threshold that defines the maximal magnitude of the linear motion a fem body can move in one second such that it can go to sleep in the next frame
        <b>Default:</b> 0.05
        */
        sleepThreshold:               PxReal;

        /*
        \brief Damping value that damps the motion of bodies that move slow enough to be candidates for sleeping (see settlingThreshold)
        <b>Default:</b> 10
        */
        sleepDamping:                 PxReal;

        /*
        \brief Penetration value that needs to get exceeded before contacts for self collision are generated. Will only have an effect if self collisions are enabled.
        <b>Default:</b> 0.1
        */
        selfCollisionFilterDistance:  PxReal;

        /*
        \brief Stress threshold to deactivate collision contacts in case the tetrahedron's stress magnitude exceeds the threshold
        <b>Default:</b> 0.9
        */
        selfCollisionStressTolerance: PxReal;

        Constructor :: (this: *PxFEMParameters) -> void #cpp_method #foreign physx_static "??0PxFEMParameters@physx@@QEAA@XZ";
    }

    /*
    \brief Flags to enable or disable special modes of a SoftBody
    */
    PxSoftBodyFlag :: struct {
        Enum :: enum s32 {
            DISABLE_SELF_COLLISION :: 1;
            COMPUTE_STRESS_TENSOR  :: 2;
            ENABLE_CCD             :: 4;
            DISPLAY_SIM_MESH       :: 8;
            KINEMATIC              :: 16;
            PARTIALLY_KINEMATIC    :: 32;

            eDISABLE_SELF_COLLISION :: DISABLE_SELF_COLLISION;
            eCOMPUTE_STRESS_TENSOR  :: COMPUTE_STRESS_TENSOR;
            eENABLE_CCD             :: ENABLE_CCD;
            eDISPLAY_SIM_MESH       :: DISPLAY_SIM_MESH;
            eKINEMATIC              :: KINEMATIC;
            ePARTIALLY_KINEMATIC    :: PARTIALLY_KINEMATIC;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxSoftBodyFlags :: PxFlags(PxSoftBodyFlag.Enum, PxU32);

    /*
    \brief Represents a FEM softbody including everything to calculate its definition like geometry and material properties
    */
    PxSoftBody :: struct {
        #as using pxactor: PxActor;

        Constructor :: (this: *PxSoftBody, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxSoftBody@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxSoftBody, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxSoftBody@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxactor; pxsoftbody_vtable: *PxSoftBody_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_Destructor :: (this: *PxSoftBody, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxSoftBody@physx@@UEAA@XZ";

        virtual_getConcreteTypeName :: (this: *PxSoftBody) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxSoftBody@physx@@UEBAPEBDXZ";

        virtual_isKindOf :: (this: *PxSoftBody, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxSoftBody@physx@@MEBA_NPEBD@Z";
    }
    PxSoftBody_VTable :: struct #type_info_none {
        using pxactor: PxActor_VTable;
        setSoftBodyFlag: (this: *PxSoftBody, flag: PxSoftBodyFlag.Enum, val: bool) -> void #cpp_method;

        setSoftBodyFlags: (this: *PxSoftBody, flags: PxSoftBodyFlags) -> void #cpp_method;

        getSoftBodyFlag: (this: *PxSoftBody) -> PxSoftBodyFlags #cpp_method;

        setParameter: (this: *PxSoftBody, parameters: PxFEMParameters) -> void #cpp_method;

        getParameter: (this: *PxSoftBody) -> PxFEMParameters #cpp_method #cpp_return_type_is_non_pod;

        getPositionInvMassBufferD: (this: *PxSoftBody) -> *PxVec4 #cpp_method;

        getRestPositionBufferD: (this: *PxSoftBody) -> *PxVec4 #cpp_method;

        getSimPositionInvMassBufferD: (this: *PxSoftBody) -> *PxVec4 #cpp_method;

        getSimVelocityBufferD: (this: *PxSoftBody) -> *PxVec4 #cpp_method;

        markDirty: (this: *PxSoftBody, flags: PxSoftBodyDataFlags) -> void #cpp_method;

        setKinematicTargetBufferD: (this: *PxSoftBody, positions: *PxVec4, flags: PxSoftBodyFlags) -> void #cpp_method;

        getCudaContextManager: (this: *PxSoftBody) -> *PxCudaContextManager #cpp_method;

        setWakeCounter: (this: *PxSoftBody, wakeCounterValue: PxReal) -> void #cpp_method;

        getWakeCounter: (this: *PxSoftBody) -> PxReal #cpp_method;

        isSleeping: (this: *PxSoftBody) -> bool #cpp_method;

        setSolverIterationCounts: (this: *PxSoftBody, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) -> void #cpp_method;

        getSolverIterationCounts: (this: *PxSoftBody, minPositionIters: *PxU32, minVelocityIters: *PxU32) -> void #cpp_method;

        getShape: (this: *PxSoftBody) -> *PxShape #cpp_method;

        getCollisionMesh_1: (this: /*const*/ *PxSoftBody) -> *PxTetrahedronMesh #cpp_method;

        getCollisionMesh: (this: *PxSoftBody) -> *PxTetrahedronMesh #cpp_method;

        getSimulationMesh_1: (this: /*const*/ *PxSoftBody) -> *PxTetrahedronMesh #cpp_method;

        getSimulationMesh: (this: *PxSoftBody) -> *PxTetrahedronMesh #cpp_method;

        getSoftBodyAuxData_1: (this: /*const*/ *PxSoftBody) -> *PxSoftBodyAuxData #cpp_method;

        getSoftBodyAuxData: (this: *PxSoftBody) -> *PxSoftBodyAuxData #cpp_method;

        attachShape: (this: *PxSoftBody, shape: *PxShape) -> bool #cpp_method;

        attachSimulationMesh: (this: *PxSoftBody, simulationMesh: *PxTetrahedronMesh, softBodyAuxData: *PxSoftBodyAuxData) -> bool #cpp_method;

        detachShape: (this: *PxSoftBody) -> void #cpp_method;

        detachSimulationMesh: (this: *PxSoftBody) -> void #cpp_method;

        addParticleFilter: (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, buffer: *PxParticleBuffer, particleId: PxU32, tetId: PxU32) -> void #cpp_method;

        removeParticleFilter: (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, buffer: *PxParticleBuffer, particleId: PxU32, tetId: PxU32) -> void #cpp_method;

        addParticleAttachment: (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, buffer: *PxParticleBuffer, particleId: PxU32, tetId: PxU32, barycentric: *PxVec4) -> PxU32 #cpp_method;

        removeParticleAttachment: (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, handle: PxU32) -> void #cpp_method;

        addRigidFilter: (this: *PxSoftBody, actor: *PxRigidActor, vertId: PxU32) -> void #cpp_method;

        removeRigidFilter: (this: *PxSoftBody, actor: *PxRigidActor, vertId: PxU32) -> void #cpp_method;

        addRigidAttachment: (this: *PxSoftBody, actor: *PxRigidActor, vertId: PxU32, actorSpacePose: *PxVec3, constraint: *PxConeLimitedConstraint = null) -> PxU32 #cpp_method;

        removeRigidAttachment: (this: *PxSoftBody, actor: *PxRigidActor, handle: PxU32) -> void #cpp_method;

        addTetRigidFilter: (this: *PxSoftBody, actor: *PxRigidActor, tetIdx: PxU32) -> void #cpp_method;

        removeTetRigidFilter: (this: *PxSoftBody, actor: *PxRigidActor, tetIdx: PxU32) -> void #cpp_method;

        addTetRigidAttachment: (this: *PxSoftBody, actor: *PxRigidActor, tetIdx: PxU32, barycentric: *PxVec4, actorSpacePose: *PxVec3, constraint: *PxConeLimitedConstraint = null) -> PxU32 #cpp_method;

        addSoftBodyFilter: (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIdx: PxU32, tetIdx1: PxU32) -> void #cpp_method;

        removeSoftBodyFilter: (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIdx: PxU32, tetIdx1: PxU32) -> void #cpp_method;

        addSoftBodyFilters: (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIndices: *PxU32, tetIndices: *PxU32, tetIndicesSize: PxU32) -> void #cpp_method;

        removeSoftBodyFilters: (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIndices: *PxU32, tetIndices: *PxU32, tetIndicesSize: PxU32) -> void #cpp_method;

        addSoftBodyAttachment: (this: *PxSoftBody, softbody0: *PxSoftBody, tetIdx0: PxU32, tetBarycentric0: *PxVec4, tetIdx1: PxU32, tetBarycentric1: *PxVec4, constraint: *PxConeLimitedConstraint = null, constraintOffset: PxReal = 0.0) -> PxU32 #cpp_method;

        removeSoftBodyAttachment: (this: *PxSoftBody, softbody0: *PxSoftBody, handle: PxU32) -> void #cpp_method;

        addClothFilter: (this: *PxSoftBody, cloth: *PxFEMCloth, triIdx: PxU32, tetIdx: PxU32) -> void #cpp_method;

        removeClothFilter: (this: *PxSoftBody, cloth: *PxFEMCloth, triIdx: PxU32, tetIdx: PxU32) -> void #cpp_method;

        addVertClothFilter: (this: *PxSoftBody, cloth: *PxFEMCloth, vertIdx: PxU32, tetIdx: PxU32) -> void #cpp_method;

        removeVertClothFilter: (this: *PxSoftBody, cloth: *PxFEMCloth, vertIdx: PxU32, tetIdx: PxU32) -> void #cpp_method;

        addClothAttachment: (this: *PxSoftBody, cloth: *PxFEMCloth, triIdx: PxU32, triBarycentric: *PxVec4, tetIdx: PxU32, tetBarycentric: *PxVec4, constraint: *PxConeLimitedConstraint = null, constraintOffset: PxReal = 0.0) -> PxU32 #cpp_method;

        removeClothAttachment: (this: *PxSoftBody, cloth: *PxFEMCloth, handle: PxU32) -> void #cpp_method;

        getGpuSoftBodyIndex: (this: *PxSoftBody) -> PxU32 #cpp_method;
    }

    PxSoftBody_setSoftBodyFlag :: inline (this: *PxSoftBody, flag: PxSoftBodyFlag.Enum, val: bool) { this.pxsoftbody_vtable.setSoftBodyFlag(this, flag, val); }

    PxSoftBody_setSoftBodyFlags :: inline (this: *PxSoftBody, flags: PxSoftBodyFlags) { this.pxsoftbody_vtable.setSoftBodyFlags(this, flags); }

    PxSoftBody_getSoftBodyFlag :: inline (this: *PxSoftBody) -> PxSoftBodyFlags { return this.pxsoftbody_vtable.getSoftBodyFlag(this); }

    PxSoftBody_setParameter :: inline (this: *PxSoftBody, parameters: PxFEMParameters) { this.pxsoftbody_vtable.setParameter(this, parameters); }

    PxSoftBody_getParameter :: inline (this: *PxSoftBody) -> PxFEMParameters { return this.pxsoftbody_vtable.getParameter(this); }

    PxSoftBody_getPositionInvMassBufferD :: inline (this: *PxSoftBody) -> *PxVec4 { return this.pxsoftbody_vtable.getPositionInvMassBufferD(this); }

    PxSoftBody_getRestPositionBufferD :: inline (this: *PxSoftBody) -> *PxVec4 { return this.pxsoftbody_vtable.getRestPositionBufferD(this); }

    PxSoftBody_getSimPositionInvMassBufferD :: inline (this: *PxSoftBody) -> *PxVec4 { return this.pxsoftbody_vtable.getSimPositionInvMassBufferD(this); }

    PxSoftBody_getSimVelocityBufferD :: inline (this: *PxSoftBody) -> *PxVec4 { return this.pxsoftbody_vtable.getSimVelocityBufferD(this); }

    PxSoftBody_markDirty :: inline (this: *PxSoftBody, flags: PxSoftBodyDataFlags) { this.pxsoftbody_vtable.markDirty(this, flags); }

    PxSoftBody_setKinematicTargetBufferD :: inline (this: *PxSoftBody, positions: *PxVec4, flags: PxSoftBodyFlags) { this.pxsoftbody_vtable.setKinematicTargetBufferD(this, positions, flags); }

    PxSoftBody_getCudaContextManager :: inline (this: *PxSoftBody) -> *PxCudaContextManager { return this.pxsoftbody_vtable.getCudaContextManager(this); }

    PxSoftBody_setWakeCounter :: inline (this: *PxSoftBody, wakeCounterValue: PxReal) { this.pxsoftbody_vtable.setWakeCounter(this, wakeCounterValue); }

    PxSoftBody_getWakeCounter :: inline (this: *PxSoftBody) -> PxReal { return this.pxsoftbody_vtable.getWakeCounter(this); }

    PxSoftBody_isSleeping :: inline (this: *PxSoftBody) -> bool { return this.pxsoftbody_vtable.isSleeping(this); }

    PxSoftBody_setSolverIterationCounts :: inline (this: *PxSoftBody, minPositionIters: PxU32, minVelocityIters: PxU32 = 1) { this.pxsoftbody_vtable.setSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxSoftBody_getSolverIterationCounts :: inline (this: *PxSoftBody, minPositionIters: *PxU32, minVelocityIters: *PxU32) { this.pxsoftbody_vtable.getSolverIterationCounts(this, minPositionIters, minVelocityIters); }

    PxSoftBody_getShape :: inline (this: *PxSoftBody) -> *PxShape { return this.pxsoftbody_vtable.getShape(this); }

    PxSoftBody_getCollisionMesh_1 :: inline (this: /*const*/ *PxSoftBody) -> *PxTetrahedronMesh { return this.pxsoftbody_vtable.getCollisionMesh_1(this); }

    PxSoftBody_getCollisionMesh :: inline (this: *PxSoftBody) -> *PxTetrahedronMesh { return this.pxsoftbody_vtable.getCollisionMesh(this); }

    PxSoftBody_getSimulationMesh_1 :: inline (this: /*const*/ *PxSoftBody) -> *PxTetrahedronMesh { return this.pxsoftbody_vtable.getSimulationMesh_1(this); }

    PxSoftBody_getSimulationMesh :: inline (this: *PxSoftBody) -> *PxTetrahedronMesh { return this.pxsoftbody_vtable.getSimulationMesh(this); }

    PxSoftBody_getSoftBodyAuxData_1 :: inline (this: /*const*/ *PxSoftBody) -> *PxSoftBodyAuxData { return this.pxsoftbody_vtable.getSoftBodyAuxData_1(this); }

    PxSoftBody_getSoftBodyAuxData :: inline (this: *PxSoftBody) -> *PxSoftBodyAuxData { return this.pxsoftbody_vtable.getSoftBodyAuxData(this); }

    PxSoftBody_attachShape :: inline (this: *PxSoftBody, shape: *PxShape) -> bool { return this.pxsoftbody_vtable.attachShape(this, shape); }

    PxSoftBody_attachSimulationMesh :: inline (this: *PxSoftBody, simulationMesh: *PxTetrahedronMesh, softBodyAuxData: *PxSoftBodyAuxData) -> bool { return this.pxsoftbody_vtable.attachSimulationMesh(this, simulationMesh, softBodyAuxData); }

    PxSoftBody_detachShape :: inline (this: *PxSoftBody) { this.pxsoftbody_vtable.detachShape(this); }

    PxSoftBody_detachSimulationMesh :: inline (this: *PxSoftBody) { this.pxsoftbody_vtable.detachSimulationMesh(this); }

    PxSoftBody_addParticleFilter :: inline (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, buffer: *PxParticleBuffer, particleId: PxU32, tetId: PxU32) { this.pxsoftbody_vtable.addParticleFilter(this, particlesystem, buffer, particleId, tetId); }

    PxSoftBody_removeParticleFilter :: inline (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, buffer: *PxParticleBuffer, particleId: PxU32, tetId: PxU32) { this.pxsoftbody_vtable.removeParticleFilter(this, particlesystem, buffer, particleId, tetId); }

    PxSoftBody_addParticleAttachment :: inline (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, buffer: *PxParticleBuffer, particleId: PxU32, tetId: PxU32, barycentric: *PxVec4) -> PxU32 { return this.pxsoftbody_vtable.addParticleAttachment(this, particlesystem, buffer, particleId, tetId, barycentric); }

    PxSoftBody_removeParticleAttachment :: inline (this: *PxSoftBody, particlesystem: *PxPBDParticleSystem, handle: PxU32) { this.pxsoftbody_vtable.removeParticleAttachment(this, particlesystem, handle); }

    PxSoftBody_addRigidFilter :: inline (this: *PxSoftBody, actor: *PxRigidActor, vertId: PxU32) { this.pxsoftbody_vtable.addRigidFilter(this, actor, vertId); }

    PxSoftBody_removeRigidFilter :: inline (this: *PxSoftBody, actor: *PxRigidActor, vertId: PxU32) { this.pxsoftbody_vtable.removeRigidFilter(this, actor, vertId); }

    PxSoftBody_addRigidAttachment :: inline (this: *PxSoftBody, actor: *PxRigidActor, vertId: PxU32, actorSpacePose: *PxVec3, constraint: *PxConeLimitedConstraint = null) -> PxU32 { return this.pxsoftbody_vtable.addRigidAttachment(this, actor, vertId, actorSpacePose, constraint); }

    PxSoftBody_removeRigidAttachment :: inline (this: *PxSoftBody, actor: *PxRigidActor, handle: PxU32) { this.pxsoftbody_vtable.removeRigidAttachment(this, actor, handle); }

    PxSoftBody_addTetRigidFilter :: inline (this: *PxSoftBody, actor: *PxRigidActor, tetIdx: PxU32) { this.pxsoftbody_vtable.addTetRigidFilter(this, actor, tetIdx); }

    PxSoftBody_removeTetRigidFilter :: inline (this: *PxSoftBody, actor: *PxRigidActor, tetIdx: PxU32) { this.pxsoftbody_vtable.removeTetRigidFilter(this, actor, tetIdx); }

    PxSoftBody_addTetRigidAttachment :: inline (this: *PxSoftBody, actor: *PxRigidActor, tetIdx: PxU32, barycentric: *PxVec4, actorSpacePose: *PxVec3, constraint: *PxConeLimitedConstraint = null) -> PxU32 { return this.pxsoftbody_vtable.addTetRigidAttachment(this, actor, tetIdx, barycentric, actorSpacePose, constraint); }

    PxSoftBody_addSoftBodyFilter :: inline (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIdx: PxU32, tetIdx1: PxU32) { this.pxsoftbody_vtable.addSoftBodyFilter(this, otherSoftBody, otherTetIdx, tetIdx1); }

    PxSoftBody_removeSoftBodyFilter :: inline (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIdx: PxU32, tetIdx1: PxU32) { this.pxsoftbody_vtable.removeSoftBodyFilter(this, otherSoftBody, otherTetIdx, tetIdx1); }

    PxSoftBody_addSoftBodyFilters :: inline (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIndices: *PxU32, tetIndices: *PxU32, tetIndicesSize: PxU32) { this.pxsoftbody_vtable.addSoftBodyFilters(this, otherSoftBody, otherTetIndices, tetIndices, tetIndicesSize); }

    PxSoftBody_removeSoftBodyFilters :: inline (this: *PxSoftBody, otherSoftBody: *PxSoftBody, otherTetIndices: *PxU32, tetIndices: *PxU32, tetIndicesSize: PxU32) { this.pxsoftbody_vtable.removeSoftBodyFilters(this, otherSoftBody, otherTetIndices, tetIndices, tetIndicesSize); }

    PxSoftBody_addSoftBodyAttachment :: inline (this: *PxSoftBody, softbody0: *PxSoftBody, tetIdx0: PxU32, tetBarycentric0: *PxVec4, tetIdx1: PxU32, tetBarycentric1: *PxVec4, constraint: *PxConeLimitedConstraint = null, constraintOffset: PxReal = 0.0) -> PxU32 { return this.pxsoftbody_vtable.addSoftBodyAttachment(this, softbody0, tetIdx0, tetBarycentric0, tetIdx1, tetBarycentric1, constraint, constraintOffset); }

    PxSoftBody_removeSoftBodyAttachment :: inline (this: *PxSoftBody, softbody0: *PxSoftBody, handle: PxU32) { this.pxsoftbody_vtable.removeSoftBodyAttachment(this, softbody0, handle); }

    PxSoftBody_addClothFilter :: inline (this: *PxSoftBody, cloth: *PxFEMCloth, triIdx: PxU32, tetIdx: PxU32) { this.pxsoftbody_vtable.addClothFilter(this, cloth, triIdx, tetIdx); }

    PxSoftBody_removeClothFilter :: inline (this: *PxSoftBody, cloth: *PxFEMCloth, triIdx: PxU32, tetIdx: PxU32) { this.pxsoftbody_vtable.removeClothFilter(this, cloth, triIdx, tetIdx); }

    PxSoftBody_addVertClothFilter :: inline (this: *PxSoftBody, cloth: *PxFEMCloth, vertIdx: PxU32, tetIdx: PxU32) { this.pxsoftbody_vtable.addVertClothFilter(this, cloth, vertIdx, tetIdx); }

    PxSoftBody_removeVertClothFilter :: inline (this: *PxSoftBody, cloth: *PxFEMCloth, vertIdx: PxU32, tetIdx: PxU32) { this.pxsoftbody_vtable.removeVertClothFilter(this, cloth, vertIdx, tetIdx); }

    PxSoftBody_addClothAttachment :: inline (this: *PxSoftBody, cloth: *PxFEMCloth, triIdx: PxU32, triBarycentric: *PxVec4, tetIdx: PxU32, tetBarycentric: *PxVec4, constraint: *PxConeLimitedConstraint = null, constraintOffset: PxReal = 0.0) -> PxU32 { return this.pxsoftbody_vtable.addClothAttachment(this, cloth, triIdx, triBarycentric, tetIdx, tetBarycentric, constraint, constraintOffset); }

    PxSoftBody_removeClothAttachment :: inline (this: *PxSoftBody, cloth: *PxFEMCloth, handle: PxU32) { this.pxsoftbody_vtable.removeClothAttachment(this, cloth, handle); }

    PxSoftBody_getGpuSoftBodyIndex :: inline (this: *PxSoftBody) -> PxU32 { return this.pxsoftbody_vtable.getGpuSoftBodyIndex(this); }

    vtable :: (obj: *PxSoftBody) -> *PxSoftBody_VTable { return obj.pxsoftbody_vtable; }


    /*
    \brief A precomputed pruning structure to accelerate scene queries against newly added actors.
    
    The pruning structure can be provided to #PxScene:: addActors() in which case it will get merged
    directly into the scene query optimization AABB tree, thus leading to improved performance when
    doing queries against the newly added actors. This applies to both static and dynamic actors.
    
    \note PxPruningStructure objects can be added to a collection and get serialized.
    \note Adding a PxPruningStructure object to a collection will also add the actors that were used to build the pruning structure.
    
    \note PxPruningStructure must be released before its rigid actors.
    \note PxRigidBody objects can be in one PxPruningStructure only.
    \note Changing the bounds of PxRigidBody objects assigned to a pruning structure that has not been added to a scene yet will
    invalidate the pruning structure. Same happens if shape scene query flags change or shape gets removed from an actor.
    
    \see PxScene::addActors PxCollection
    */
    PxPruningStructure :: struct {
        #as using pxbase: PxBase;

        Constructor :: (this: *PxPruningStructure, concreteType: PxType, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxPruningStructure@physx@@IEAA@GV?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        Constructor :: (this: *PxPruningStructure, baseFlags: PxBaseFlags) -> void #cpp_method #foreign physx_static "??0PxPruningStructure@physx@@IEAA@V?$PxFlags@W4Enum@PxBaseFlag@physx@@G@1@@Z";
        #place pxbase; pxpruningstructure_vtable: *PxPruningStructure_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.

        virtual_getConcreteTypeName :: (this: *PxPruningStructure) -> *u8 #cpp_method #foreign physx_static "?getConcreteTypeName@PxPruningStructure@physx@@UEBAPEBDXZ";

        virtual_Destructor :: (this: *PxPruningStructure, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physx_static "??1PxPruningStructure@physx@@MEAA@XZ";
        virtual_isKindOf :: (this: *PxPruningStructure, name: *u8) -> bool #cpp_method #foreign physx_static "?isKindOf@PxPruningStructure@physx@@MEBA_NPEBD@Z";
    }
    PxPruningStructure_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        getRigidActors: (this: *PxPruningStructure, userBuffer: **PxRigidActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 #cpp_method;

        getNbRigidActors: (this: *PxPruningStructure) -> PxU32 #cpp_method;

        getStaticMergeData: (this: *PxPruningStructure) -> *void #cpp_method;

        getDynamicMergeData: (this: *PxPruningStructure) -> *void #cpp_method;
    }

    PxPruningStructure_getRigidActors :: inline (this: *PxPruningStructure, userBuffer: **PxRigidActor, bufferSize: PxU32, startIndex: PxU32 = 0) -> PxU32 { return this.pxpruningstructure_vtable.getRigidActors(this, userBuffer, bufferSize, startIndex); }

    PxPruningStructure_getNbRigidActors :: inline (this: *PxPruningStructure) -> PxU32 { return this.pxpruningstructure_vtable.getNbRigidActors(this); }

    PxPruningStructure_getStaticMergeData :: inline (this: *PxPruningStructure) -> *void { return this.pxpruningstructure_vtable.getStaticMergeData(this); }

    PxPruningStructure_getDynamicMergeData :: inline (this: *PxPruningStructure) -> *void { return this.pxpruningstructure_vtable.getDynamicMergeData(this); }

    vtable :: (obj: *PxPruningStructure) -> *PxPruningStructure_VTable { return obj.pxpruningstructure_vtable; }


    PxExtendedVec3 :: PxVec3d;
    PxExtended :: float64;

    toVec3 :: (v: *PxExtendedVec3) -> PxVec3 #foreign physxcharacterkinematic_static "?toVec3@physx@@YA?AV?$PxVec3T@M@1@AEBV?$PxVec3T@N@1@@Z";
    toVec3 :: (v: PxExtendedVec3) -> PxVec3 #no_context {
        return toVec3(*v);
    }

    // Computes the single-precision difference between two extended-precision points
    diff :: (p1: *PxExtendedVec3, p0: *PxExtendedVec3) -> PxVec3 #foreign physxcharacterkinematic_static "?diff@physx@@YA?AV?$PxVec3T@M@1@AEBV?$PxVec3T@N@1@0@Z";
    diff :: (p1: PxExtendedVec3, p0: PxExtendedVec3) -> PxVec3 #no_context {
        return diff(*p1, *p0);
    }

    /*
    \brief Base class for obstacles.
    
    \see PxBoxObstacle PxCapsuleObstacle PxObstacleContext
    */
    PxObstacle :: struct {
        mType:     PxGeometryType.Enum;

        getType :: (this: *PxObstacle) -> PxGeometryType.Enum #cpp_method #foreign physxcharacterkinematic_static "?getType@PxObstacle@physx@@QEBA?AW4Enum@PxGeometryType@2@XZ";

        mUserData: *void;
        mPos:      PxExtendedVec3;
        mRot:      PxQuat;
    }

    /*
    \brief A box obstacle.
    
    \see PxObstacle PxCapsuleObstacle PxObstacleContext
    */
    PxBoxObstacle :: struct {
        #as using pxobstacle: PxObstacle;

        mHalfExtents: PxVec3;
    }

    /*
    \brief A capsule obstacle.
    
    \see PxBoxObstacle PxObstacle PxObstacleContext
    */
    PxCapsuleObstacle :: struct {
        #as using pxobstacle: PxObstacle;

        mHalfHeight: PxReal;
        mRadius:     PxReal;
    }

    PxObstacleHandle :: PxU32;

    /*
    \brief Context class for obstacles.
    
    An obstacle context class contains and manages a set of user-defined obstacles.
    
    \see PxBoxObstacle PxCapsuleObstacle PxObstacle
    */
    PxObstacleContext :: struct {
        vtable: *PxObstacleContext_VTable;
        Constructor :: (this: *PxObstacleContext) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxObstacleContext@physx@@QEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxObstacleContext, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxObstacleContext@physx@@UEAA@XZ";
    }
    PxObstacleContext_VTable :: struct #type_info_none {
        Destructor: (this: *PxObstacleContext, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        release: (this: *PxObstacleContext) -> void #cpp_method;

        getControllerManager: (this: *PxObstacleContext) -> *PxControllerManager #cpp_method;

        addObstacle: (this: *PxObstacleContext, obstacle: *PxObstacle) -> PxObstacleHandle #cpp_method;

        removeObstacle: (this: *PxObstacleContext, handle: PxObstacleHandle) -> bool #cpp_method;

        updateObstacle: (this: *PxObstacleContext, handle: PxObstacleHandle, obstacle: *PxObstacle) -> bool #cpp_method;

        getNbObstacles: (this: *PxObstacleContext) -> PxU32 #cpp_method;

        getObstacle: (this: *PxObstacleContext, i: PxU32) -> *PxObstacle #cpp_method;

        getObstacleByHandle: (this: *PxObstacleContext, handle: PxObstacleHandle) -> *PxObstacle #cpp_method;
    }

    PxObstacleContext_Destructor :: inline (this: *PxObstacleContext, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxObstacleContext_release :: inline (this: *PxObstacleContext) { this.vtable.release(this); }

    PxObstacleContext_getControllerManager :: inline (this: *PxObstacleContext) -> *PxControllerManager { return this.vtable.getControllerManager(this); }

    PxObstacleContext_addObstacle :: inline (this: *PxObstacleContext, obstacle: *PxObstacle) -> PxObstacleHandle { return this.vtable.addObstacle(this, obstacle); }

    PxObstacleContext_removeObstacle :: inline (this: *PxObstacleContext, handle: PxObstacleHandle) -> bool { return this.vtable.removeObstacle(this, handle); }

    PxObstacleContext_updateObstacle :: inline (this: *PxObstacleContext, handle: PxObstacleHandle, obstacle: *PxObstacle) -> bool { return this.vtable.updateObstacle(this, handle, obstacle); }

    PxObstacleContext_getNbObstacles :: inline (this: *PxObstacleContext) -> PxU32 { return this.vtable.getNbObstacles(this); }

    PxObstacleContext_getObstacle :: inline (this: *PxObstacleContext, i: PxU32) -> *PxObstacle { return this.vtable.getObstacle(this, i); }

    PxObstacleContext_getObstacleByHandle :: inline (this: *PxObstacleContext, handle: PxObstacleHandle) -> *PxObstacle { return this.vtable.getObstacleByHandle(this, handle); }

    vtable :: (obj: *PxObstacleContext) -> *PxObstacleContext_VTable { return obj.vtable; }


    /*
    \brief The type of controller, eg box, sphere or capsule.
    */
    PxControllerShapeType :: struct {
        Enum :: enum s32 {
            BOX         :: 0;

            CAPSULE     :: 1;

            FORCE_DWORD :: 2147483647;

            eBOX         :: BOX;

            eCAPSULE     :: CAPSULE;

            eFORCE_DWORD :: FORCE_DWORD;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief specifies how a CCT interacts with non-walkable parts.
    
    This is only used when slopeLimit is non zero. It is currently enabled for static actors only, and not supported for spheres or capsules.
    */
    PxControllerNonWalkableMode :: struct {
        Enum :: enum s32 {
            CLIMBING                   :: 0;
            CLIMBING_AND_FORCE_SLIDING :: 1;

            ePREVENT_CLIMBING                   :: CLIMBING;
            ePREVENT_CLIMBING_AND_FORCE_SLIDING :: CLIMBING_AND_FORCE_SLIDING;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief specifies which sides a character is colliding with.
    */
    PxControllerCollisionFlag :: struct {
        Enum :: enum s32 {
            SIDES :: 1;
            UP    :: 2;
            DOWN  :: 4;

            eCOLLISION_SIDES :: SIDES;
            eCOLLISION_UP    :: UP;
            eCOLLISION_DOWN  :: DOWN;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxControllerCollisionFlag.
    
    \see PxControllerCollisionFlag
    */
    PxControllerCollisionFlags :: PxFlags(PxControllerCollisionFlag.Enum, PxU8);

    /*
    \brief Describes a controller's internal state.
    */
    PxControllerState :: struct {
        deltaXP:               PxVec3; //!< delta position vector for the object the CCT is standing/riding on. Not always match the CCT delta when variable timesteps are used.
        touchedShape:          *PxShape; //!< Shape on which the CCT is standing
        touchedActor:          *PxRigidActor; //!< Actor owning 'touchedShape'
        touchedObstacleHandle: PxObstacleHandle; // Obstacle on which the CCT is standing
        collisionFlags:        PxU32; //!< Last known collision flags (PxControllerCollisionFlag)
        standOnAnotherCCT:     bool; //!< Are we standing on another CCT?
        standOnObstacle:       bool; //!< Are we standing on a user-defined obstacle?
        isMovingUp:            bool; //!< is CCT moving up or not? (i.e. explicit jumping)
    }

    /*
    \brief Describes a controller's internal statistics.
    */
    PxControllerStats :: struct {
        nbIterations:     PxU16;
        nbFullUpdates:    PxU16;
        nbPartialUpdates: PxU16;
        nbTessellation:   PxU16;
    }

    /*
    \brief Describes a generic CCT hit.
    */
    PxControllerHit :: struct {
        controller:  *PxController; //!< Current controller
        worldPos:    PxExtendedVec3; //!< Contact position in world space
        worldNormal: PxVec3; //!< Contact normal in world space
        dir:         PxVec3; //!< Motion direction
        length:      PxF32; //!< Motion length
    }

    /*
    \brief Describes a hit between a CCT and a shape. Passed to onShapeHit()
    
    \see PxUserControllerHitReport.onShapeHit()
    */
    PxControllerShapeHit :: struct {
        #as using pxcontrollerhit: PxControllerHit;

        shape:         *PxShape; //!< Touched shape
        actor:         *PxRigidActor; //!< Touched actor
        triangleIndex: PxU32; //!< touched triangle index (only for meshes/heightfields)
    }

    /*
    \brief Describes a hit between a CCT and another CCT. Passed to onControllerHit().
    
    \see PxUserControllerHitReport.onControllerHit()
    */
    PxControllersHit :: struct {
        #as using pxcontrollerhit: PxControllerHit;

        other: *PxController; //!< Touched controller
    }

    /*
    \brief Describes a hit between a CCT and a user-defined obstacle. Passed to onObstacleHit().
    
    \see PxUserControllerHitReport.onObstacleHit() PxObstacleContext
    */
    PxControllerObstacleHit :: struct {
        #as using pxcontrollerhit: PxControllerHit;

        userData: *void;
    }

    /*
    \brief User callback class for character controller events.
    
    \note Character controller hit reports are only generated when move is called.
    
    \see PxControllerDesc.callback
    */
    PxUserControllerHitReport :: struct {
        vtable: *PxUserControllerHitReport_VTable;
    }
    PxUserControllerHitReport_VTable :: struct #type_info_none {
        onShapeHit: (this: *PxUserControllerHitReport, hit: *PxControllerShapeHit) -> void #cpp_method;

        onControllerHit: (this: *PxUserControllerHitReport, hit: *PxControllersHit) -> void #cpp_method;

        onObstacleHit: (this: *PxUserControllerHitReport, hit: *PxControllerObstacleHit) -> void #cpp_method;

        Destructor: (this: *PxUserControllerHitReport, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxUserControllerHitReport_onShapeHit :: inline (this: *PxUserControllerHitReport, hit: *PxControllerShapeHit) { this.vtable.onShapeHit(this, hit); }

    PxUserControllerHitReport_onControllerHit :: inline (this: *PxUserControllerHitReport, hit: *PxControllersHit) { this.vtable.onControllerHit(this, hit); }

    PxUserControllerHitReport_onObstacleHit :: inline (this: *PxUserControllerHitReport, hit: *PxControllerObstacleHit) { this.vtable.onObstacleHit(this, hit); }

    PxUserControllerHitReport_Destructor :: inline (this: *PxUserControllerHitReport, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxUserControllerHitReport) -> *PxUserControllerHitReport_VTable { return obj.vtable; }


    /*
    \brief Dedicated filtering callback for CCT vs CCT.
    
    This controls collisions between CCTs (one CCT vs anoter CCT).
    
    To make each CCT collide against all other CCTs, just return true - or simply avoid defining a callback.
    To make each CCT freely go through all other CCTs, just return false.
    Otherwise create a custom filtering logic in this callback.
    
    \see PxControllerFilters
    */
    PxControllerFilterCallback :: struct {
        vtable: *PxControllerFilterCallback_VTable;
    }
    PxControllerFilterCallback_VTable :: struct #type_info_none {
        Destructor: (this: *PxControllerFilterCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        filter: (this: *PxControllerFilterCallback, a: *PxController, b: *PxController) -> bool #cpp_method;
    }

    PxControllerFilterCallback_Destructor :: inline (this: *PxControllerFilterCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxControllerFilterCallback_filter :: inline (this: *PxControllerFilterCallback, a: *PxController, b: *PxController) -> bool { return this.vtable.filter(this, a, b); }

    vtable :: (obj: *PxControllerFilterCallback) -> *PxControllerFilterCallback_VTable { return obj.vtable; }


    /*
    \brief Filtering data for "move" call.
    
    This class contains all filtering-related parameters for the PxController::move() call.
    
    Collisions between a CCT and the world are filtered using the mFilterData, mFilterCallback and mFilterFlags
    members. These parameters are internally passed to PxScene::overlap() to find objects touched by the CCT.
    Please refer to the PxScene::overlap() documentation for details.
    
    Collisions between a CCT and another CCT are filtered using the mCCTFilterCallback member. If this filter
    callback is not defined, none of the CCT-vs-CCT collisions are filtered, and each CCT will collide against
    all other CCTs.
    
    \note PxQueryFlag::eANY_HIT and PxQueryFlag::eNO_BLOCK are ignored in mFilterFlags.
    
    \see PxController.move() PxControllerFilterCallback
    */
    PxControllerFilters :: struct {
        //!< Data for internal PxQueryFilterData structure. Passed to PxScene::overlap() call.
        //!< This can be NULL, in which case a default PxFilterData is used.
        mFilterData:        *PxFilterData;

        mFilterCallback:    *PxQueryFilterCallback; //!< Custom filter logic (can be NULL). Passed to PxScene::overlap() call.
        mFilterFlags:       PxQueryFlags; //!< Flags for internal PxQueryFilterData structure. Passed to PxScene::overlap() call.

        mCCTFilterCallback: *PxControllerFilterCallback; //!< CCT-vs-CCT filter callback. If NULL, all CCT-vs-CCT collisions are kept.
    }

    /*
    \brief Descriptor class for a character controller.
    
    \see PxBoxController PxCapsuleController
    */
    PxControllerDesc :: struct {
        vtable: *PxControllerDesc_VTable;
        /*
        \brief Returns the character controller type
        
        \return The controllers type.
        
        \see PxControllerType PxCapsuleControllerDesc PxBoxControllerDesc
        */
        getType :: (this: *PxControllerDesc) -> PxControllerShapeType.Enum #cpp_method #foreign physxcharacterkinematic_static "?getType@PxControllerDesc@physx@@QEBA?AW4Enum@PxControllerShapeType@2@XZ";

        /*
        \brief The position of the character
        
        \note The character's initial position must be such that it does not overlap the static geometry.
        
        <b>Default:</b> Zero
        */
        position:                 PxExtendedVec3;

        /*
        \brief Specifies the 'up' direction
        
        In order to provide stepping functionality the SDK must be informed about the up direction.
        
        <b>Default:</b> (0, 1, 0)
        
        */
        upDirection:              PxVec3;

        /*
        \brief The maximum slope which the character can walk up.
        
        In general it is desirable to limit where the character can walk, in particular it is unrealistic
        for the character to be able to climb arbitary slopes.
        
        The limit is expressed as the cosine of desired limit angle. A value of 0 disables this feature.
        
        \warning It is currently enabled for static actors only (not for dynamic/kinematic actors), and not supported for spheres or capsules.
        
        <b>Default:</b> 0.707
        
        \see upDirection invisibleWallHeight maxJumpHeight
        */
        slopeLimit:               PxF32;

        /*
        \brief Height of invisible walls created around non-walkable triangles
        
        The library can automatically create invisible walls around non-walkable triangles defined
        by the 'slopeLimit' parameter. This defines the height of those walls. If it is 0.0, then
        no extra triangles are created.
        
        <b>Default:</b> 0.0
        
        \see upDirection slopeLimit maxJumpHeight
        */
        invisibleWallHeight:      PxF32;

        /*
        \brief Maximum height a jumping character can reach
        
        This is only used if invisible walls are created ('invisibleWallHeight' is non zero).
        
        When a character jumps, the non-walkable triangles he might fly over are not found
        by the collision queries (since the character's bounding volume does not touch them).
        Thus those non-walkable triangles do not create invisible walls, and it is possible
        for a jumping character to land on a non-walkable triangle, while he wouldn't have
        reached that place by just walking.
        
        The 'maxJumpHeight' variable is used to extend the size of the collision volume
        downward. This way, all the non-walkable triangles are properly found by the collision
        queries and it becomes impossible to 'jump over' invisible walls.
        
        If the character in your game can not jump, it is safe to use 0.0 here. Otherwise it
        is best to keep this value as small as possible, since a larger collision volume
        means more triangles to process.
        
        <b>Default:</b> 0.0
        
        \see upDirection slopeLimit invisibleWallHeight
        */
        maxJumpHeight:            PxF32;

        /*
        \brief The contact offset used by the controller.
        
        Specifies a skin around the object within which contacts will be generated.
        Use it to avoid numerical precision issues.
        
        This is dependant on the scale of the users world, but should be a small, positive
        non zero value.
        
        <b>Default:</b> 0.1
        */
        contactOffset:            PxF32;

        /*
        \brief Defines the maximum height of an obstacle which the character can climb.
        
        A small value will mean that the character gets stuck and cannot walk up stairs etc,
        a value which is too large will mean that the character can climb over unrealistically
        high obstacles.
        
        <b>Default:</b> 0.5
        
        \see upDirection
        */
        stepOffset:               PxF32;

        /*
        \brief Density of underlying kinematic actor
        
        The CCT creates a PhysX's kinematic actor under the hood. This controls its density.
        
        <b>Default:</b> 10.0
        */
        density:                  PxF32;

        /*
        \brief Scale coefficient for underlying kinematic actor
        
        The CCT creates a PhysX's kinematic actor under the hood. This controls its scale factor.
        This should be a number a bit smaller than 1.0.
        
        This scale factor affects how the character interacts with dynamic rigid bodies around it (e.g. pushing them, etc).
        
        With a scale factor < 1, the underlying kinematic actor will not touch surrounding rigid bodies - they will
        only interact with the character controller's shapes (capsules or boxes), and users will have full control
        over the interactions (i.e. they will have to push the objects with explicit forces themselves).
        
        With a scale factor >=1, the underlying kinematic actor will touch and push surrounding rigid bodies based
        on PhysX's computations, as if there would be no character controller involved. This works fine except
        when you push objects into a wall. PhysX has no control over kinematic actors (since they are kinematic)
        so they would freely push dynamic objects into walls, and make them tunnel / explode / behave badly.
        
        With a smaller kinematic actor however, the character controller's swept shape touches dynamic rigid bodies
        first, and can apply forces to them to move them away (or not, depending on what the gameplay needs).
        Meanwhile the character controller's swept shape itself is stopped by these dynamic bodies.
        
        Setting the scale factor to 1 could still work, but it is unreliable. Depending on FPU accuracy you could
        end up with either the CCT's volume or the underlying kinematic actor touching the dynamic bodies first,
        and this could change from one moment to the next.
        
        <b>Default:</b> 0.8
        */
        scaleCoeff:               PxF32;

        /*
        \brief Cached volume growth
        
        Amount of space around the controller we cache to improve performance. This is a scale factor
        that should be higher than 1.0f but not too big, ideally lower than 2.0f.
        
        <b>Default:</b> 1.5
        */
        volumeGrowth:             PxF32;

        /*
        \brief Specifies a user report callback.
        
        This report callback is called when the character collides with shapes and other characters.
        
        Setting this to NULL disables the callback.
        
        <b>Default:</b> NULL
        
        \see PxUserControllerHitReport
        */
        reportCallback:           *PxUserControllerHitReport;

        /*
        \brief Specifies a user behavior callback.
        
        This behavior callback is called to customize the controller's behavior w.r.t. touched shapes.
        
        Setting this to NULL disables the callback.
        
        <b>Default:</b> NULL
        
        \see PxControllerBehaviorCallback
        */
        behaviorCallback:         *PxControllerBehaviorCallback;

        /*
        \brief The non-walkable mode controls if a character controller slides or not on a non-walkable part.
        
        This is only used when slopeLimit is non zero.
        
        <b>Default:</b> PxControllerNonWalkableMode::ePREVENT_CLIMBING
        
        \see PxControllerNonWalkableMode
        */
        nonWalkableMode:          PxControllerNonWalkableMode.Enum;

        /*
        \brief The material for the actor associated with the controller.
        
        The controller internally creates a rigid body actor. This parameter specifies the material of the actor.
        
        <b>Default:</b> NULL
        
        \see PxMaterial
        */
        material:                 *PxMaterial;

        /*
        \brief Use a deletion listener to get informed about released objects and clear internal caches if needed.
        
        If a character controller registers a deletion listener, it will get informed about released objects. That allows the
        controller to invalidate cached data that connects to a released object. If a deletion listener is not
        registered, PxController::invalidateCache has to be called manually after objects have been released.
        
        \see PxController::invalidateCache
        
        <b>Default:</b> true
        */
        registerDeletionListener: bool;

        /*
        \brief Client ID for associated actor.
        
        \see PxClientID PxActor::setOwnerClient
        
        <b>Default:</b> PX_DEFAULT_CLIENT
        */
        clientID:                 PxClientID;

        /*
        \brief User specified data associated with the controller.
        
        <b>Default:</b> NULL
        */
        userData:                 *void;

        mType:                    PxControllerShapeType.Enum; //!< The type of the controller. This gets set by the derived class' ctor, the user should not have to change it.
    }
    PxControllerDesc_VTable :: struct #type_info_none {
        isValid: (this: *PxControllerDesc) -> bool #cpp_method;

        Destructor: (this: *PxControllerDesc, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxControllerDesc_isValid :: inline (this: *PxControllerDesc) -> bool { return this.vtable.isValid(this); }

    PxControllerDesc_Destructor :: inline (this: *PxControllerDesc, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxControllerDesc) -> *PxControllerDesc_VTable { return obj.vtable; }


    /*
    \brief Base class for character controllers.
    
    \see PxCapsuleController PxBoxController
    */
    PxController :: struct {
        vtable: *PxController_VTable;
        Constructor :: (this: *PxController) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxController@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxController, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxController@physx@@MEAA@XZ";
    }
    PxController_VTable :: struct #type_info_none {
        getType: (this: *PxController) -> PxControllerShapeType.Enum #cpp_method;

        release: (this: *PxController) -> void #cpp_method;

        move: (this: *PxController, disp: *PxVec3, minDist: PxF32, elapsedTime: PxF32, filters: *PxControllerFilters, obstacles: *PxObstacleContext = null) -> PxControllerCollisionFlags #cpp_method;

        setPosition: (this: *PxController, position: *PxExtendedVec3) -> bool #cpp_method;

        getPosition: (this: *PxController) -> *PxExtendedVec3 #cpp_method;

        setFootPosition: (this: *PxController, position: *PxExtendedVec3) -> bool #cpp_method;

        getFootPosition: (this: *PxController) -> PxExtendedVec3 #cpp_method;

        getActor: (this: *PxController) -> *PxRigidDynamic #cpp_method;

        setStepOffset: (this: *PxController, offset: PxF32) -> void #cpp_method;

        getStepOffset: (this: *PxController) -> PxF32 #cpp_method;

        setNonWalkableMode: (this: *PxController, flag: PxControllerNonWalkableMode.Enum) -> void #cpp_method;

        getNonWalkableMode: (this: *PxController) -> PxControllerNonWalkableMode.Enum #cpp_method;

        getContactOffset: (this: *PxController) -> PxF32 #cpp_method;

        setContactOffset: (this: *PxController, offset: PxF32) -> void #cpp_method;

        getUpDirection: (this: *PxController) -> PxVec3 #cpp_method;

        setUpDirection: (this: *PxController, up: *PxVec3) -> void #cpp_method;

        getSlopeLimit: (this: *PxController) -> PxF32 #cpp_method;

        setSlopeLimit: (this: *PxController, slopeLimit: PxF32) -> void #cpp_method;

        invalidateCache: (this: *PxController) -> void #cpp_method;

        getScene: (this: *PxController) -> *PxScene #cpp_method;

        getUserData: (this: *PxController) -> *void #cpp_method;

        setUserData: (this: *PxController, userData: *void) -> void #cpp_method;

        getState: (this: *PxController, state: *PxControllerState) -> void #cpp_method;

        getStats: (this: *PxController, stats: *PxControllerStats) -> void #cpp_method;

        resize: (this: *PxController, height: PxReal) -> void #cpp_method;

        Destructor: (this: *PxController, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxController_getType :: inline (this: *PxController) -> PxControllerShapeType.Enum { return this.vtable.getType(this); }

    PxController_release :: inline (this: *PxController) { this.vtable.release(this); }

    PxController_move :: inline (this: *PxController, disp: *PxVec3, minDist: PxF32, elapsedTime: PxF32, filters: *PxControllerFilters, obstacles: *PxObstacleContext = null) -> PxControllerCollisionFlags { return this.vtable.move(this, disp, minDist, elapsedTime, filters, obstacles); }

    PxController_setPosition :: inline (this: *PxController, position: *PxExtendedVec3) -> bool { return this.vtable.setPosition(this, position); }

    PxController_getPosition :: inline (this: *PxController) -> *PxExtendedVec3 { return this.vtable.getPosition(this); }

    PxController_setFootPosition :: inline (this: *PxController, position: *PxExtendedVec3) -> bool { return this.vtable.setFootPosition(this, position); }

    PxController_getFootPosition :: inline (this: *PxController) -> PxExtendedVec3 { return this.vtable.getFootPosition(this); }

    PxController_getActor :: inline (this: *PxController) -> *PxRigidDynamic { return this.vtable.getActor(this); }

    PxController_setStepOffset :: inline (this: *PxController, offset: PxF32) { this.vtable.setStepOffset(this, offset); }

    PxController_getStepOffset :: inline (this: *PxController) -> PxF32 { return this.vtable.getStepOffset(this); }

    PxController_setNonWalkableMode :: inline (this: *PxController, flag: PxControllerNonWalkableMode.Enum) { this.vtable.setNonWalkableMode(this, flag); }

    PxController_getNonWalkableMode :: inline (this: *PxController) -> PxControllerNonWalkableMode.Enum { return this.vtable.getNonWalkableMode(this); }

    PxController_getContactOffset :: inline (this: *PxController) -> PxF32 { return this.vtable.getContactOffset(this); }

    PxController_setContactOffset :: inline (this: *PxController, offset: PxF32) { this.vtable.setContactOffset(this, offset); }

    PxController_getUpDirection :: inline (this: *PxController) -> PxVec3 { return this.vtable.getUpDirection(this); }

    PxController_setUpDirection :: inline (this: *PxController, up: *PxVec3) { this.vtable.setUpDirection(this, up); }

    PxController_getSlopeLimit :: inline (this: *PxController) -> PxF32 { return this.vtable.getSlopeLimit(this); }

    PxController_setSlopeLimit :: inline (this: *PxController, slopeLimit: PxF32) { this.vtable.setSlopeLimit(this, slopeLimit); }

    PxController_invalidateCache :: inline (this: *PxController) { this.vtable.invalidateCache(this); }

    PxController_getScene :: inline (this: *PxController) -> *PxScene { return this.vtable.getScene(this); }

    PxController_getUserData :: inline (this: *PxController) -> *void { return this.vtable.getUserData(this); }

    PxController_setUserData :: inline (this: *PxController, userData: *void) { this.vtable.setUserData(this, userData); }

    PxController_getState :: inline (this: *PxController, state: *PxControllerState) { this.vtable.getState(this, state); }

    PxController_getStats :: inline (this: *PxController, stats: *PxControllerStats) { this.vtable.getStats(this, stats); }

    PxController_resize :: inline (this: *PxController, height: PxReal) { this.vtable.resize(this, height); }

    PxController_Destructor :: inline (this: *PxController, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxController) -> *PxController_VTable { return obj.vtable; }


    /*
    \brief Descriptor for a box character controller.
    
    \see PxBoxController PxControllerDesc
    */
    PxBoxControllerDesc :: struct {
        #as using pxcontrollerdesc: PxControllerDesc;

        halfHeight:        PxF32; // Half-height in the "up" direction

        halfSideExtent:    PxF32; // Half-extent in the "side" direction

        halfForwardExtent: PxF32; // Half-extent in the "forward" direction
        #place pxcontrollerdesc; pxboxcontrollerdesc_vtable: *PxBoxControllerDesc_VTable;
    }
    PxBoxControllerDesc_VTable :: struct #type_info_none {
        using pxcontrollerdesc: PxControllerDesc_VTable;
        setToDefault: (this: *PxBoxControllerDesc) -> void #cpp_method;
    }
    PxBoxControllerDesc_setToDefault :: inline (this: *PxBoxControllerDesc) { this.pxboxcontrollerdesc_vtable.setToDefault(this); }

    vtable :: (obj: *PxBoxControllerDesc) -> *PxBoxControllerDesc_VTable { return obj.pxboxcontrollerdesc_vtable; }


    /*
    \brief Box character controller.
    
    \see PxBoxControllerDesc PxController
    */
    PxBoxController :: struct {
        #as using pxcontroller: PxController;

        Constructor :: (this: *PxBoxController) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxBoxController@physx@@IEAA@XZ";
        #place pxcontroller; pxboxcontroller_vtable: *PxBoxController_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxBoxController, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxBoxController@physx@@MEAA@XZ";
    }
    PxBoxController_VTable :: struct #type_info_none {
        using pxcontroller: PxController_VTable;
        getHalfHeight: (this: *PxBoxController) -> PxF32 #cpp_method;

        getHalfSideExtent: (this: *PxBoxController) -> PxF32 #cpp_method;

        getHalfForwardExtent: (this: *PxBoxController) -> PxF32 #cpp_method;

        setHalfHeight: (this: *PxBoxController, halfHeight: PxF32) -> bool #cpp_method;

        setHalfSideExtent: (this: *PxBoxController, halfSideExtent: PxF32) -> bool #cpp_method;

        setHalfForwardExtent: (this: *PxBoxController, halfForwardExtent: PxF32) -> bool #cpp_method;
    }

    PxBoxController_getHalfHeight :: inline (this: *PxBoxController) -> PxF32 { return this.pxboxcontroller_vtable.getHalfHeight(this); }

    PxBoxController_getHalfSideExtent :: inline (this: *PxBoxController) -> PxF32 { return this.pxboxcontroller_vtable.getHalfSideExtent(this); }

    PxBoxController_getHalfForwardExtent :: inline (this: *PxBoxController) -> PxF32 { return this.pxboxcontroller_vtable.getHalfForwardExtent(this); }

    PxBoxController_setHalfHeight :: inline (this: *PxBoxController, halfHeight: PxF32) -> bool { return this.pxboxcontroller_vtable.setHalfHeight(this, halfHeight); }

    PxBoxController_setHalfSideExtent :: inline (this: *PxBoxController, halfSideExtent: PxF32) -> bool { return this.pxboxcontroller_vtable.setHalfSideExtent(this, halfSideExtent); }

    PxBoxController_setHalfForwardExtent :: inline (this: *PxBoxController, halfForwardExtent: PxF32) -> bool { return this.pxboxcontroller_vtable.setHalfForwardExtent(this, halfForwardExtent); }

    vtable :: (obj: *PxBoxController) -> *PxBoxController_VTable { return obj.pxboxcontroller_vtable; }


    PxCapsuleClimbingMode :: struct {
        Enum :: enum s32 {
            EASY        :: 0;
            CONSTRAINED :: 1;

            LAST        :: 2;

            eEASY        :: EASY;
            eCONSTRAINED :: CONSTRAINED;

            eLAST        :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief A descriptor for a capsule character controller.
    
    \see PxCapsuleController PxControllerDesc
    */
    PxCapsuleControllerDesc :: struct {
        #as using pxcontrollerdesc: PxControllerDesc;

        /*
        \brief The radius of the capsule
        
        <b>Default:</b> 0.0
        
        \see PxCapsuleController
        */
        radius:       PxF32;

        /*
        \brief The height of the controller
        
        <b>Default:</b> 0.0
        
        \see PxCapsuleController
        */
        height:       PxF32;

        /*
        \brief The climbing mode
        
        <b>Default:</b> PxCapsuleClimbingMode::eEASY
        
        \see PxCapsuleController
        */
        climbingMode: PxCapsuleClimbingMode.Enum;
        #place pxcontrollerdesc; pxcapsulecontrollerdesc_vtable: *PxCapsuleControllerDesc_VTable;
    }
    PxCapsuleControllerDesc_VTable :: struct #type_info_none {
        using pxcontrollerdesc: PxControllerDesc_VTable;
        setToDefault: (this: *PxCapsuleControllerDesc) -> void #cpp_method;
    }
    PxCapsuleControllerDesc_setToDefault :: inline (this: *PxCapsuleControllerDesc) { this.pxcapsulecontrollerdesc_vtable.setToDefault(this); }

    vtable :: (obj: *PxCapsuleControllerDesc) -> *PxCapsuleControllerDesc_VTable { return obj.pxcapsulecontrollerdesc_vtable; }


    /*
    \brief A capsule character controller.
    
    The capsule is defined as a position, a vertical height, and a radius.
    The height is the distance between the two sphere centers at the end of the capsule.
    In other words:
    
    p = pos (returned by controller)<br>
    h = height<br>
    r = radius<br>
    
    p = center of capsule<br>
    top sphere center = p.y + h*0.5<br>
    bottom sphere center = p.y - h*0.5<br>
    top capsule point = p.y + h*0.5 + r<br>
    bottom capsule point = p.y - h*0.5 - r<br>
    */
    PxCapsuleController :: struct {
        #as using pxcontroller: PxController;

        Constructor :: (this: *PxCapsuleController) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxCapsuleController@physx@@IEAA@XZ";
        #place pxcontroller; pxcapsulecontroller_vtable: *PxCapsuleController_VTable;

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxCapsuleController, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxCapsuleController@physx@@MEAA@XZ";
    }
    PxCapsuleController_VTable :: struct #type_info_none {
        using pxcontroller: PxController_VTable;
        getRadius: (this: *PxCapsuleController) -> PxF32 #cpp_method;

        setRadius: (this: *PxCapsuleController, radius: PxF32) -> bool #cpp_method;

        getHeight: (this: *PxCapsuleController) -> PxF32 #cpp_method;

        setHeight: (this: *PxCapsuleController, height: PxF32) -> bool #cpp_method;

        getClimbingMode: (this: *PxCapsuleController) -> PxCapsuleClimbingMode.Enum #cpp_method;

        setClimbingMode: (this: *PxCapsuleController, mode: PxCapsuleClimbingMode.Enum) -> bool #cpp_method;
    }

    PxCapsuleController_getRadius :: inline (this: *PxCapsuleController) -> PxF32 { return this.pxcapsulecontroller_vtable.getRadius(this); }

    PxCapsuleController_setRadius :: inline (this: *PxCapsuleController, radius: PxF32) -> bool { return this.pxcapsulecontroller_vtable.setRadius(this, radius); }

    PxCapsuleController_getHeight :: inline (this: *PxCapsuleController) -> PxF32 { return this.pxcapsulecontroller_vtable.getHeight(this); }

    PxCapsuleController_setHeight :: inline (this: *PxCapsuleController, height: PxF32) -> bool { return this.pxcapsulecontroller_vtable.setHeight(this, height); }

    PxCapsuleController_getClimbingMode :: inline (this: *PxCapsuleController) -> PxCapsuleClimbingMode.Enum { return this.pxcapsulecontroller_vtable.getClimbingMode(this); }

    PxCapsuleController_setClimbingMode :: inline (this: *PxCapsuleController, mode: PxCapsuleClimbingMode.Enum) -> bool { return this.pxcapsulecontroller_vtable.setClimbingMode(this, mode); }

    vtable :: (obj: *PxCapsuleController) -> *PxCapsuleController_VTable { return obj.pxcapsulecontroller_vtable; }


    /*
    \brief specifies controller behavior
    */
    PxControllerBehaviorFlag :: struct {
        Enum :: enum s32 {
            CAN_RIDE_ON_OBJECT :: 1;
            SLIDE              :: 2;
            USER_DEFINED_RIDE  :: 4;

            eCCT_CAN_RIDE_ON_OBJECT :: CAN_RIDE_ON_OBJECT;
            eCCT_SLIDE              :: SLIDE;
            eCCT_USER_DEFINED_RIDE  :: USER_DEFINED_RIDE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxControllerBehaviorFlag.
    
    \see PxControllerBehaviorFlag
    */
    PxControllerBehaviorFlags :: PxFlags(PxControllerBehaviorFlag.Enum, PxU8);

    /*
    \brief User behavior callback.
    
    This behavior callback is called to customize the controller's behavior w.r.t. touched shapes.
    */
    PxControllerBehaviorCallback :: struct {
        vtable: *PxControllerBehaviorCallback_VTable;
    }
    PxControllerBehaviorCallback_VTable :: struct #type_info_none {
        getBehaviorFlags: (this: *PxControllerBehaviorCallback, obstacle: *PxObstacle) -> PxControllerBehaviorFlags #cpp_method;

        getBehaviorFlags_1: (this: *PxControllerBehaviorCallback, controller: /*const reference*/ *PxController) -> PxControllerBehaviorFlags #cpp_method;

        getBehaviorFlags_2: (this: *PxControllerBehaviorCallback, shape: /*const reference*/ *PxShape, actor: /*const reference*/ *PxActor) -> PxControllerBehaviorFlags #cpp_method;

        Destructor: (this: *PxControllerBehaviorCallback, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxControllerBehaviorCallback_getBehaviorFlags :: inline (this: *PxControllerBehaviorCallback, obstacle: /*const reference*/ *PxObstacle) -> PxControllerBehaviorFlags { return this.vtable.getBehaviorFlags(this, obstacle); }

    PxControllerBehaviorCallback_getBehaviorFlags_1 :: inline (this: *PxControllerBehaviorCallback, controller: /*const reference*/ *PxController) -> PxControllerBehaviorFlags { return this.vtable.getBehaviorFlags_1(this, controller); }

    PxControllerBehaviorCallback_getBehaviorFlags_2 :: inline (this: *PxControllerBehaviorCallback, shape: /*const reference*/ *PxShape, actor: /*const reference*/ *PxActor) -> PxControllerBehaviorFlags { return this.vtable.getBehaviorFlags_2(this, shape, actor); }

    PxControllerBehaviorCallback_Destructor :: inline (this: *PxControllerBehaviorCallback, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxControllerBehaviorCallback) -> *PxControllerBehaviorCallback_VTable { return obj.vtable; }


    /*
    \brief specifies debug-rendering flags
    */
    PxControllerDebugRenderFlag :: struct {
        Enum :: enum s32 {
            TEMPORAL_BV :: 1;
            CACHED_BV   :: 2;
            OBSTACLES   :: 4;

            NONE        :: 0;
            ALL         :: -1;

            eTEMPORAL_BV :: TEMPORAL_BV;
            eCACHED_BV   :: CACHED_BV;
            eOBSTACLES   :: OBSTACLES;

            eNONE        :: NONE;
            eALL         :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxControllerDebugRenderFlag.
    
    \see PxControllerDebugRenderFlag
    */
    PxControllerDebugRenderFlags :: PxFlags(PxControllerDebugRenderFlag.Enum, PxU32);

    /*
    \brief Manages an array of character controllers.
    
    \see PxController PxBoxController PxCapsuleController
    */
    PxControllerManager :: struct {
        vtable: *PxControllerManager_VTable;
        Constructor :: (this: *PxControllerManager) -> void #cpp_method #foreign physxcharacterkinematic_static "??0PxControllerManager@physx@@IEAA@XZ";

        // Virtual functions:
        // Normally you should call them via the vtable.
        // But these bindings can be useful if you need to call the parent implementation in a sub-struct’s overwritten method
        // or need to create a vtable yourself.
        virtual_Destructor :: (this: *PxControllerManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method #foreign physxcharacterkinematic_static "??1PxControllerManager@physx@@MEAA@XZ";
    }
    PxControllerManager_VTable :: struct #type_info_none {
        release: (this: *PxControllerManager) -> void #cpp_method;

        getScene: (this: *PxControllerManager) -> *PxScene #cpp_method;

        getNbControllers: (this: *PxControllerManager) -> PxU32 #cpp_method;

        getController: (this: *PxControllerManager, index: PxU32) -> *PxController #cpp_method;

        createController: (this: *PxControllerManager, desc: *PxControllerDesc) -> *PxController #cpp_method;

        purgeControllers: (this: *PxControllerManager) -> void #cpp_method;

        getRenderBuffer: (this: *PxControllerManager) -> *PxRenderBuffer #cpp_method;

        setDebugRenderingFlags: (this: *PxControllerManager, flags: PxControllerDebugRenderFlags) -> void #cpp_method;

        getNbObstacleContexts: (this: *PxControllerManager) -> PxU32 #cpp_method;

        getObstacleContext: (this: *PxControllerManager, index: PxU32) -> *PxObstacleContext #cpp_method;

        createObstacleContext: (this: *PxControllerManager) -> *PxObstacleContext #cpp_method;

        computeInteractions: (this: *PxControllerManager, elapsedTime: PxF32, cctFilterCb: *PxControllerFilterCallback = null) -> void #cpp_method;

        setTessellation: (this: *PxControllerManager, flag: bool, maxEdgeLength: float) -> void #cpp_method;

        setOverlapRecoveryModule: (this: *PxControllerManager, flag: bool) -> void #cpp_method;

        setPreciseSweeps: (this: *PxControllerManager, flag: bool) -> void #cpp_method;

        setPreventVerticalSlidingAgainstCeiling: (this: *PxControllerManager, flag: bool) -> void #cpp_method;

        shiftOrigin: (this: *PxControllerManager, shift: *PxVec3) -> void #cpp_method;

        Destructor: (this: *PxControllerManager, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxControllerManager_release :: inline (this: *PxControllerManager) { this.vtable.release(this); }

    PxControllerManager_getScene :: inline (this: *PxControllerManager) -> *PxScene { return this.vtable.getScene(this); }

    PxControllerManager_getNbControllers :: inline (this: *PxControllerManager) -> PxU32 { return this.vtable.getNbControllers(this); }

    PxControllerManager_getController :: inline (this: *PxControllerManager, index: PxU32) -> *PxController { return this.vtable.getController(this, index); }

    PxControllerManager_createController :: inline (this: *PxControllerManager, desc: *PxControllerDesc) -> *PxController { return this.vtable.createController(this, desc); }

    PxControllerManager_purgeControllers :: inline (this: *PxControllerManager) { this.vtable.purgeControllers(this); }

    PxControllerManager_getRenderBuffer :: inline (this: *PxControllerManager) -> *PxRenderBuffer { return this.vtable.getRenderBuffer(this); }

    PxControllerManager_setDebugRenderingFlags :: inline (this: *PxControllerManager, flags: PxControllerDebugRenderFlags) { this.vtable.setDebugRenderingFlags(this, flags); }

    PxControllerManager_getNbObstacleContexts :: inline (this: *PxControllerManager) -> PxU32 { return this.vtable.getNbObstacleContexts(this); }

    PxControllerManager_getObstacleContext :: inline (this: *PxControllerManager, index: PxU32) -> *PxObstacleContext { return this.vtable.getObstacleContext(this, index); }

    PxControllerManager_createObstacleContext :: inline (this: *PxControllerManager) -> *PxObstacleContext { return this.vtable.createObstacleContext(this); }

    PxControllerManager_computeInteractions :: inline (this: *PxControllerManager, elapsedTime: PxF32, cctFilterCb: *PxControllerFilterCallback = null) { this.vtable.computeInteractions(this, elapsedTime, cctFilterCb); }

    PxControllerManager_setTessellation :: inline (this: *PxControllerManager, flag: bool, maxEdgeLength: float) { this.vtable.setTessellation(this, flag, maxEdgeLength); }

    PxControllerManager_setOverlapRecoveryModule :: inline (this: *PxControllerManager, flag: bool) { this.vtable.setOverlapRecoveryModule(this, flag); }

    PxControllerManager_setPreciseSweeps :: inline (this: *PxControllerManager, flag: bool) { this.vtable.setPreciseSweeps(this, flag); }

    PxControllerManager_setPreventVerticalSlidingAgainstCeiling :: inline (this: *PxControllerManager, flag: bool) { this.vtable.setPreventVerticalSlidingAgainstCeiling(this, flag); }

    PxControllerManager_shiftOrigin :: inline (this: *PxControllerManager, shift: *PxVec3) { this.vtable.shiftOrigin(this, shift); }

    PxControllerManager_Destructor :: inline (this: *PxControllerManager, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxControllerManager) -> *PxControllerManager_VTable { return obj.vtable; }


    PxSDFBuilder :: struct {}

    /*
    \brief A helper structure to define dimensions in 3D
    */
    PxDim3 :: struct {
        x: PxU32;
        y: PxU32;
        z: PxU32;
    }

    /*
    \brief Defines the number of bits per subgrid pixel
    */
    PxSdfBitsPerSubgridPixel :: struct {
        Enum :: enum s32 {
            _8_BIT_PER_PIXEL  :: 1;
            _16_BIT_PER_PIXEL :: 2;
            _32_BIT_PER_PIXEL :: 4;

            e8_BIT_PER_PIXEL  :: _8_BIT_PER_PIXEL;
            e16_BIT_PER_PIXEL :: _16_BIT_PER_PIXEL;
            e32_BIT_PER_PIXEL :: _32_BIT_PER_PIXEL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief A structure describing signed distance field for mesh.
    */
    PxSDFDesc :: struct {
        /*
        \brief Pointer to first sdf array element.
        */
        sdf:                                            PxBoundedData;

        /*
        \brief Dimensions of sdf
        */
        dims:                                           PxDim3;

        /*
        \brief The Lower bound of the original mesh
        */
        meshLower:                                      PxVec3;

        /*
        \brief The spacing of each sdf voxel
        */
        spacing:                                        PxReal;

        /*
        \brief The number of cells in a sparse subgrid block (full block has subgridSize^3 cells and (subgridSize+1)^3 samples). If set to zero, this indicates that only a dense background grid SDF is used without sparse blocks
        */
        subgridSize:                                    PxU32;

        /*
        \brief Enumeration that defines the number of bits per subgrid pixel (either 32, 16 or 8bits)
        */
        bitsPerSubgridPixel:                            PxSdfBitsPerSubgridPixel.Enum;

        /*
        \brief Number of subgrid blocks in the 3d texture. The full texture dimension will be sdfSubgrids3DTexBlockDim*(subgridSize+1).
        */
        sdfSubgrids3DTexBlockDim:                       PxDim3;

        /*
        \brief The data to create the 3d texture containg the packed subgrid blocks. Stored as PxU8 to support multiple formats (8, 16 and 32 bits per pixel)
        */
        sdfSubgrids:                                    PxBoundedData;

        /*
        \brief Array with start indices into the subgrid texture for every subgrid block. 10bits for z coordinate, 10bits for y and 10bits for x. Encoding is as follows: slot = (z << 20) | (y << 10) | x
        */
        sdfStartSlots:                                  PxBoundedData;

        /*
        \brief The minimum value over all subgrid blocks. Used if normalized textures are used which is the case for 8 and 16bit formats
        */
        subgridsMinSdfValue:                            PxReal;

        /*
        \brief The maximum value over all subgrid blocks. Used if normalized textures are used which is the case for 8 and 16bit formats
        */
        subgridsMaxSdfValue:                            PxReal;

        /*
        \brief The bounds of the sdf. If left unassigned (empty), the bounds of the mesh will be used
        */
        sdfBounds:                                      PxBounds3;

        /*
        \brief Narrow band thickness as a fraction of the bounds diagonal length. Every subgrid block that
        overlaps with the narrow band around the mesh surface will be kept providing high resolution around the mesh surface.
        The valid range of this parameter is (0, 1). The higher the value, the more subgrids will get created, the more memory will be required.
        */
        narrowBandThicknessRelativeToSdfBoundsDiagonal: PxReal;

        /*
        \brief The number of threads that are launched to compute the signed distance field
        */
        numThreadsForSdfConstruction:                   PxU32;

        /*
        \brief Optional pointer to the geometry of the mesh that is used to compute the SDF. If it is not set, the geometry of the mesh, that this descriptor is passed to during cooking, will be taken.
        The mesh data must only be available during cooking. It can be released once cooking completed.
        */
        baseMesh:                                       PxSimpleTriangleMesh;

        /*
        \brief Optional pointer to an instance of a SDF builder. This significantly speeds up the construction of the SDF since the default SDF builder will do almost all computations directly on the GPU.
        The user must release the instance of the SDF builder once cooking completed.
        */
        sdfBuilder:                                     *PxSDFBuilder;

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid
        */
        isValid :: (this: *PxSDFDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxSDFDesc@physx@@QEBA_NXZ";
    }

    /*
    \brief Flags which describe the format and behavior of a convex mesh.
    */
    PxConvexFlag :: struct {
        Enum :: enum s32 {
            _16_BIT_INDICES           :: 1;

            COMPUTE_CONVEX            :: 2;

            CHECK_ZERO_AREA_TRIANGLES :: 4;

            QUANTIZE_INPUT            :: 8;

            DISABLE_MESH_VALIDATION   :: 16;

            PLANE_SHIFTING            :: 32;

            FAST_INERTIA_COMPUTATION  :: 64;

            GPU_COMPATIBLE            :: 128;

            SHIFT_VERTICES            :: 256;

            e16_BIT_INDICES            :: _16_BIT_INDICES;

            eCOMPUTE_CONVEX            :: COMPUTE_CONVEX;

            eCHECK_ZERO_AREA_TRIANGLES :: CHECK_ZERO_AREA_TRIANGLES;

            eQUANTIZE_INPUT            :: QUANTIZE_INPUT;

            eDISABLE_MESH_VALIDATION   :: DISABLE_MESH_VALIDATION;

            ePLANE_SHIFTING            :: PLANE_SHIFTING;

            eFAST_INERTIA_COMPUTATION  :: FAST_INERTIA_COMPUTATION;

            eGPU_COMPATIBLE            :: GPU_COMPATIBLE;

            eSHIFT_VERTICES            :: SHIFT_VERTICES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief collection of set bits defined in PxConvexFlag.
    
    \see PxConvexFlag
    */
    PxConvexFlags :: PxFlags(PxConvexFlag.Enum, PxU16);
    operator~ :: (a: PxConvexFlag.Enum) -> PxFlags(PxConvexFlag.Enum, PxU16) #foreign physxcommon_static "??Sphysx@@YA?AV?$PxFlags@W4Enum@PxConvexFlag@physx@@G@0@W4Enum@PxConvexFlag@0@@Z";

    /*
    \brief Descriptor class for #PxConvexMesh.
    \note The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 256.
    \note The number of vertices and the number of convex polygons in a GPU compatible convex mesh is limited to 64,
    and the number of faces per vertex is limited to 32.
    
    \see PxConvexMesh PxConvexMeshGeometry PxShape PxPhysics.createConvexMesh()
    
    */
    PxConvexMeshDesc :: struct {
        /*
        \brief Vertex positions data in PxBoundedData format.
        
        <b>Default:</b> NULL
        */
        points:         PxBoundedData;

        /*
        \brief Polygons data in PxBoundedData format.
        <p>Pointer to first polygon. </p>
        
        <b>Default:</b> NULL
        
        \see PxHullPolygon
        */
        polygons:       PxBoundedData;

        /*
        \brief Polygon indices data in PxBoundedData format.
        <p>Pointer to first index.</p>
        
        <b>Default:</b> NULL
        
        <p>This is declared as a void pointer because it is actually either an PxU16 or a PxU32 pointer.</p>
        
        \see PxHullPolygon PxConvexFlag::e16_BIT_INDICES
        */
        indices:        PxBoundedData;

        /*
        \brief Flags bits, combined from values of the enum ::PxConvexFlag
        
        <b>Default:</b> 0
        */
        flags:          PxConvexFlags;

        /*
        \brief Limits the number of vertices of the result convex mesh. Hard maximum limit is 255
        and minimum limit is 4 if PxConvexFlag::ePLANE_SHIFTING is used, otherwise the minimum
        limit is 8.
        
        \note The please see PxConvexFlag::ePLANE_SHIFTING for algorithm explanation
        \note The maximum limit for GPU compatible convex meshes is 64.
        
        \see PxConvexFlag::ePLANE_SHIFTING
        
        <b>Range:</b> [4, 255]<br>
        <b>Default:</b> 255
        */
        vertexLimit:    PxU16;

        /*
        \brief Limits the number of polygons of the result convex mesh. Hard maximum limit is 255
        and minimum limit is 4.
        
        \note The maximum limit for GPU compatible convex meshes is 64.
        
        <b>Range:</b> [4, 255]<br>
        <b>Default:</b> 255
        */
        polygonLimit:   PxU16;

        /*
        \brief Maximum number of vertices after quantization. The quantization is done during the vertex cleaning phase.
        The quantization is applied when PxConvexFlag::eQUANTIZE_INPUT is specified.
        
        \see PxConvexFlag::eQUANTIZE_INPUT
        
        <b>Range:</b> [4, 65535]<br>
        <b>Default:</b> 255
        */
        quantizedCount: PxU16;

        /*
        \brief SDF descriptor. When this descriptor is set, signed distance field is calculated for this convex mesh.
        
        <b>Default:</b> NULL
        */
        sdfDesc:        *PxSDFDesc;

        /*
        \brief constructor sets to default.
        */
        Constructor :: (this: *PxConvexMeshDesc) -> void #cpp_method #foreign physxcommon_static "??0PxConvexMeshDesc@physx@@QEAA@XZ";

        /*
        \brief Returns true if the descriptor is valid.
        
        \return True if the current settings are valid
        */
        isValid :: (this: *PxConvexMeshDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxConvexMeshDesc@physx@@QEBA_NXZ";
    }

    /*
    \brief Descriptor class for #PxTriangleMesh.
    
    Note that this class is derived from PxSimpleTriangleMesh which contains the members that describe the basic mesh.
    The mesh data is *copied* when an PxTriangleMesh object is created from this descriptor. After the call the
    user may discard the triangle data.
    
    \see PxTriangleMesh PxTriangleMeshGeometry PxShape
    */
    PxTriangleMeshDesc :: struct {
        #as using pxsimpletrianglemesh: PxSimpleTriangleMesh;

        /*
        Optional pointer to first material index, or NULL. There are PxSimpleTriangleMesh::numTriangles indices in total.
        Caller may add materialIndexStride bytes to the pointer to access the next triangle.
        
        When a triangle mesh collides with another object, a material is required at the collision point.
        If materialIndices is NULL, then the material of the PxShape instance is used.
        Otherwise, if the point of contact is on a triangle with index i, then the material index is determined as:
        PxMaterialTableIndex	index = *(PxMaterialTableIndex *)(((PxU8*)materialIndices) + materialIndexStride * i);
        
        If the contact point falls on a vertex or an edge, a triangle adjacent to the vertex or edge is selected, and its index
        used to look up a material. The selection is arbitrary but consistent over time.
        
        <b>Default:</b> NULL
        
        \see materialIndexStride
        */
        materialIndices: PxTypedStridedData(PxMaterialTableIndex);

        /*
        \brief SDF descriptor. When this descriptor is set, signed distance field is calculated for this convex mesh.
        
        <b>Default:</b> NULL
        */
        sdfDesc:         *PxSDFDesc;

        /*
        \brief Constructor sets to default.
        */
        Constructor :: (this: *PxTriangleMeshDesc) -> void #cpp_method #foreign physxcommon_static "??0PxTriangleMeshDesc@physx@@QEAA@XZ";

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid
        */
        isValid :: (this: *PxTriangleMeshDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxTriangleMeshDesc@physx@@QEBA_NXZ";
    }

    /*
    \brief Descriptor class for #PxTetrahedronMesh (contains only pure geometric data).
    
    \see PxTetrahedronMesh PxShape
    */
    PxTetrahedronMeshDesc :: struct {
        /*
        \brief Defines the tetrahedron structure of a mesh.
        */
        PxMeshFormat :: enum s32 {
            TET_MESH :: 0;
            HEX_MESH :: 1;

            eTET_MESH :: TET_MESH;
            eHEX_MESH :: HEX_MESH;
        }

        /*
        Optional pointer to first material index, or NULL. There are PxTetrahedronMesh::numTriangles indices in total.
        Caller may add materialIndexStride bytes to the pointer to access the next triangle.
        
        When a tetrahedron mesh collides with another object, a material is required at the collision point.
        If materialIndices is NULL, then the material of the PxShape instance is used.
        Otherwise, if the point of contact is on a tetrahedron with index i, then the material index is determined as:
        PxFEMMaterialTableIndex	index = *(PxFEMMaterialTableIndex *)(((PxU8*)materialIndices) + materialIndexStride * i);
        
        If the contact point falls on a vertex or an edge, a tetrahedron adjacent to the vertex or edge is selected, and its index
        used to look up a material. The selection is arbitrary but consistent over time.
        
        <b>Default:</b> NULL
        
        \see materialIndexStride
        */
        materialIndices: PxTypedStridedData(PxFEMMaterialTableIndex);

        /*
        \brief Pointer to first vertex point.
        */
        points:          PxBoundedData;

        /*
        \brief Pointer to first tetrahedron.
        
        Caller may add tetrhedronStrideBytes bytes to the pointer to access the next tetrahedron.
        
        These are quadruplets of 0 based indices:
        vert0 vert1 vert2 vert3
        vert0 vert1 vert2 vert3
        vert0 vert1 vert2 vert3
        ...
        
        where vertex is either a 32 or 16 bit unsigned integer. There are numTetrahedrons*4 indices.
        
        This is declared as a void pointer because it is actually either an PxU16 or a PxU32 pointer.
        */
        tetrahedrons:    PxBoundedData;

        /*
        \brief Flags bits, combined from values of the enum ::PxMeshFlag
        */
        flags:           PxMeshFlags;

        /*
        \brief Used for simulation meshes only. Defines if this tet mesh should be simulated as a tet mesh,
        or if a set of tetrahedra should be used to represent another shape, e.g. a hexahedral mesh constructed
        from 5 or 6 elements.
        */
        tetsPerElement:  PxU16;

        isValid :: (this: *PxTetrahedronMeshDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxTetrahedronMeshDesc@physx@@QEBA_NXZ";
    }

    //\see PxSoftBodyMesh PxShape
    ///
    PxSoftBodySimulationDataDesc :: struct {
        /*
        \brief Pointer to first index of tetrahedron that contains the vertex at the same location in the vertex buffer.
        if left unassigned it will be computed automatically. If a point is inside multiple tetrahedra (ambiguous case), the frist one found will be taken.
        */
        vertexToTet: PxBoundedData;

        isValid :: (this: *PxSoftBodySimulationDataDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxSoftBodySimulationDataDesc@physx@@QEBA_NXZ";
    }

    /*
    \deprecated This is only used for BVH33 which is deprecated and will be removed in a future version. Use BVH34 instead.
    
    \brief Enumeration for mesh cooking hints.
    */
    PxMeshCookingHint :: struct {
        Enum :: enum s32 {
            SIM_PERFORMANCE     :: 0;
            COOKING_PERFORMANCE :: 1;

            eSIM_PERFORMANCE     :: SIM_PERFORMANCE;
            eCOOKING_PERFORMANCE :: COOKING_PERFORMANCE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated BVH33 is deprecated and will be removed in a future version. Use BVH34 instead.
    
    \brief Structure describing parameters affecting BVH33 midphase mesh structure.
    
    \see PxCookingParams, PxMidphaseDesc
    */
    PxBVH33MidphaseDesc :: struct {
        /*
        \brief Controls the trade-off between mesh size and runtime performance.
        
        Using a value of 1.0 will produce a larger cooked mesh with generally higher runtime performance,
        using 0.0 will produce a smaller cooked mesh, with generally lower runtime performance.
        
        Values outside of [0,1] range will be clamped and cause a warning when any mesh gets cooked.
        
        <b>Default value:</b> 0.55
        <b>Range:</b> [0.0f, 1.0f]
        */
        meshSizePerformanceTradeOff: PxF32;

        /*
        \brief Mesh cooking hint. Used to specify mesh hierarchy construction preference.
        
        <b>Default value:</b> PxMeshCookingHint::eSIM_PERFORMANCE
        */
        meshCookingHint:             PxMeshCookingHint.Enum;

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxBVH33MidphaseDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxBVH33MidphaseDesc@physx@@QEBA_NXZ";
    }

    /*
    \brief Desired build strategy for PxMeshMidPhase::eBVH34
    */
    PxBVH34BuildStrategy :: struct {
        Enum :: enum s32 {
            FAST    :: 0;
            DEFAULT :: 1;
            SAH     :: 2;

            LAST    :: 3;

            eFAST    :: FAST;
            eDEFAULT :: DEFAULT;
            eSAH     :: SAH;

            eLAST    :: LAST;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    
    \brief Structure describing parameters affecting BVH34 midphase mesh structure.
    
    \see PxCookingParams, PxMidphaseDesc
    */
    PxBVH34MidphaseDesc :: struct {
        /*
        \brief Mesh cooking hint for max primitives per leaf limit.
        Less primitives per leaf produces larger meshes with better runtime performance
        and worse cooking performance. More triangles per leaf results in faster cooking speed and
        smaller mesh sizes, but with worse runtime performance.
        
        <b>Default value:</b> 4
        <b>Range:</b> <2, 15>
        */
        numPrimsPerLeaf: PxU32;

        /*
        \brief Desired build strategy for the BVH
        
        <b>Default value:</b> eDEFAULT
        */
        buildStrategy:   PxBVH34BuildStrategy.Enum;

        /*
        \brief Whether the tree should be quantized or not
        
        Quantized trees use up less memory, but the runtime dequantization (to retrieve the node bounds) might have
        a measurable performance cost. In most cases the cost is too small to matter, and using less memory is more
        important. Hence, the default is true.
        
        One important use case for non-quantized trees is deformable meshes. The refit function for the BVH is not
        supported for quantized trees.
        
        <b>Default value:</b> true
        */
        quantized:       bool;

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxBVH34MidphaseDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxBVH34MidphaseDesc@physx@@QEBA_NXZ";
    }

    /*
    
    \brief Structure describing parameters affecting midphase mesh structure.
    
    \see PxCookingParams, PxBVH33MidphaseDesc, PxBVH34MidphaseDesc
    */
    PxMidphaseDesc :: struct {
        /*
        \brief	Returns type of midphase mesh structure.
        \return	PxMeshMidPhase::Enum
        
        \see PxMeshMidPhase::Enum
        */
        getType :: (this: *PxMidphaseDesc) -> PxMeshMidPhase.Enum #cpp_method #foreign physxcommon_static "?getType@PxMidphaseDesc@physx@@QEBA?AW4Enum@PxMeshMidPhase@2@XZ";

        /*
        \brief	Midphase descriptors union
        
        \see PxBV33MidphaseDesc, PxBV34MidphaseDesc
        */
        union {
            mBVH33Desc: PxBVH33MidphaseDesc;
            mBVH34Desc: PxBVH34MidphaseDesc;
        }

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxMidphaseDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxMidphaseDesc@physx@@QEBA_NXZ";

        mType: PxMeshMidPhase.Enum;
    }

    /*
    \brief Descriptor class for #PxBVH.
    
    \see PxBVH
    */
    PxBVHDesc :: struct {
        /*
        \brief Pointer to first bounding box.
        */
        bounds:          PxBoundedData;

        /*
        \brief Bounds enlargement
        
        Passed bounds are slightly enlarged before creating the BVH. This is done to avoid numerical issues when
        e.g. raycasts just graze the bounds. The performed operation is:
        
        extents = (bounds.maximum - bounds.minimum)/2
        enlagedBounds.minimum = passedBounds.minium - extents * enlargement
        enlagedBounds.maximum = passedBounds.maxium + extents * enlargement
        
        Users can pass pre-enlarged bounds to the BVH builder, in which case just set the enlargement value to zero.
        
        <b>Default value:</b> 0.01
        */
        enlargement:     float;

        /*
        \brief Max primitives per leaf limit.
        
        <b>Range:</b> [0, 16)<br>
        <b>Default value:</b> 4
        */
        numPrimsPerLeaf: PxU32;

        /*
        \brief Desired build strategy for the BVH
        
        <b>Default value:</b> eDEFAULT
        */
        buildStrategy:   PxBVHBuildStrategy.Enum;

        /*
        \brief Returns true if the descriptor is valid.
        \return true if the current settings are valid.
        */
        isValid :: (this: *PxBVHDesc) -> bool #cpp_method #foreign physxcommon_static "?isValid@PxBVHDesc@physx@@QEBA_NXZ";
    }

    /*
    \brief Result from convex cooking.
    */
    PxConvexMeshCookingResult :: struct {
        Enum :: enum s32 {
            SUCCESS                :: 0;

            ZERO_AREA_TEST_FAILED  :: 1;

            POLYGONS_LIMIT_REACHED :: 2;

            FAILURE                :: 3;

            NON_GPU_COMPATIBLE     :: 4;

            eSUCCESS                :: SUCCESS;

            eZERO_AREA_TEST_FAILED  :: ZERO_AREA_TEST_FAILED;

            ePOLYGONS_LIMIT_REACHED :: POLYGONS_LIMIT_REACHED;

            eFAILURE                :: FAILURE;

            eNON_GPU_COMPATIBLE     :: NON_GPU_COMPATIBLE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /* \brief Enumeration for convex mesh cooking algorithms. */
    PxConvexMeshCookingType :: struct {
        Enum :: enum s32 {
            eQUICKHULL :: 0;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Result from triangle mesh cooking
    */
    PxTriangleMeshCookingResult :: struct {
        Enum :: enum s32 {
            SUCCESS        :: 0;

            LARGE_TRIANGLE :: 1;

            EMPTY_MESH     :: 2;

            FAILURE        :: 3;

            eSUCCESS        :: SUCCESS;

            eLARGE_TRIANGLE :: LARGE_TRIANGLE;

            eEMPTY_MESH     :: EMPTY_MESH;

            eFAILURE        :: FAILURE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Enum for the set of mesh pre-processing parameters.
    */
    PxMeshPreprocessingFlag :: struct {
        Enum :: enum s32 {
            WELD_VERTICES                   :: 1;

            DISABLE_CLEAN_MESH              :: 2;

            DISABLE_ACTIVE_EDGES_PRECOMPUTE :: 4;

            FORCE_32BIT_INDICES             :: 8;

            ENABLE_VERT_MAPPING             :: 16;

            ENABLE_INERTIA                  :: 32;

            eWELD_VERTICES                   :: WELD_VERTICES;

            eDISABLE_CLEAN_MESH              :: DISABLE_CLEAN_MESH;

            eDISABLE_ACTIVE_EDGES_PRECOMPUTE :: DISABLE_ACTIVE_EDGES_PRECOMPUTE;

            eFORCE_32BIT_INDICES             :: FORCE_32BIT_INDICES;

            eENABLE_VERT_MAPPING             :: ENABLE_VERT_MAPPING;

            eENABLE_INERTIA                  :: ENABLE_INERTIA;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxMeshPreprocessingFlags :: PxFlags(PxMeshPreprocessingFlag.Enum, PxU32);

    /*
    \brief Structure describing parameters affecting mesh cooking.
    
    \see PxSetCookingParams() PxGetCookingParams()
    */
    PxCookingParams :: struct {
        /*
        \brief Zero-size area epsilon used in convex hull computation.
        
        If the area of a triangle of the hull is below this value, the triangle will be rejected. This test
        is done only if PxConvexFlag::eCHECK_ZERO_AREA_TRIANGLES is used.
        
        \see PxConvexFlag::eCHECK_ZERO_AREA_TRIANGLES
        
        <b>Default value:</b> 0.06f*PxTolerancesScale.length*PxTolerancesScale.length
        
        <b>Range:</b> (0.0f, PX_MAX_F32)
        */
        areaTestEpsilon:                float;

        /*
        \brief Plane tolerance used in convex hull computation.
        
        The value is used during hull construction. When a new point is about to be added to the hull it
        gets dropped when the point is closer to the hull than the planeTolerance. The planeTolerance
        is increased according to the hull size.
        
        If 0.0f is set all points are accepted when the convex hull is created. This may lead to edge cases
        where the new points may be merged into an existing polygon and the polygons plane equation might
        slightly change therefore. This might lead to failures during polygon merging phase in the hull computation.
        
        It is recommended to use the default value, however if it is required that all points needs to be
        accepted or huge thin convexes are created, it might be required to lower the default value.
        
        \note The plane tolerance is used only within PxConvexMeshCookingType::eQUICKHULL algorithm.
        
        <b>Default value:</b> 0.0007f
        
        <b>Range:</b> <0.0f, PX_MAX_F32)
        */
        planeTolerance:                 float;

        /*
        \brief Convex hull creation algorithm.
        
        <b>Default value:</b> PxConvexMeshCookingType::eQUICKHULL
        
        \see PxConvexMeshCookingType
        */
        convexMeshCookingType:          PxConvexMeshCookingType.Enum;

        /*
        \brief When true, the face remap table is not created.  This saves a significant amount of memory, but the SDK will
        not be able to provide the remap information for internal mesh triangles returned by collisions,
        sweeps or raycasts hits.
        
        <b>Default value:</b> false
        */
        suppressTriangleMeshRemapTable: bool;

        /*
        \brief When true, the triangle adjacency information is created. You can get the adjacency triangles
        for a given triangle from getTriangle.
        
        <b>Default value:</b> false
        */
        buildTriangleAdjacencies:       bool;

        /*
        \brief When true, additional information required for GPU-accelerated rigid body simulation is created. This can increase memory usage and cooking times for convex meshes and triangle meshes.
        
        <b>Default value:</b> false
        */
        buildGPUData:                   bool;

        /*
        \brief Tolerance scale is used to check if cooked triangles are not too huge. This check will help with simulation stability.
        
        \note The PxTolerancesScale values have to match the values used when creating a PxPhysics or PxScene instance.
        
        \see PxTolerancesScale
        */
        scale:                          PxTolerancesScale;

        /*
        \brief Mesh pre-processing parameters. Used to control options like whether the mesh cooking performs vertex welding before cooking.
        
        <b>Default value:</b> 0
        */
        meshPreprocessParams:           PxMeshPreprocessingFlags;

        /*
        \brief Mesh weld tolerance. If mesh welding is enabled, this controls the distance at which vertices are welded.
        If mesh welding is not enabled, this value defines the acceptance distance for mesh validation. Provided no two vertices are within this distance, the mesh is considered to be
        clean. If not, a warning will be emitted. Having a clean, welded mesh is required to achieve the best possible performance.
        
        The default vertex welding uses a snap-to-grid approach. This approach effectively truncates each vertex to integer values using meshWeldTolerance.
        Once these snapped vertices are produced, all vertices that snap to a given vertex on the grid are remapped to reference a single vertex. Following this,
        all triangles' indices are remapped to reference this subset of clean vertices. It should be noted that	the vertices that we do not alter the
        position of the vertices; the snap-to-grid is only performed to identify nearby vertices.
        
        The mesh validation approach also uses the same snap-to-grid approach to identify nearby vertices. If more than one vertex snaps to a given grid coordinate,
        we ensure that the distance between the vertices is at least meshWeldTolerance. If this is not the case, a warning is emitted.
        
        <b>Default value:</b> 0.0
        */
        meshWeldTolerance:              PxReal;

        /*
        \brief "Zero-area" epsilon used in mesh cleaning.
        
        This is similar to areaTestEpsilon, but for the mesh cleaning operation.
        
        If the area of a triangle is below this value, the triangle will be removed. This is only done when mesh cleaning is enabled,
        i.e. when PxMeshPreprocessingFlag::eDISABLE_CLEAN_MESH is not set.
        
        Default value is 0.0f to be consistent with previous PhysX versions, which only removed triangles whose area
        was exactly zero.
        
        \see PxMeshPreprocessingFlag::eDISABLE_CLEAN_MESH
        
        <b>Default value:</b> 0.0f
        
        <b>Range:</b> (0.0f, PX_MAX_F32)
        */
        meshAreaMinLimit:               PxReal;

        /*
        \brief Maximum edge length.
        
        If an edge of a triangle is above this value, a warning is sent to the error stream. This is only a check,
        corresponding triangles are not removed.
        
        This is only done when mesh cleaning is enabled, i.e. when PxMeshPreprocessingFlag::eDISABLE_CLEAN_MESH is not set.
        
        Default value is 500.0f to be consistent with previous PhysX versions. This value is internally multiplied by
        PxTolerancesScale::length before being used. Use 0.0f to disable the checks.
        
        \see PxMeshPreprocessingFlag::eDISABLE_CLEAN_MESH
        
        <b>Default value:</b> 500.0f
        
        <b>Range:</b> (0.0f, PX_MAX_F32)
        */
        meshEdgeLengthMaxLimit:         PxReal;

        /*
        \brief Controls the desired midphase desc structure for triangle meshes.
        
        \see PxBVH33MidphaseDesc, PxBVH34MidphaseDesc, PxMidphaseDesc
        
        <b>Default value:</b> PxMeshMidPhase::eBVH34
        */
        midphaseDesc:                   PxMidphaseDesc;

        /*
        \brief Vertex limit beyond which additional acceleration structures are computed for each convex mesh. Increase that limit to reduce memory usage.
        Computing the extra structures all the time does not guarantee optimal performance. There is a per-platform break-even point below which the
        extra structures actually hurt performance.
        
        <b>Default value:</b> 32
        */
        gaussMapLimit:                  PxU32;

        /*
        \brief Maximum mass ratio allowed on vertices touched by a single tet. If a any tetrahedron exceeds the mass ratio, the masses will get smoothed locally
        until the maximum mass ratio is matched. Value should not be below 1. Smoothing might not fully converge for values <1.5. The smaller the maximum
        allowed ratio, the better the stability during simulation.
        
        <b>Default value:</b> FLT_MAX
        */
        maxWeightRatioInTet:            PxReal;
    }

    /*
    \brief default implementation of a memory write stream
    
    \see PxOutputStream
    */
    PxDefaultMemoryOutputStream :: struct {
        #as using pxoutputstream: PxOutputStream;

        mAllocator: *PxAllocatorCallback;
        mData:      *PxU8;
        mSize:      PxU32;
        mCapacity:  PxU32;
        #place pxoutputstream; pxdefaultmemoryoutputstream_vtable: *PxDefaultMemoryOutputStream_VTable;
    }
    PxDefaultMemoryOutputStream_VTable :: struct #type_info_none {
        using pxoutputstream: PxOutputStream_VTable;
        getSize: (this: *PxDefaultMemoryOutputStream) -> PxU32 #cpp_method;
        getData: (this: *PxDefaultMemoryOutputStream) -> *PxU8 #cpp_method;
    }

    PxDefaultMemoryOutputStream_getSize :: inline (this: *PxDefaultMemoryOutputStream) -> PxU32 { return this.pxdefaultmemoryoutputstream_vtable.getSize(this); }
    PxDefaultMemoryOutputStream_getData :: inline (this: *PxDefaultMemoryOutputStream) -> *PxU8 { return this.pxdefaultmemoryoutputstream_vtable.getData(this); }

    vtable :: (obj: *PxDefaultMemoryOutputStream) -> *PxDefaultMemoryOutputStream_VTable { return obj.pxdefaultmemoryoutputstream_vtable; }


    /*
    \brief default implementation of a memory read stream
    
    \see PxInputData
    */
    PxDefaultMemoryInputData :: struct {
        #as using pxinputdata: PxInputData;

        mSize: PxU32;
        mData: *PxU8;
        mPos:  PxU32;
    }

    /*
    \brief default implementation of a file write stream
    
    \see PxOutputStream
    */
    PxDefaultFileOutputStream :: struct {
        #as using pxoutputstream: PxOutputStream;

        mFile: PxFileHandle;
        #place pxoutputstream; pxdefaultfileoutputstream_vtable: *PxDefaultFileOutputStream_VTable;
    }
    PxDefaultFileOutputStream_VTable :: struct #type_info_none {
        using pxoutputstream: PxOutputStream_VTable;
        isValid: (this: *PxDefaultFileOutputStream) -> bool #cpp_method;
    }
    PxDefaultFileOutputStream_isValid :: inline (this: *PxDefaultFileOutputStream) -> bool { return this.pxdefaultfileoutputstream_vtable.isValid(this); }

    vtable :: (obj: *PxDefaultFileOutputStream) -> *PxDefaultFileOutputStream_VTable { return obj.pxdefaultfileoutputstream_vtable; }


    /*
    \brief default implementation of a file read stream
    
    \see PxInputData
    */
    PxDefaultFileInputData :: struct {
        #as using pxinputdata: PxInputData;

        mFile:   PxFileHandle;
        mLength: PxU32;
    }

    /*
    \brief default implementation of the allocator interface required by the SDK
    */
    PxDefaultAllocator :: struct {
        #as using pxallocatorcallback: PxAllocatorCallback;
    }

    /*
    \brief Unique identifiers for extensions classes which implement a constraint based on PxConstraint.
    
    \note Users which want to create their own custom constraint types should choose an ID larger or equal to eNEXT_FREE_ID
    and not eINVALID_ID.
    
    \see PxConstraint PxSimulationEventCallback.onConstraintBreak()
    */
    PxConstraintExtIDs :: struct {
        Enum :: enum s32 {
            JOINT                          :: 0;
            VEHICLE_SUSP_LIMIT_DEPRECATED  :: 1;
            VEHICLE_STICKY_TYRE_DEPRECATED :: 2;
            VEHICLE_JOINT                  :: 3;
            NEXT_FREE_ID                   :: 4;
            INVALID_ID                     :: 2147483647;

            eJOINT                          :: JOINT;
            eVEHICLE_SUSP_LIMIT_DEPRECATED  :: VEHICLE_SUSP_LIMIT_DEPRECATED;
            eVEHICLE_STICKY_TYRE_DEPRECATED :: VEHICLE_STICKY_TYRE_DEPRECATED;
            eVEHICLE_JOINT                  :: VEHICLE_JOINT;
            eNEXT_FREE_ID                   :: NEXT_FREE_ID;
            eINVALID_ID                     :: INVALID_ID;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief an enumeration of PhysX' built-in joint types
    
    \see PxJoint
    */
    PxJointConcreteType :: struct {
        Enum :: enum s32 {
            SPHERICAL       :: 256;
            REVOLUTE        :: 257;
            PRISMATIC       :: 258;
            FIXED           :: 259;
            DISTANCE        :: 260;
            D6              :: 261;
            CONTACT         :: 262;
            GEAR            :: 263;
            RACK_AND_PINION :: 264;
            Last            :: 265;

            eSPHERICAL       :: SPHERICAL;
            eREVOLUTE        :: REVOLUTE;
            ePRISMATIC       :: PRISMATIC;
            eFIXED           :: FIXED;
            eDISTANCE        :: DISTANCE;
            eD6              :: D6;
            eCONTACT         :: CONTACT;
            eGEAR            :: GEAR;
            eRACK_AND_PINION :: RACK_AND_PINION;
            eLast            :: Last;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief an enumeration for specifying one or other of the actors referenced by a joint
    
    \see PxJoint
    */
    PxJointActorIndex :: struct {
        Enum :: enum s32 {
            eACTOR0 :: 0;
            eACTOR1 :: 1;
            COUNT   :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief a base interface providing common functionality for PhysX joints
    */
    PxJoint :: struct {
        #as using pxbase: PxBase;

        userData: *void; //!< user can assign this to whatever, usually to create a 1:1 relationship with a user object.
        #place pxbase; pxjoint_vtable: *PxJoint_VTable;
    }
    PxJoint_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        setActors: (this: *PxJoint, actor0: *PxRigidActor, actor1: *PxRigidActor) -> void #cpp_method;

        getActors: (this: *PxJoint, actor0: **PxRigidActor, actor1: **PxRigidActor) -> void #cpp_method;

        setLocalPose: (this: *PxJoint, actor: PxJointActorIndex.Enum, localPose: *PxTransform) -> void #cpp_method;

        getLocalPose: (this: *PxJoint, actor: PxJointActorIndex.Enum) -> PxTransform #cpp_method;

        getRelativeTransform: (this: *PxJoint) -> PxTransform #cpp_method;

        getRelativeLinearVelocity: (this: *PxJoint) -> PxVec3 #cpp_method;

        getRelativeAngularVelocity: (this: *PxJoint) -> PxVec3 #cpp_method;

        setBreakForce: (this: *PxJoint, force: PxReal, torque: PxReal) -> void #cpp_method;

        getBreakForce: (this: *PxJoint, force: *PxReal, torque: *PxReal) -> void #cpp_method;

        setConstraintFlags: (this: *PxJoint, flags: PxConstraintFlags) -> void #cpp_method;

        setConstraintFlag: (this: *PxJoint, flag: PxConstraintFlag.Enum, value: bool) -> void #cpp_method;

        getConstraintFlags: (this: *PxJoint) -> PxConstraintFlags #cpp_method;

        setInvMassScale0: (this: *PxJoint, invMassScale: PxReal) -> void #cpp_method;

        getInvMassScale0: (this: *PxJoint) -> PxReal #cpp_method;

        setInvInertiaScale0: (this: *PxJoint, invInertiaScale: PxReal) -> void #cpp_method;

        getInvInertiaScale0: (this: *PxJoint) -> PxReal #cpp_method;

        setInvMassScale1: (this: *PxJoint, invMassScale: PxReal) -> void #cpp_method;

        getInvMassScale1: (this: *PxJoint) -> PxReal #cpp_method;

        setInvInertiaScale1: (this: *PxJoint, invInertiaScale: PxReal) -> void #cpp_method;

        getInvInertiaScale1: (this: *PxJoint) -> PxReal #cpp_method;

        getConstraint: (this: *PxJoint) -> *PxConstraint #cpp_method;

        setName: (this: *PxJoint, name: *u8) -> void #cpp_method;

        getName: (this: *PxJoint) -> *u8 #cpp_method;

        getScene: (this: *PxJoint) -> *PxScene #cpp_method;
    }

    PxJoint_setActors :: inline (this: *PxJoint, actor0: *PxRigidActor, actor1: *PxRigidActor) { this.pxjoint_vtable.setActors(this, actor0, actor1); }

    PxJoint_getActors :: inline (this: *PxJoint, actor0: **PxRigidActor, actor1: **PxRigidActor) { this.pxjoint_vtable.getActors(this, actor0, actor1); }

    PxJoint_setLocalPose :: inline (this: *PxJoint, actor: PxJointActorIndex.Enum, localPose: *PxTransform) { this.pxjoint_vtable.setLocalPose(this, actor, localPose); }

    PxJoint_getLocalPose :: inline (this: *PxJoint, actor: PxJointActorIndex.Enum) -> PxTransform { return this.pxjoint_vtable.getLocalPose(this, actor); }

    PxJoint_getRelativeTransform :: inline (this: *PxJoint) -> PxTransform { return this.pxjoint_vtable.getRelativeTransform(this); }

    PxJoint_getRelativeLinearVelocity :: inline (this: *PxJoint) -> PxVec3 { return this.pxjoint_vtable.getRelativeLinearVelocity(this); }

    PxJoint_getRelativeAngularVelocity :: inline (this: *PxJoint) -> PxVec3 { return this.pxjoint_vtable.getRelativeAngularVelocity(this); }

    PxJoint_setBreakForce :: inline (this: *PxJoint, force: PxReal, torque: PxReal) { this.pxjoint_vtable.setBreakForce(this, force, torque); }

    PxJoint_getBreakForce :: inline (this: *PxJoint, force: *PxReal, torque: *PxReal) { this.pxjoint_vtable.getBreakForce(this, force, torque); }

    PxJoint_setConstraintFlags :: inline (this: *PxJoint, flags: PxConstraintFlags) { this.pxjoint_vtable.setConstraintFlags(this, flags); }

    PxJoint_setConstraintFlag :: inline (this: *PxJoint, flag: PxConstraintFlag.Enum, value: bool) { this.pxjoint_vtable.setConstraintFlag(this, flag, value); }

    PxJoint_getConstraintFlags :: inline (this: *PxJoint) -> PxConstraintFlags { return this.pxjoint_vtable.getConstraintFlags(this); }

    PxJoint_setInvMassScale0 :: inline (this: *PxJoint, invMassScale: PxReal) { this.pxjoint_vtable.setInvMassScale0(this, invMassScale); }

    PxJoint_getInvMassScale0 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvMassScale0(this); }

    PxJoint_setInvInertiaScale0 :: inline (this: *PxJoint, invInertiaScale: PxReal) { this.pxjoint_vtable.setInvInertiaScale0(this, invInertiaScale); }

    PxJoint_getInvInertiaScale0 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvInertiaScale0(this); }

    PxJoint_setInvMassScale1 :: inline (this: *PxJoint, invMassScale: PxReal) { this.pxjoint_vtable.setInvMassScale1(this, invMassScale); }

    PxJoint_getInvMassScale1 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvMassScale1(this); }

    PxJoint_setInvInertiaScale1 :: inline (this: *PxJoint, invInertiaScale: PxReal) { this.pxjoint_vtable.setInvInertiaScale1(this, invInertiaScale); }

    PxJoint_getInvInertiaScale1 :: inline (this: *PxJoint) -> PxReal { return this.pxjoint_vtable.getInvInertiaScale1(this); }

    PxJoint_getConstraint :: inline (this: *PxJoint) -> *PxConstraint { return this.pxjoint_vtable.getConstraint(this); }

    PxJoint_setName :: inline (this: *PxJoint, name: *u8) { this.pxjoint_vtable.setName(this, name); }

    PxJoint_getName :: inline (this: *PxJoint) -> *u8 { return this.pxjoint_vtable.getName(this); }

    PxJoint_getScene :: inline (this: *PxJoint) -> *PxScene { return this.pxjoint_vtable.getScene(this); }

    vtable :: (obj: *PxJoint) -> *PxJoint_VTable { return obj.pxjoint_vtable; }


    PxSpring :: struct {
        stiffness: PxReal; //!< the spring strength of the drive: that is, the force proportional to the position error
        damping:   PxReal; //!< the damping strength of the drive: that is, the force proportional to the velocity error
    }

    /*
    \brief flags for configuring the drive of a PxDistanceJoint
    
    \see PxDistanceJoint
    */
    PxDistanceJointFlag :: struct {
        Enum :: enum s32 {
            MAX_DISTANCE_ENABLED :: 2;
            MIN_DISTANCE_ENABLED :: 4;
            SPRING_ENABLED       :: 8;

            eMAX_DISTANCE_ENABLED :: MAX_DISTANCE_ENABLED;
            eMIN_DISTANCE_ENABLED :: MIN_DISTANCE_ENABLED;
            eSPRING_ENABLED       :: SPRING_ENABLED;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxDistanceJointFlags :: PxFlags(PxDistanceJointFlag.Enum, PxU16);

    /*
    \brief a joint that maintains an upper or lower bound (or both) on the distance between two points on different objects
    
    \see PxDistanceJointCreate PxJoint
    */
    PxDistanceJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxdistancejoint_vtable: *PxDistanceJoint_VTable;
    }
    PxDistanceJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getDistance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setMinDistance: (this: *PxDistanceJoint, distance: PxReal) -> void #cpp_method;

        getMinDistance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setMaxDistance: (this: *PxDistanceJoint, distance: PxReal) -> void #cpp_method;

        getMaxDistance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setTolerance: (this: *PxDistanceJoint, tolerance: PxReal) -> void #cpp_method;

        getTolerance: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setStiffness: (this: *PxDistanceJoint, stiffness: PxReal) -> void #cpp_method;

        getStiffness: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setDamping: (this: *PxDistanceJoint, damping: PxReal) -> void #cpp_method;

        getDamping: (this: *PxDistanceJoint) -> PxReal #cpp_method;

        setDistanceJointFlags: (this: *PxDistanceJoint, flags: PxDistanceJointFlags) -> void #cpp_method;

        setDistanceJointFlag: (this: *PxDistanceJoint, flag: PxDistanceJointFlag.Enum, value: bool) -> void #cpp_method;

        getDistanceJointFlags: (this: *PxDistanceJoint) -> PxDistanceJointFlags #cpp_method;
    }

    PxDistanceJoint_getDistance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getDistance(this); }

    PxDistanceJoint_setMinDistance :: inline (this: *PxDistanceJoint, distance: PxReal) { this.pxdistancejoint_vtable.setMinDistance(this, distance); }

    PxDistanceJoint_getMinDistance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getMinDistance(this); }

    PxDistanceJoint_setMaxDistance :: inline (this: *PxDistanceJoint, distance: PxReal) { this.pxdistancejoint_vtable.setMaxDistance(this, distance); }

    PxDistanceJoint_getMaxDistance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getMaxDistance(this); }

    PxDistanceJoint_setTolerance :: inline (this: *PxDistanceJoint, tolerance: PxReal) { this.pxdistancejoint_vtable.setTolerance(this, tolerance); }

    PxDistanceJoint_getTolerance :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getTolerance(this); }

    PxDistanceJoint_setStiffness :: inline (this: *PxDistanceJoint, stiffness: PxReal) { this.pxdistancejoint_vtable.setStiffness(this, stiffness); }

    PxDistanceJoint_getStiffness :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getStiffness(this); }

    PxDistanceJoint_setDamping :: inline (this: *PxDistanceJoint, damping: PxReal) { this.pxdistancejoint_vtable.setDamping(this, damping); }

    PxDistanceJoint_getDamping :: inline (this: *PxDistanceJoint) -> PxReal { return this.pxdistancejoint_vtable.getDamping(this); }

    PxDistanceJoint_setDistanceJointFlags :: inline (this: *PxDistanceJoint, flags: PxDistanceJointFlags) { this.pxdistancejoint_vtable.setDistanceJointFlags(this, flags); }

    PxDistanceJoint_setDistanceJointFlag :: inline (this: *PxDistanceJoint, flag: PxDistanceJointFlag.Enum, value: bool) { this.pxdistancejoint_vtable.setDistanceJointFlag(this, flag, value); }

    PxDistanceJoint_getDistanceJointFlags :: inline (this: *PxDistanceJoint) -> PxDistanceJointFlags { return this.pxdistancejoint_vtable.getDistanceJointFlags(this); }

    vtable :: (obj: *PxDistanceJoint) -> *PxDistanceJoint_VTable { return obj.pxdistancejoint_vtable; }


    /*
    \deprecated Will be removed in a future version once a suitable replacement for loop-closure articulation inverse dynamics is made available.
    */
    PxJacobianRow :: struct {
        linear0:  PxVec3;
        linear1:  PxVec3;
        angular0: PxVec3;
        angular1: PxVec3;

        Constructor :: (this: *PxJacobianRow) -> void #cpp_method #foreign physx_static "??0PxJacobianRow@physx@@QEAA@XZ";
    }

    /*
    \deprecated Will be removed in a future version when a replacement for loop-closure articulation inverse dynamics is made available.
    
    \brief PxContactJoint is best viewed as a helper function for the inverse dynamics of articulations. The expected use case
    is to use PxContactJoint::getConstraint() in conjunction with PxArticulationReducedCoordinate::addLoopJoint().
    
    \see PxContactJointCreate PxArticulationReducedCoordinate::addLoopJoint
    */
    PxContactJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxcontactjoint_vtable: *PxContactJoint_VTable;
    }
    PxContactJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        setContact: (this: *PxContactJoint, contact: *PxVec3) -> void #cpp_method;

        setContactNormal: (this: *PxContactJoint, contactNormal: *PxVec3) -> void #cpp_method;

        setPenetration: (this: *PxContactJoint, penetration: PxReal) -> void #cpp_method;

        getContact: (this: *PxContactJoint) -> PxVec3 #cpp_method;

        getContactNormal: (this: *PxContactJoint) -> PxVec3 #cpp_method;

        getPenetration: (this: *PxContactJoint) -> PxReal #cpp_method;

        getRestitution: (this: *PxContactJoint) -> PxReal #cpp_method;
        setRestitution: (this: *PxContactJoint, restitution: PxReal) -> void #cpp_method;
        getBounceThreshold: (this: *PxContactJoint) -> PxReal #cpp_method;
        setBounceThreshold: (this: *PxContactJoint, bounceThreshold: PxReal) -> void #cpp_method;

        computeJacobians: (this: *PxContactJoint, jacobian: *PxJacobianRow) -> void #cpp_method;
        getNbJacobianRows: (this: *PxContactJoint) -> PxU32 #cpp_method;
    }

    PxContactJoint_setContact :: inline (this: *PxContactJoint, contact: *PxVec3) { this.pxcontactjoint_vtable.setContact(this, contact); }

    PxContactJoint_setContactNormal :: inline (this: *PxContactJoint, contactNormal: *PxVec3) { this.pxcontactjoint_vtable.setContactNormal(this, contactNormal); }

    PxContactJoint_setPenetration :: inline (this: *PxContactJoint, penetration: PxReal) { this.pxcontactjoint_vtable.setPenetration(this, penetration); }

    PxContactJoint_getContact :: inline (this: *PxContactJoint) -> PxVec3 { return this.pxcontactjoint_vtable.getContact(this); }

    PxContactJoint_getContactNormal :: inline (this: *PxContactJoint) -> PxVec3 { return this.pxcontactjoint_vtable.getContactNormal(this); }

    PxContactJoint_getPenetration :: inline (this: *PxContactJoint) -> PxReal { return this.pxcontactjoint_vtable.getPenetration(this); }

    PxContactJoint_getRestitution :: inline (this: *PxContactJoint) -> PxReal { return this.pxcontactjoint_vtable.getRestitution(this); }
    PxContactJoint_setRestitution :: inline (this: *PxContactJoint, restitution: PxReal) { this.pxcontactjoint_vtable.setRestitution(this, restitution); }
    PxContactJoint_getBounceThreshold :: inline (this: *PxContactJoint) -> PxReal { return this.pxcontactjoint_vtable.getBounceThreshold(this); }
    PxContactJoint_setBounceThreshold :: inline (this: *PxContactJoint, bounceThreshold: PxReal) { this.pxcontactjoint_vtable.setBounceThreshold(this, bounceThreshold); }

    PxContactJoint_computeJacobians :: inline (this: *PxContactJoint, jacobian: *PxJacobianRow) { this.pxcontactjoint_vtable.computeJacobians(this, jacobian); }
    PxContactJoint_getNbJacobianRows :: inline (this: *PxContactJoint) -> PxU32 { return this.pxcontactjoint_vtable.getNbJacobianRows(this); }

    vtable :: (obj: *PxContactJoint) -> *PxContactJoint_VTable { return obj.pxcontactjoint_vtable; }


    /*
    \brief A fixed joint permits no relative movement between two bodies. ie the bodies are glued together.
    
    \image html fixedJoint.png
    
    \see PxFixedJointCreate() PxJoint
    */
    PxFixedJoint :: struct {
        #as using pxjoint: PxJoint;
    }

    /*
    \brief Describes the parameters for a joint limit.
    
    Limits are enabled or disabled by setting flags or other configuration parameters joints, see the
    documentation for specific joint types for details.
    */
    PxJointLimitParameters :: struct {
        /*
        \brief Controls the amount of bounce when the joint hits a limit.
        
        A restitution value of 1.0 causes the joint to bounce back with the velocity which it hit the limit.
        A value of zero causes the joint to stop dead.
        
        In situations where the joint has many locked DOFs (e.g. 5) the restitution may not be applied
        correctly. This is due to a limitation in the solver which causes the restitution velocity to become zero
        as the solver enforces constraints on the other DOFs.
        
        This limitation applies to both angular and linear limits, however it is generally most apparent with limited
        angular DOFs. Disabling joint projection and increasing the solver iteration count may improve this behavior
        to some extent.
        
        Also, combining soft joint limits with joint drives driving against those limits may affect stability.
        
        <b>Range:</b> [0,1]<br>
        <b>Default:</b> 0.0
        */
        restitution:     PxReal;

        /*
        determines the minimum impact velocity which will cause the joint to bounce
        */
        bounceThreshold: PxReal;

        /*
        \brief if greater than zero, the limit is soft, i.e. a spring pulls the joint back to the limit
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.0
        */
        stiffness:       PxReal;

        /*
        \brief if spring is greater than zero, this is the damping of the limit spring
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        <b>Default:</b> 0.0
        */
        damping:         PxReal;
    }

    /*
    \brief Describes a one-sided linear limit.
    */
    PxJointLinearLimit :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /*
        \brief the extent of the limit.
        
        <b>Range:</b> (0, PX_MAX_F32) <br>
        <b>Default:</b> PX_MAX_F32
        */
        value: PxReal;
    }

    /*
    \brief Describes a two-sided limit.
    */
    PxJointLinearLimitPair :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /*
        \brief the range of the limit. The upper limit must be no lower than the
        lower limit, and if they are equal the limited degree of freedom will be treated as locked.
        
        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PX_MAX_F32/3, upper = PX_MAX_F32/3
        */
        upper: PxReal;
        /*
        \brief the range of the limit. The upper limit must be no lower than the
        lower limit, and if they are equal the limited degree of freedom will be treated as locked.
        
        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PX_MAX_F32/3, upper = PX_MAX_F32/3
        */
        lower: PxReal;
    }

    PxJointAngularLimitPair :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /*
        \brief the range of the limit. The upper limit must be no lower than the lower limit.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PI/2, upper = PI/2
        */
        upper: PxReal;
        /*
        \brief the range of the limit. The upper limit must be no lower than the lower limit.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> See the joint on which the limit is used for details<br>
        <b>Default:</b> lower = -PI/2, upper = PI/2
        */
        lower: PxReal;
    }

    /*
    \brief Describes an elliptical conical joint limit. Note that very small or highly elliptical limit cones may
    result in jitter.
    
    \see PxD6Joint PxSphericalJoint
    */
    PxJointLimitCone :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /*
        \brief the maximum angle from the Y axis of the constraint frame.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (0,PI)<br>
        <b>Default:</b> PI/2
        */
        yAngle: PxReal;

        /*
        \brief the maximum angle from the Z-axis of the constraint frame.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (0,PI)<br>
        <b>Default:</b> PI/2
        */
        zAngle: PxReal;
    }

    /*
    \brief Describes a pyramidal joint limit.
    
    \see PxD6Joint
    */
    PxJointLimitPyramid :: struct {
        #as using pxjointlimitparameters: PxJointLimitParameters;

        /*
        \brief the minimum angle from the Y axis of the constraint frame.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> -PI/2
        */
        yAngleMin: PxReal;

        /*
        \brief the maximum angle from the Y axis of the constraint frame.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> PI/2
        */
        yAngleMax: PxReal;

        /*
        \brief the minimum angle from the Z-axis of the constraint frame.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> -PI/2
        */
        zAngleMin: PxReal;

        /*
        \brief the maximum angle from the Z-axis of the constraint frame.
        
        <b>Unit:</b> Angular: Radians
        <b>Range:</b> Angular: (-PI,PI)<br>
        <b>Default:</b> PI/2
        */
        zAngleMax: PxReal;
    }

    /*
    \brief Flags specific to the prismatic joint.
    
    \see PxPrismaticJoint
    */
    PxPrismaticJointFlag :: struct {
        Enum :: enum s32 {
            eLIMIT_ENABLED :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxPrismaticJointFlags :: PxFlags(PxPrismaticJointFlag.Enum, PxU16);

    /*
    \brief A prismatic joint permits relative translational movement between two bodies along
    an axis, but no relative rotational movement.
    
    the axis on each body is defined as the line containing the origin of the joint frame and
    extending along the x-axis of that frame
    
    \image html prismJoint.png
    
    \see PxPrismaticJointCreate() PxJoint
    */
    PxPrismaticJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxprismaticjoint_vtable: *PxPrismaticJoint_VTable;
    }
    PxPrismaticJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getPosition: (this: *PxPrismaticJoint) -> PxReal #cpp_method;

        getVelocity: (this: *PxPrismaticJoint) -> PxReal #cpp_method;

        setLimit: (this: *PxPrismaticJoint, unknown0: *PxJointLinearLimitPair) -> void #cpp_method;

        getLimit: (this: *PxPrismaticJoint) -> PxJointLinearLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setPrismaticJointFlags: (this: *PxPrismaticJoint, flags: PxPrismaticJointFlags) -> void #cpp_method;

        setPrismaticJointFlag: (this: *PxPrismaticJoint, flag: PxPrismaticJointFlag.Enum, value: bool) -> void #cpp_method;

        getPrismaticJointFlags: (this: *PxPrismaticJoint) -> PxPrismaticJointFlags #cpp_method;
    }

    PxPrismaticJoint_getPosition :: inline (this: *PxPrismaticJoint) -> PxReal { return this.pxprismaticjoint_vtable.getPosition(this); }

    PxPrismaticJoint_getVelocity :: inline (this: *PxPrismaticJoint) -> PxReal { return this.pxprismaticjoint_vtable.getVelocity(this); }

    PxPrismaticJoint_setLimit :: inline (this: *PxPrismaticJoint, unknown0: *PxJointLinearLimitPair) { this.pxprismaticjoint_vtable.setLimit(this, unknown0); }

    PxPrismaticJoint_getLimit :: inline (this: *PxPrismaticJoint) -> PxJointLinearLimitPair { return this.pxprismaticjoint_vtable.getLimit(this); }

    PxPrismaticJoint_setPrismaticJointFlags :: inline (this: *PxPrismaticJoint, flags: PxPrismaticJointFlags) { this.pxprismaticjoint_vtable.setPrismaticJointFlags(this, flags); }

    PxPrismaticJoint_setPrismaticJointFlag :: inline (this: *PxPrismaticJoint, flag: PxPrismaticJointFlag.Enum, value: bool) { this.pxprismaticjoint_vtable.setPrismaticJointFlag(this, flag, value); }

    PxPrismaticJoint_getPrismaticJointFlags :: inline (this: *PxPrismaticJoint) -> PxPrismaticJointFlags { return this.pxprismaticjoint_vtable.getPrismaticJointFlags(this); }

    vtable :: (obj: *PxPrismaticJoint) -> *PxPrismaticJoint_VTable { return obj.pxprismaticjoint_vtable; }


    /*
    \brief Flags specific to the Revolute Joint.
    
    \see PxRevoluteJoint
    */
    PxRevoluteJointFlag :: struct {
        Enum :: enum s32 {
            LIMIT_ENABLED  :: 1;
            DRIVE_ENABLED  :: 2;
            DRIVE_FREESPIN :: 4;

            eLIMIT_ENABLED  :: LIMIT_ENABLED;
            eDRIVE_ENABLED  :: DRIVE_ENABLED;
            eDRIVE_FREESPIN :: DRIVE_FREESPIN;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxRevoluteJointFlags :: PxFlags(PxRevoluteJointFlag.Enum, PxU16);

    /*
    
    \brief A joint which behaves in a similar way to a hinge or axle.
    
    A hinge joint removes all but a single rotational degree of freedom from two objects.
    The axis along which the two bodies may rotate is specified with a point and a direction
    vector.
    
    The position of the hinge on each body is specified by the origin of the body's joint frame.
    The axis of the hinge is specified as the direction of the x-axis in the body's joint frame.
    
    \image html revoluteJoint.png
    
    A revolute joint can be given a motor, so that it can apply a force to rotate the attached actors.
    It may also be given a limit, to restrict the revolute motion to within a certain range. In
    addition, the bodies may be projected together if the distance or angle between them exceeds
    a given threshold.
    
    Projection, drive and limits are activated by setting the appropriate flags on the joint.
    
    \see PxRevoluteJointCreate() PxJoint
    */
    PxRevoluteJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxrevolutejoint_vtable: *PxRevoluteJoint_VTable;
    }
    PxRevoluteJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getAngle: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        getVelocity: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setLimit: (this: *PxRevoluteJoint, limits: *PxJointAngularLimitPair) -> void #cpp_method;

        getLimit: (this: *PxRevoluteJoint) -> PxJointAngularLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setDriveVelocity: (this: *PxRevoluteJoint, velocity: PxReal, autowake := true) -> void #cpp_method;

        getDriveVelocity: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setDriveForceLimit: (this: *PxRevoluteJoint, limit: PxReal) -> void #cpp_method;

        getDriveForceLimit: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setDriveGearRatio: (this: *PxRevoluteJoint, ratio: PxReal) -> void #cpp_method;

        getDriveGearRatio: (this: *PxRevoluteJoint) -> PxReal #cpp_method;

        setRevoluteJointFlags: (this: *PxRevoluteJoint, flags: PxRevoluteJointFlags) -> void #cpp_method;

        setRevoluteJointFlag: (this: *PxRevoluteJoint, flag: PxRevoluteJointFlag.Enum, value: bool) -> void #cpp_method;

        getRevoluteJointFlags: (this: *PxRevoluteJoint) -> PxRevoluteJointFlags #cpp_method;
    }

    PxRevoluteJoint_getAngle :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getAngle(this); }

    PxRevoluteJoint_getVelocity :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getVelocity(this); }

    PxRevoluteJoint_setLimit :: inline (this: *PxRevoluteJoint, limits: *PxJointAngularLimitPair) { this.pxrevolutejoint_vtable.setLimit(this, limits); }

    PxRevoluteJoint_getLimit :: inline (this: *PxRevoluteJoint) -> PxJointAngularLimitPair { return this.pxrevolutejoint_vtable.getLimit(this); }

    PxRevoluteJoint_setDriveVelocity :: inline (this: *PxRevoluteJoint, velocity: PxReal, autowake := true) { this.pxrevolutejoint_vtable.setDriveVelocity(this, velocity, autowake); }

    PxRevoluteJoint_getDriveVelocity :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getDriveVelocity(this); }

    PxRevoluteJoint_setDriveForceLimit :: inline (this: *PxRevoluteJoint, limit: PxReal) { this.pxrevolutejoint_vtable.setDriveForceLimit(this, limit); }

    PxRevoluteJoint_getDriveForceLimit :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getDriveForceLimit(this); }

    PxRevoluteJoint_setDriveGearRatio :: inline (this: *PxRevoluteJoint, ratio: PxReal) { this.pxrevolutejoint_vtable.setDriveGearRatio(this, ratio); }

    PxRevoluteJoint_getDriveGearRatio :: inline (this: *PxRevoluteJoint) -> PxReal { return this.pxrevolutejoint_vtable.getDriveGearRatio(this); }

    PxRevoluteJoint_setRevoluteJointFlags :: inline (this: *PxRevoluteJoint, flags: PxRevoluteJointFlags) { this.pxrevolutejoint_vtable.setRevoluteJointFlags(this, flags); }

    PxRevoluteJoint_setRevoluteJointFlag :: inline (this: *PxRevoluteJoint, flag: PxRevoluteJointFlag.Enum, value: bool) { this.pxrevolutejoint_vtable.setRevoluteJointFlag(this, flag, value); }

    PxRevoluteJoint_getRevoluteJointFlags :: inline (this: *PxRevoluteJoint) -> PxRevoluteJointFlags { return this.pxrevolutejoint_vtable.getRevoluteJointFlags(this); }

    vtable :: (obj: *PxRevoluteJoint) -> *PxRevoluteJoint_VTable { return obj.pxrevolutejoint_vtable; }


    /*
    \brief Flags specific to the spherical joint.
    
    \see PxSphericalJoint
    */
    PxSphericalJointFlag :: struct {
        Enum :: enum s32 {
            eLIMIT_ENABLED :: 2;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxSphericalJointFlags :: PxFlags(PxSphericalJointFlag.Enum, PxU16);

    /*
    \brief A joint which behaves in a similar way to a ball and socket.
    
    A spherical joint removes all linear degrees of freedom from two objects.
    
    The position of the joint on each actor is specified by the origin of the body's joint frame.
    
    A spherical joint may have a cone limit, to restrict the motion to within a certain range. In
    addition, the bodies may be projected together if the distance between them exceeds a given threshold.
    
    Projection, drive and limits are activated by setting the appropriate flags on the joint.
    
    \see PxRevoluteJointCreate() PxJoint
    */
    PxSphericalJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxsphericaljoint_vtable: *PxSphericalJoint_VTable;
    }
    PxSphericalJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        getLimitCone: (this: *PxSphericalJoint) -> PxJointLimitCone #cpp_method #cpp_return_type_is_non_pod;

        setLimitCone: (this: *PxSphericalJoint, limit: *PxJointLimitCone) -> void #cpp_method;

        getSwingYAngle: (this: *PxSphericalJoint) -> PxReal #cpp_method;

        getSwingZAngle: (this: *PxSphericalJoint) -> PxReal #cpp_method;

        setSphericalJointFlags: (this: *PxSphericalJoint, flags: PxSphericalJointFlags) -> void #cpp_method;

        setSphericalJointFlag: (this: *PxSphericalJoint, flag: PxSphericalJointFlag.Enum, value: bool) -> void #cpp_method;

        getSphericalJointFlags: (this: *PxSphericalJoint) -> PxSphericalJointFlags #cpp_method;
    }

    PxSphericalJoint_getLimitCone :: inline (this: *PxSphericalJoint) -> PxJointLimitCone { return this.pxsphericaljoint_vtable.getLimitCone(this); }

    PxSphericalJoint_setLimitCone :: inline (this: *PxSphericalJoint, limit: *PxJointLimitCone) { this.pxsphericaljoint_vtable.setLimitCone(this, limit); }

    PxSphericalJoint_getSwingYAngle :: inline (this: *PxSphericalJoint) -> PxReal { return this.pxsphericaljoint_vtable.getSwingYAngle(this); }

    PxSphericalJoint_getSwingZAngle :: inline (this: *PxSphericalJoint) -> PxReal { return this.pxsphericaljoint_vtable.getSwingZAngle(this); }

    PxSphericalJoint_setSphericalJointFlags :: inline (this: *PxSphericalJoint, flags: PxSphericalJointFlags) { this.pxsphericaljoint_vtable.setSphericalJointFlags(this, flags); }

    PxSphericalJoint_setSphericalJointFlag :: inline (this: *PxSphericalJoint, flag: PxSphericalJointFlag.Enum, value: bool) { this.pxsphericaljoint_vtable.setSphericalJointFlag(this, flag, value); }

    PxSphericalJoint_getSphericalJointFlags :: inline (this: *PxSphericalJoint) -> PxSphericalJointFlags { return this.pxsphericaljoint_vtable.getSphericalJointFlags(this); }

    vtable :: (obj: *PxSphericalJoint) -> *PxSphericalJoint_VTable { return obj.pxsphericaljoint_vtable; }


    /*
    \brief Used to specify one of the degrees of freedom of  a D6 joint.
    
    \see PxD6Joint
    */
    PxD6Axis :: struct {
        Enum :: enum s32 {
            X      :: 0;
            Y      :: 1;
            Z      :: 2;
            TWIST  :: 3;
            SWING1 :: 4;
            SWING2 :: 5;
            COUNT  :: 6;

            eX      :: X;
            eY      :: Y;
            eZ      :: Z;
            eTWIST  :: TWIST;
            eSWING1 :: SWING1;
            eSWING2 :: SWING2;
            eCOUNT  :: COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Used to specify the range of motions allowed for a degree of freedom in a D6 joint.
    
    \see PxD6Joint
    */
    PxD6Motion :: struct {
        Enum :: enum s32 {
            LOCKED  :: 0;
            LIMITED :: 1;
            FREE    :: 2;

            eLOCKED  :: LOCKED;
            eLIMITED :: LIMITED;
            eFREE    :: FREE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Used to specify which axes of a D6 joint are driven.
    
    Each drive is an implicit force-limited damped spring:
    
    force = spring * (target position - position) + damping * (targetVelocity - velocity)
    
    Alternatively, the spring may be configured to generate a specified acceleration instead of a force.
    
    A linear axis is affected by drive only if the corresponding drive flag is set. There are two possible models
    for angular drive: swing/twist, which may be used to drive one or more angular degrees of freedom, or slerp,
    which may only be used to drive all three angular degrees simultaneously.
    
    \see PxD6Joint
    */
    PxD6Drive :: struct {
        Enum :: enum s32 {
            X     :: 0;
            Y     :: 1;
            Z     :: 2;
            SWING :: 3;
            TWIST :: 4;
            SLERP :: 5;
            COUNT :: 6;

            eX     :: X;
            eY     :: Y;
            eZ     :: Z;
            eSWING :: SWING;
            eTWIST :: TWIST;
            eSLERP :: SLERP;
            eCOUNT :: COUNT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief flags for configuring the drive model of a PxD6Joint
    
    \see PxD6JointDrive PxD6Joint
    */
    PxD6JointDriveFlag :: struct {
        Enum :: enum s32 {
            eACCELERATION :: 1;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxD6JointDriveFlags :: PxFlags(PxD6JointDriveFlag.Enum, PxU32);

    /*
    \brief parameters for configuring the drive model of a PxD6Joint
    
    \see PxD6Joint
    */
    PxD6JointDrive :: struct {
        #as using pxspring: PxSpring;

        forceLimit: PxReal; //!< the force limit of the drive - may be an impulse or a force depending on PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES
        flags:      PxD6JointDriveFlags; //!< the joint drive flags 
    }

    /*
    \brief A D6 joint is a general constraint between two actors.
    
    It allows the application to individually define the linear and rotational degrees of freedom,
    and also to configure a variety of limits and driven degrees of freedom.
    
    By default all degrees of freedom are locked. So to create a prismatic joint with free motion
    along the x-axis:
    
    \code
    ...
    joint->setMotion(PxD6Axis::eX, PxD6JointMotion::eFREE);
    ...
    \endcode
    
    Or a Revolute joint with motion free allowed around the x-axis:
    
    \code
    ...
    joint->setMotion(PxD6Axis::eTWIST, PxD6JointMotion::eFREE);
    ...
    \endcode
    
    Degrees of freedom may also be set to limited instead of locked.
    
    There are two different kinds of linear limits available. The first kind is a single limit value
    for all linear degrees of freedom, which may act as a linear, circular, or spherical limit depending
    on which degrees of freedom are limited. This is similar to a distance limit. Then, the second kind
    supports a pair of limit values for each linear axis, which can be used to implement a traditional
    prismatic joint for example.
    
    If the twist degree of freedom is limited, is supports upper and lower limits. The two swing degrees
    of freedom are limited with a cone limit.
    \see PxD6JointCreate() PxJoint
    */
    PxD6Joint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxd6joint_vtable: *PxD6Joint_VTable;
    }
    PxD6Joint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        setMotion: (this: *PxD6Joint, axis: PxD6Axis.Enum, type: PxD6Motion.Enum) -> void #cpp_method;

        getMotion: (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxD6Motion.Enum #cpp_method;

        getTwistAngle: (this: *PxD6Joint) -> PxReal #cpp_method;

        getSwingYAngle: (this: *PxD6Joint) -> PxReal #cpp_method;

        getSwingZAngle: (this: *PxD6Joint) -> PxReal #cpp_method;

        setDistanceLimit: (this: *PxD6Joint, limit: *PxJointLinearLimit) -> void #cpp_method;

        getDistanceLimit: (this: *PxD6Joint) -> PxJointLinearLimit #cpp_method #cpp_return_type_is_non_pod;

        setLinearLimit: (this: *PxD6Joint, axis: PxD6Axis.Enum, limit: *PxJointLinearLimitPair) -> void #cpp_method;

        getLinearLimit: (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxJointLinearLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setTwistLimit: (this: *PxD6Joint, limit: *PxJointAngularLimitPair) -> void #cpp_method;

        getTwistLimit: (this: *PxD6Joint) -> PxJointAngularLimitPair #cpp_method #cpp_return_type_is_non_pod;

        setSwingLimit: (this: *PxD6Joint, limit: *PxJointLimitCone) -> void #cpp_method;

        getSwingLimit: (this: *PxD6Joint) -> PxJointLimitCone #cpp_method #cpp_return_type_is_non_pod;

        setPyramidSwingLimit: (this: *PxD6Joint, limit: *PxJointLimitPyramid) -> void #cpp_method;

        getPyramidSwingLimit: (this: *PxD6Joint) -> PxJointLimitPyramid #cpp_method #cpp_return_type_is_non_pod;

        setDrive: (this: *PxD6Joint, index: PxD6Drive.Enum, drive: *PxD6JointDrive) -> void #cpp_method;

        getDrive: (this: *PxD6Joint, index: PxD6Drive.Enum) -> PxD6JointDrive #cpp_method #cpp_return_type_is_non_pod;

        setDrivePosition: (this: *PxD6Joint, pose: *PxTransform, autowake := true) -> void #cpp_method;

        getDrivePosition: (this: *PxD6Joint) -> PxTransform #cpp_method;

        setDriveVelocity: (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3, autowake := true) -> void #cpp_method;

        getDriveVelocity: (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3) -> void #cpp_method;
    }

    PxD6Joint_setMotion :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum, type: PxD6Motion.Enum) { this.pxd6joint_vtable.setMotion(this, axis, type); }

    PxD6Joint_getMotion :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxD6Motion.Enum { return this.pxd6joint_vtable.getMotion(this, axis); }

    PxD6Joint_getTwistAngle :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getTwistAngle(this); }

    PxD6Joint_getSwingYAngle :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getSwingYAngle(this); }

    PxD6Joint_getSwingZAngle :: inline (this: *PxD6Joint) -> PxReal { return this.pxd6joint_vtable.getSwingZAngle(this); }

    PxD6Joint_setDistanceLimit :: inline (this: *PxD6Joint, limit: *PxJointLinearLimit) { this.pxd6joint_vtable.setDistanceLimit(this, limit); }

    PxD6Joint_getDistanceLimit :: inline (this: *PxD6Joint) -> PxJointLinearLimit { return this.pxd6joint_vtable.getDistanceLimit(this); }

    PxD6Joint_setLinearLimit :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum, limit: *PxJointLinearLimitPair) { this.pxd6joint_vtable.setLinearLimit(this, axis, limit); }

    PxD6Joint_getLinearLimit :: inline (this: *PxD6Joint, axis: PxD6Axis.Enum) -> PxJointLinearLimitPair { return this.pxd6joint_vtable.getLinearLimit(this, axis); }

    PxD6Joint_setTwistLimit :: inline (this: *PxD6Joint, limit: *PxJointAngularLimitPair) { this.pxd6joint_vtable.setTwistLimit(this, limit); }

    PxD6Joint_getTwistLimit :: inline (this: *PxD6Joint) -> PxJointAngularLimitPair { return this.pxd6joint_vtable.getTwistLimit(this); }

    PxD6Joint_setSwingLimit :: inline (this: *PxD6Joint, limit: *PxJointLimitCone) { this.pxd6joint_vtable.setSwingLimit(this, limit); }

    PxD6Joint_getSwingLimit :: inline (this: *PxD6Joint) -> PxJointLimitCone { return this.pxd6joint_vtable.getSwingLimit(this); }

    PxD6Joint_setPyramidSwingLimit :: inline (this: *PxD6Joint, limit: *PxJointLimitPyramid) { this.pxd6joint_vtable.setPyramidSwingLimit(this, limit); }

    PxD6Joint_getPyramidSwingLimit :: inline (this: *PxD6Joint) -> PxJointLimitPyramid { return this.pxd6joint_vtable.getPyramidSwingLimit(this); }

    PxD6Joint_setDrive :: inline (this: *PxD6Joint, index: PxD6Drive.Enum, drive: *PxD6JointDrive) { this.pxd6joint_vtable.setDrive(this, index, drive); }

    PxD6Joint_getDrive :: inline (this: *PxD6Joint, index: PxD6Drive.Enum) -> PxD6JointDrive { return this.pxd6joint_vtable.getDrive(this, index); }

    PxD6Joint_setDrivePosition :: inline (this: *PxD6Joint, pose: *PxTransform, autowake := true) { this.pxd6joint_vtable.setDrivePosition(this, pose, autowake); }

    PxD6Joint_getDrivePosition :: inline (this: *PxD6Joint) -> PxTransform { return this.pxd6joint_vtable.getDrivePosition(this); }

    PxD6Joint_setDriveVelocity :: inline (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3, autowake := true) { this.pxd6joint_vtable.setDriveVelocity(this, linear, angular, autowake); }

    PxD6Joint_getDriveVelocity :: inline (this: *PxD6Joint, linear: *PxVec3, angular: *PxVec3) { this.pxd6joint_vtable.getDriveVelocity(this, linear, angular); }

    vtable :: (obj: *PxD6Joint) -> *PxD6Joint_VTable { return obj.pxd6joint_vtable; }


    /*
    \brief A joint that connects two existing revolute joints and constrains their relative angular velocity and position with respect to each other.
    
    \see PxGearJointCreate PxJoint
    */
    PxGearJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxgearjoint_vtable: *PxGearJoint_VTable;
    }
    PxGearJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        setHinges: (this: *PxGearJoint, hinge0: *PxBase, hinge1: *PxBase) -> bool #cpp_method;

        getHinges: (this: *PxGearJoint, hinge0: **PxBase, hinge1: **PxBase) -> void #cpp_method;

        setGearRatio: (this: *PxGearJoint, ratio: float) -> void #cpp_method;

        getGearRatio: (this: *PxGearJoint) -> float #cpp_method;
    }

    PxGearJoint_setHinges :: inline (this: *PxGearJoint, hinge0: *PxBase, hinge1: *PxBase) -> bool { return this.pxgearjoint_vtable.setHinges(this, hinge0, hinge1); }

    PxGearJoint_getHinges :: inline (this: *PxGearJoint, hinge0: **PxBase, hinge1: **PxBase) { this.pxgearjoint_vtable.getHinges(this, hinge0, hinge1); }

    PxGearJoint_setGearRatio :: inline (this: *PxGearJoint, ratio: float) { this.pxgearjoint_vtable.setGearRatio(this, ratio); }

    PxGearJoint_getGearRatio :: inline (this: *PxGearJoint) -> float { return this.pxgearjoint_vtable.getGearRatio(this); }

    vtable :: (obj: *PxGearJoint) -> *PxGearJoint_VTable { return obj.pxgearjoint_vtable; }


    /*
    \brief A joint that connects an existing revolute joint to an existing prismatic joint,
    and constrains their relative angular/linear velocity and position with respect to each other.
    
    \see PxRackAndPinionJointCreate PxJoint
    */
    PxRackAndPinionJoint :: struct {
        #as using pxjoint: PxJoint;
        #place pxjoint; pxrackandpinionjoint_vtable: *PxRackAndPinionJoint_VTable;
    }
    PxRackAndPinionJoint_VTable :: struct #type_info_none {
        using pxjoint: PxJoint_VTable;
        setJoints: (this: *PxRackAndPinionJoint, hinge: *PxBase, prismatic: *PxBase) -> bool #cpp_method;

        getJoints: (this: *PxRackAndPinionJoint, hinge: **PxBase, prismatic: **PxBase) -> void #cpp_method;

        setRatio: (this: *PxRackAndPinionJoint, ratio: float) -> void #cpp_method;

        getRatio: (this: *PxRackAndPinionJoint) -> float #cpp_method;

        setData: (this: *PxRackAndPinionJoint, nbRackTeeth: PxU32, nbPinionTeeth: PxU32, rackLength: float) -> bool #cpp_method;
    }

    PxRackAndPinionJoint_setJoints :: inline (this: *PxRackAndPinionJoint, hinge: *PxBase, prismatic: *PxBase) -> bool { return this.pxrackandpinionjoint_vtable.setJoints(this, hinge, prismatic); }

    PxRackAndPinionJoint_getJoints :: inline (this: *PxRackAndPinionJoint, hinge: **PxBase, prismatic: **PxBase) { this.pxrackandpinionjoint_vtable.getJoints(this, hinge, prismatic); }

    PxRackAndPinionJoint_setRatio :: inline (this: *PxRackAndPinionJoint, ratio: float) { this.pxrackandpinionjoint_vtable.setRatio(this, ratio); }

    PxRackAndPinionJoint_getRatio :: inline (this: *PxRackAndPinionJoint) -> float { return this.pxrackandpinionjoint_vtable.getRatio(this); }

    PxRackAndPinionJoint_setData :: inline (this: *PxRackAndPinionJoint, nbRackTeeth: PxU32, nbPinionTeeth: PxU32, rackLength: float) -> bool { return this.pxrackandpinionjoint_vtable.setData(this, nbRackTeeth, nbPinionTeeth, rackLength); }

    vtable :: (obj: *PxRackAndPinionJoint) -> *PxRackAndPinionJoint_VTable { return obj.pxrackandpinionjoint_vtable; }


    /*
    \brief 64-bit mask used for collision filtering.
    
    The collision filtering equation for 2 objects o0 and o1 is:
    
    <pre> (G0 op0 K0) op2 (G1 op1 K1) == b </pre>
    
    with
    
    <ul>
    <li> G0 = PxGroupsMask for object o0. See PxSetGroupsMask </li>
    <li> G1 = PxGroupsMask for object o1. See PxSetGroupsMask </li>
    <li> K0 = filtering constant 0. See PxSetFilterConstants </li>
    <li> K1 = filtering constant 1. See PxSetFilterConstants </li>
    <li> b = filtering boolean. See PxSetFilterBool </li>
    <li> op0, op1, op2 = filtering operations. See PxSetFilterOps </li>
    </ul>
    
    If the filtering equation is true, collision detection is enabled.
    
    \see PxSetFilterOps()
    */
    PxGroupsMask :: struct {
        bits0: PxU16;
        bits1: PxU16;
        bits2: PxU16;
        bits3: PxU16;
    }

    /*
    \brief Collision filtering operations.
    
    \see PxGroupsMask
    */
    PxFilterOp :: struct {
        Enum :: enum s32 {
            AND      :: 0;
            OR       :: 1;
            XOR      :: 2;
            NAND     :: 3;
            NOR      :: 4;
            NXOR     :: 5;
            SWAP_AND :: 6;

            PX_FILTEROP_AND      :: AND;
            PX_FILTEROP_OR       :: OR;
            PX_FILTEROP_XOR      :: XOR;
            PX_FILTEROP_NAND     :: NAND;
            PX_FILTEROP_NOR      :: NOR;
            PX_FILTEROP_NXOR     :: NXOR;
            PX_FILTEROP_SWAP_AND :: SWAP_AND;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief default implementation of the error callback
    
    This class is provided in order to enable the SDK to be started with the minimum of user code. Typically an application
    will use its own error callback, and log the error to file or otherwise make it visible. Warnings and error messages from
    the SDK are usually indicative that changes are required in order for PhysX to function correctly, and should not be ignored.
    */
    PxDefaultErrorCallback :: struct {
        #as using pxerrorcallback: PxErrorCallback;
    }

    /*
    \brief utility functions for use with PxRigidActor and subclasses
    
    \see PxRigidActor PxRigidStatic PxRigidBody PxRigidDynamic PxArticulationLink
    */
    PxRigidActorExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Utility class to compute and manipulate mass and inertia tensor properties.
    
    In most cases #PxRigidBodyExt::updateMassAndInertia(), #PxRigidBodyExt::setMassAndUpdateInertia() should be enough to
    setup the mass properties of a rigid body. This utility class targets users that need to customize the mass properties
    computation.
    */
    PxMassProperties :: struct {
        inertiaTensor: PxMat33; //!< The inertia tensor of the object.
        centerOfMass:  PxVec3; //!< The center of mass of the object.
        mass:          PxReal; //!< The mass of the object.
    }

    /*
    \brief utility functions for use with PxRigidBody and subclasses
    
    \see PxRigidBody PxRigidDynamic PxArticulationLink
    */
    PxRigidBodyExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief utility functions for use with PxShape
    
    \see PxShape
    */
    PxShapeExt :: struct {
        /*
        \brief Retrieves the world space pose of the shape.
        
        \param[in] shape The shape for which to get the global pose.
        \param[in] actor The actor to which the shape is attached
        
        \return Global pose of shape.
        */
        getGlobalPose :: (shape: *PxShape, actor: *PxRigidActor) -> PxTransform #foreign physxcharacterkinematic_static "?getGlobalPose@PxShapeExt@physx@@SA?AV?$PxTransformT@M@2@AEBVPxShape@2@AEBVPxRigidActor@2@@Z";
        getGlobalPose :: (shape: PxShape, actor: PxRigidActor) -> PxTransform #no_context {
            return getGlobalPose(*shape, *actor);
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Utility class to find mesh triangles touched by a specified geometry object.
    
    This class is a helper calling PxMeshQuery::findOverlapTriangleMesh or PxMeshQuery::findOverlapHeightField under the hood,
    while taking care of necessary memory management issues.
    
    PxMeshQuery::findOverlapTriangleMesh and PxMeshQuery::findOverlapHeightField are the "raw" functions operating on user-provided fixed-size
    buffers. These functions abort with an error code in case of buffer overflow. PxMeshOverlapUtil is a convenient helper function checking
    this error code, and resizing buffers appropriately, until the desired call succeeds.
    
    Returned triangle indices are stored within the class, and can be used with PxMeshQuery::getTriangle() to retrieve the triangle properties.
    */
    PxMeshOverlapUtil :: struct {
        /*
        \brief Retrieves array of triangle indices after a findOverlap call.
        \return Indices of touched triangles
        */
        getResults :: (this: *PxMeshOverlapUtil) -> *PxU32 #cpp_method #foreign physxcharacterkinematic_static "?getResults@PxMeshOverlapUtil@physx@@QEBAPEBIXZ";

        mResultsMemory: *PxU32;
        mResults:       [256] PxU32;
        mNbResults:     PxU32;
        mMaxNbResults:  PxU32;
    }

    /*
    \brief Utility functions for serialization
    
    \see PxCollection, PxSerializationRegistry
    */
    PxSerialization :: struct {
        /*
        \brief Additional PxScene and PxPhysics options stored in XML serialized data.
        
        \deprecated Xml serialization is deprecated. An alternative serialization system is provided through USD Physics.
        
        The PxXmlMiscParameter parameter can be serialized and deserialized along with PxCollection instances (XML only).
        This is for application use only and has no impact on how objects are serialized or deserialized.
        
        \see PxSerialization::createCollectionFromXml, PxSerialization::serializeCollectionToXml
        */
        PxXmlMiscParameter :: struct {
            /*
            \brief Up vector for the scene reference coordinate system.
            */
            upVector: PxVec3;

            /*
            \brief Tolerances scale to be used for the scene.
            */
            scale:    PxTolerancesScale;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief A default implementation for a CPU task dispatcher.
    
    \see PxDefaultCpuDispatcherCreate() PxCpuDispatcher
    */
    PxDefaultCpuDispatcher :: struct {
        #as using pxcpudispatcher: PxCpuDispatcher;
        #place pxcpudispatcher; pxdefaultcpudispatcher_vtable: *PxDefaultCpuDispatcher_VTable;
    }
    PxDefaultCpuDispatcher_VTable :: struct #type_info_none {
        using pxcpudispatcher: PxCpuDispatcher_VTable;
        release: (this: *PxDefaultCpuDispatcher) -> void #cpp_method;

        setRunProfiled: (this: *PxDefaultCpuDispatcher, runProfiled: bool) -> void #cpp_method;

        getRunProfiled: (this: *PxDefaultCpuDispatcher) -> bool #cpp_method;
    }

    PxDefaultCpuDispatcher_release :: inline (this: *PxDefaultCpuDispatcher) { this.pxdefaultcpudispatcher_vtable.release(this); }

    PxDefaultCpuDispatcher_setRunProfiled :: inline (this: *PxDefaultCpuDispatcher, runProfiled: bool) { this.pxdefaultcpudispatcher_vtable.setRunProfiled(this, runProfiled); }

    PxDefaultCpuDispatcher_getRunProfiled :: inline (this: *PxDefaultCpuDispatcher) -> bool { return this.pxdefaultcpudispatcher_vtable.getRunProfiled(this); }

    vtable :: (obj: *PxDefaultCpuDispatcher) -> *PxDefaultCpuDispatcher_VTable { return obj.pxdefaultcpudispatcher_vtable; }


    /*
    \brief If a thread ends up waiting for work it will find itself in a spin-wait loop until work becomes available.
    Three strategies are available to limit wasted cycles.
    The strategies are as follows:
    a) wait until a work task signals the end of the spin-wait period.
    b) yield the thread by providing a hint to reschedule thread execution, thereby allowing other threads to run.
    c) yield the processor by informing it that it is waiting for work and requesting it to more efficiently use compute resources.
    */
    PxDefaultCpuDispatcherWaitForWorkMode :: struct {
        Enum :: enum s32 {
            WAIT_FOR_WORK   :: 0;
            YIELD_THREAD    :: 1;
            YIELD_PROCESSOR :: 2;

            eWAIT_FOR_WORK   :: WAIT_FOR_WORK;
            eYIELD_THREAD    :: YIELD_THREAD;
            eYIELD_PROCESSOR :: YIELD_PROCESSOR;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief a factory class for creating PxStringTable with a specific allocator.
    
    \see PxStringTable
    */
    PxStringTableExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxBroadPhaseExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    // These types have been deprecated (removed) in PhysX 3.4. We typedef them to the new types here for easy migration from 3.3 to 3.4.
    // We will not remove these aliases for convenience.
    PxSceneQueryHit :: PxQueryHit;
    PxSceneQueryFilterData :: PxQueryFilterData;
    PxSceneQueryFilterCallback :: PxQueryFilterCallback;
    PxSceneQueryCache :: PxQueryCache;
    PxSceneQueryFlag :: PxHitFlag;
    PxSceneQueryFlags :: PxHitFlags;

    /*
    \brief Utility functions for use with PxScene, related to scene queries.
    
    Some of these functions have been deprecated (removed) in PhysX 3.4. We re-implement them here for easy migration from 3.3 to 3.4.
    We will not remove them for convenience.
    */
    PxSceneQueryExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxBatchQueryStatus :: struct {
        Enum :: enum s32 {
            PENDING  :: 0;

            SUCCESS  :: 1;

            OVERFLOW :: 2;

            ePENDING  :: PENDING;

            eSUCCESS  :: SUCCESS;

            eOVERFLOW :: OVERFLOW;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    PxBatchQueryExt :: struct {
        vtable: *PxBatchQueryExt_VTable;
    }
    PxBatchQueryExt_VTable :: struct #type_info_none {
        release: (this: *PxBatchQueryExt) -> void #cpp_method;

        raycast: (this: *PxBatchQueryExt, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal, maxNbTouches: PxU16 = 0, hitFlags: PxHitFlags = PxHitFlags.{xx Enum.DEFAULT}, filterData: *PxQueryFilterData, cache: *PxQueryCache = null) -> *PxRaycastBuffer #cpp_method;
        raycast :: (this: *PxBatchQueryExt, origin: PxVec3, unitDir: PxVec3, distance: PxReal, maxNbTouches: PxU16 = 0, hitFlags: PxHitFlags = PxHitFlags.{xx Enum.DEFAULT}, filterData: PxQueryFilterData = PxQueryFilterData.{}, cache: *PxQueryCache = null) -> *PxRaycastBuffer #no_context {
            return raycast(this, *origin, *unitDir, distance, maxNbTouches, hitFlags, *filterData, cache);
        }

        sweep: (this: *PxBatchQueryExt, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, maxNbTouches: PxU16 = 0, hitFlags: PxHitFlags = PxHitFlags.{xx Enum.DEFAULT}, filterData: *PxQueryFilterData, cache: *PxQueryCache = null, inflation: PxReal = 0.0) -> *PxSweepBuffer #cpp_method;
        sweep :: (this: *PxBatchQueryExt, geometry: PxGeometry, pose: PxTransform, unitDir: PxVec3, distance: PxReal, maxNbTouches: PxU16 = 0, hitFlags: PxHitFlags = PxHitFlags.{xx Enum.DEFAULT}, filterData: PxQueryFilterData = PxQueryFilterData.{}, cache: *PxQueryCache = null, inflation: PxReal = 0.0) -> *PxSweepBuffer #no_context {
            return sweep(this, *geometry, *pose, *unitDir, distance, maxNbTouches, hitFlags, *filterData, cache, inflation);
        }

        overlap: (this: *PxBatchQueryExt, geometry: *PxGeometry, pose: *PxTransform, maxNbTouches: PxU16 = 0, filterData: *PxQueryFilterData, cache: *PxQueryCache = null) -> *PxOverlapBuffer #cpp_method;
        overlap :: (this: *PxBatchQueryExt, geometry: PxGeometry, pose: PxTransform, maxNbTouches: PxU16 = 0, filterData: PxQueryFilterData = PxQueryFilterData.{}, cache: *PxQueryCache = null) -> *PxOverlapBuffer #no_context {
            return overlap(this, *geometry, *pose, maxNbTouches, *filterData, cache);
        }

        execute: (this: *PxBatchQueryExt) -> void #cpp_method;

        Destructor: (this: *PxBatchQueryExt, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxBatchQueryExt_release :: inline (this: *PxBatchQueryExt) { this.vtable.release(this); }

    PxBatchQueryExt_raycast :: inline (this: *PxBatchQueryExt, origin: *PxVec3, unitDir: *PxVec3, distance: PxReal, maxNbTouches: PxU16 = 0, hitFlags: PxHitFlags = PxHitFlags.{xx Enum.DEFAULT}, filterData: *PxQueryFilterData, cache: *PxQueryCache = null) -> *PxRaycastBuffer { return this.vtable.raycast(this, origin, unitDir, distance, maxNbTouches, hitFlags, filterData, cache); }

    PxBatchQueryExt_sweep :: inline (this: *PxBatchQueryExt, geometry: *PxGeometry, pose: *PxTransform, unitDir: *PxVec3, distance: PxReal, maxNbTouches: PxU16 = 0, hitFlags: PxHitFlags = PxHitFlags.{xx Enum.DEFAULT}, filterData: *PxQueryFilterData, cache: *PxQueryCache = null, inflation: PxReal = 0.0) -> *PxSweepBuffer { return this.vtable.sweep(this, geometry, pose, unitDir, distance, maxNbTouches, hitFlags, filterData, cache, inflation); }

    PxBatchQueryExt_overlap :: inline (this: *PxBatchQueryExt, geometry: *PxGeometry, pose: *PxTransform, maxNbTouches: PxU16 = 0, filterData: *PxQueryFilterData, cache: *PxQueryCache = null) -> *PxOverlapBuffer { return this.vtable.overlap(this, geometry, pose, maxNbTouches, filterData, cache); }

    PxBatchQueryExt_execute :: inline (this: *PxBatchQueryExt) { this.vtable.execute(this); }

    PxBatchQueryExt_Destructor :: inline (this: *PxBatchQueryExt, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxBatchQueryExt) -> *PxBatchQueryExt_VTable { return obj.vtable; }


    /*
    \brief A custom scene query system.
    
    This is an example of a custom scene query system. It augments the PxSceneQuerySystem API to support an arbitrary number
    of "pruners", instead of the usual hardcoded two.
    
    It might not be possible to support the whole PxSceneQuerySystem API in this context. See the source code for details.
    
    \see PxSceneQuerySystem
    */
    PxCustomSceneQuerySystem :: struct {
        #as using pxscenequerysystem: PxSceneQuerySystem;
        #place pxscenequerysystem; pxcustomscenequerysystem_vtable: *PxCustomSceneQuerySystem_VTable;
    }
    PxCustomSceneQuerySystem_VTable :: struct #type_info_none {
        using pxscenequerysystem: PxSceneQuerySystem_VTable;
        addPruner: (this: *PxCustomSceneQuerySystem, primaryType: PxPruningStructureType.Enum, secondaryType: PxDynamicTreeSecondaryPruner.Enum, preallocated: PxU32 = 0) -> PxU32 #cpp_method;

        startCustomBuildstep: (this: *PxCustomSceneQuerySystem) -> PxU32 #cpp_method;

        customBuildstep: (this: *PxCustomSceneQuerySystem, index: PxU32) -> void #cpp_method;

        finishCustomBuildstep: (this: *PxCustomSceneQuerySystem) -> void #cpp_method;
    }

    PxCustomSceneQuerySystem_addPruner :: inline (this: *PxCustomSceneQuerySystem, primaryType: PxPruningStructureType.Enum, secondaryType: PxDynamicTreeSecondaryPruner.Enum, preallocated: PxU32 = 0) -> PxU32 { return this.pxcustomscenequerysystem_vtable.addPruner(this, primaryType, secondaryType, preallocated); }

    PxCustomSceneQuerySystem_startCustomBuildstep :: inline (this: *PxCustomSceneQuerySystem) -> PxU32 { return this.pxcustomscenequerysystem_vtable.startCustomBuildstep(this); }

    PxCustomSceneQuerySystem_customBuildstep :: inline (this: *PxCustomSceneQuerySystem, index: PxU32) { this.pxcustomscenequerysystem_vtable.customBuildstep(this, index); }

    PxCustomSceneQuerySystem_finishCustomBuildstep :: inline (this: *PxCustomSceneQuerySystem) { this.pxcustomscenequerysystem_vtable.finishCustomBuildstep(this); }

    vtable :: (obj: *PxCustomSceneQuerySystem) -> *PxCustomSceneQuerySystem_VTable { return obj.pxcustomscenequerysystem_vtable; }


    /*
    \brief An adapter class to customize the object-to-pruner mapping.
    
    In the regular PhysX code static shapes went to the static pruner, and dynamic shapes went to the
    dynamic pruner.
    
    This class is a replacement for this mapping when N user-defined pruners are involved.
    */
    PxCustomSceneQuerySystemAdapter :: struct {
        vtable: *PxCustomSceneQuerySystemAdapter_VTable;
    }
    PxCustomSceneQuerySystemAdapter_VTable :: struct #type_info_none {
        Destructor: (this: *PxCustomSceneQuerySystemAdapter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        getPrunerIndex: (this: *PxCustomSceneQuerySystemAdapter, actor: *PxRigidActor, shape: *PxShape) -> PxU32 #cpp_method;

        processPruner: (this: *PxCustomSceneQuerySystemAdapter, prunerIndex: PxU32, _context: *PxQueryThreadContext, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback) -> bool #cpp_method;
    }

    PxCustomSceneQuerySystemAdapter_Destructor :: inline (this: *PxCustomSceneQuerySystemAdapter, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxCustomSceneQuerySystemAdapter_getPrunerIndex :: inline (this: *PxCustomSceneQuerySystemAdapter, actor: *PxRigidActor, shape: *PxShape) -> PxU32 { return this.vtable.getPrunerIndex(this, actor, shape); }

    PxCustomSceneQuerySystemAdapter_processPruner :: inline (this: *PxCustomSceneQuerySystemAdapter, prunerIndex: PxU32, _context: *PxQueryThreadContext, filterData: *PxQueryFilterData, filterCall: *PxQueryFilterCallback) -> bool { return this.vtable.processPruner(this, prunerIndex, _context, filterData, filterCall); }

    vtable :: (obj: *PxCustomSceneQuerySystemAdapter) -> *PxCustomSceneQuerySystemAdapter_VTable { return obj.vtable; }


    /*
    \brief utility functions to sample vertices on or inside a triangle mesh or other geometries
    */
    PxSamplingExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Sampler to generate Poisson Samples locally on a triangle mesh or a shape. For every local addition of new samples, an individual sampling density can be used.
    */
    PxPoissonSampler :: struct {
        #as using pxuserallocated: PxUserAllocated;
        vtable: *PxPoissonSampler_VTable;
    }
    PxPoissonSampler_VTable :: struct #type_info_none {
        setSamplingRadius: (this: *PxPoissonSampler, samplingRadius: PxReal) -> bool #cpp_method;

        addSamples: (this: *PxPoissonSampler, samples: *PxArray(PxVec3)) -> void #cpp_method;

        removeSamples: (this: *PxPoissonSampler, samples: *PxArray(PxVec3)) -> PxU32 #cpp_method;

        addSamplesInSphere: (this: *PxPoissonSampler, sphereCenter: *PxVec3, sphereRadius: PxReal, createVolumeSamples := false) -> void #cpp_method;

        addSamplesInBox: (this: *PxPoissonSampler, axisAlignedBox: *PxBounds3, boxOrientation: *PxQuat, createVolumeSamples := false) -> void #cpp_method;

        getSamples: (this: *PxPoissonSampler) -> *PxArray(PxVec3) #cpp_method;

        Destructor: (this: *PxPoissonSampler, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxPoissonSampler_setSamplingRadius :: inline (this: *PxPoissonSampler, samplingRadius: PxReal) -> bool { return this.vtable.setSamplingRadius(this, samplingRadius); }

    PxPoissonSampler_addSamples :: inline (this: *PxPoissonSampler, samples: *PxArray(PxVec3)) { this.vtable.addSamples(this, samples); }

    PxPoissonSampler_removeSamples :: inline (this: *PxPoissonSampler, samples: *PxArray(PxVec3)) -> PxU32 { return this.vtable.removeSamples(this, samples); }

    PxPoissonSampler_addSamplesInSphere :: inline (this: *PxPoissonSampler, sphereCenter: *PxVec3, sphereRadius: PxReal, createVolumeSamples := false) { this.vtable.addSamplesInSphere(this, sphereCenter, sphereRadius, createVolumeSamples); }

    PxPoissonSampler_addSamplesInBox :: inline (this: *PxPoissonSampler, axisAlignedBox: *PxBounds3, boxOrientation: *PxQuat, createVolumeSamples := false) { this.vtable.addSamplesInBox(this, axisAlignedBox, boxOrientation, createVolumeSamples); }

    PxPoissonSampler_getSamples :: inline (this: *PxPoissonSampler) -> *PxArray(PxVec3) { return this.vtable.getSamples(this); }

    PxPoissonSampler_Destructor :: inline (this: *PxPoissonSampler, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxPoissonSampler) -> *PxPoissonSampler_VTable { return obj.vtable; }


    /*
    \brief Sampler to generate Poisson Samples on a triangle mesh.
    */
    PxTriangleMeshPoissonSampler :: struct {
        #as using pxpoissonsampler: PxPoissonSampler;
        #place pxpoissonsampler; pxtrianglemeshpoissonsampler_vtable: *PxTriangleMeshPoissonSampler_VTable;
    }
    PxTriangleMeshPoissonSampler_VTable :: struct #type_info_none {
        using pxpoissonsampler: PxPoissonSampler_VTable;
        getSampleTriangleIds: (this: *PxTriangleMeshPoissonSampler) -> *PxArray(PxI32) #cpp_method;

        getSampleBarycentrics: (this: *PxTriangleMeshPoissonSampler) -> *PxArray(PxVec3) #cpp_method;

        isPointInTriangleMesh: (this: *PxTriangleMeshPoissonSampler, p: *PxVec3) -> bool #cpp_method;
    }

    PxTriangleMeshPoissonSampler_getSampleTriangleIds :: inline (this: *PxTriangleMeshPoissonSampler) -> *PxArray(PxI32) { return this.pxtrianglemeshpoissonsampler_vtable.getSampleTriangleIds(this); }

    PxTriangleMeshPoissonSampler_getSampleBarycentrics :: inline (this: *PxTriangleMeshPoissonSampler) -> *PxArray(PxVec3) { return this.pxtrianglemeshpoissonsampler_vtable.getSampleBarycentrics(this); }

    PxTriangleMeshPoissonSampler_isPointInTriangleMesh :: inline (this: *PxTriangleMeshPoissonSampler, p: *PxVec3) -> bool { return this.pxtrianglemeshpoissonsampler_vtable.isPointInTriangleMesh(this, p); }

    vtable :: (obj: *PxTriangleMeshPoissonSampler) -> *PxTriangleMeshPoissonSampler_VTable { return obj.pxtrianglemeshpoissonsampler_vtable; }


    /*
    \brief utility functions for use with PxTetrahedronMesh and subclasses
    */
    PxTetrahedronMeshExt :: struct {
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Collection of GJK query functions (sweeps, raycasts, overlaps, ...).
    */
    PxGjkQuery :: struct {
        /*
        \brief Abstract interface for a user defined shape GJK mapping support.
        A user defined shape consists of a core shape and a margin. If the distance
        between two shapes' cores is equal to the sum of their margins, these shapes are
        considered touching.
        */
        Support :: struct {
            vtable: *Support_VTable;
        }
        Support_VTable :: struct #type_info_none {
            Destructor: (this: *Support, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

            getMargin: (this: *Support) -> PxReal #cpp_method;

            supportLocal: (this: *Support, dir: *PxVec3) -> PxVec3 #cpp_method;
        }

        Support_Destructor :: inline (this: *Support, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

        Support_getMargin :: inline (this: *Support) -> PxReal { return this.vtable.getMargin(this); }

        Support_supportLocal :: inline (this: *Support, dir: *PxVec3) -> PxVec3 { return this.vtable.supportLocal(this, dir); }

        vtable :: (obj: *Support) -> *Support_VTable { return obj.vtable; }


        /*
        \brief Computes proximity information for two shapes using GJK-EPA algorithm
        
        \param[in] a				Shape A support mapping
        \param[in] b				Shape B support mapping
        \param[in] poseA			Shape A transformation
        \param[in] poseB			Shape B transformation
        \param[in] contactDistance	The distance at which proximity info begins to be computed between the shapes
        \param[in] toleranceLength	The toleranceLength. Used for scaling distance-based thresholds internally to produce appropriate results given simulations in different units
        \param[out] pointA			The closest/deepest point on shape A surface
        \param[out] pointB			The closest/deepest point on shape B surface
        \param[out] separatingAxis	Translating shape B along 'separatingAxis' by 'separation' makes the shapes touching
        \param[out] separation		Translating shape B along 'separatingAxis' by 'separation' makes the shapes touching
        
        \return						False if the distance greater than contactDistance.
        */
        proximityInfo :: (a: *Support, b: *Support, poseA: *PxTransform, poseB: *PxTransform, contactDistance: PxReal, toleranceLength: PxReal, pointA: *PxVec3, pointB: *PxVec3, separatingAxis: *PxVec3, separation: *PxReal) -> bool #foreign physxcommon_static "?proximityInfo@PxGjkQuery@physx@@SA_NAEBUSupport@12@0AEBV?$PxTransformT@M@2@1MMAEAV?$PxVec3T@M@2@22AEAM@Z";
        proximityInfo :: (a: Support, b: Support, poseA: PxTransform, poseB: PxTransform, contactDistance: PxReal, toleranceLength: PxReal, pointA: *PxVec3, pointB: *PxVec3, separatingAxis: *PxVec3, separation: *PxReal) -> bool #no_context {
            return proximityInfo(*a, *b, *poseA, *poseB, contactDistance, toleranceLength, pointA, pointB, separatingAxis, separation);
        }

        /*
        \brief Raycast test against the given shape.
        
        \param[in] shape		Shape support mapping
        \param[in] pose			Shape transformation
        \param[in] rayStart		The start point of the ray to test the shape against
        \param[in] unitDir		Normalized direction of the ray to test the shape against
        \param[in] maxDist		Maximum ray length, has to be in the [0, inf) range
        \param[out] t			Hit distance
        \param[out] n			Hit normal
        \param[out] p			Hit point
        
        \return					True if there is a hit.
        */
        raycast :: (shape: *Support, pose: *PxTransform, rayStart: *PxVec3, unitDir: *PxVec3, maxDist: PxReal, t: *PxReal, n: *PxVec3, p: *PxVec3) -> bool #foreign physxcommon_static "?raycast@PxGjkQuery@physx@@SA_NAEBUSupport@12@AEBV?$PxTransformT@M@2@AEBV?$PxVec3T@M@2@2MAEAMAEAV52@4@Z";
        raycast :: (shape: Support, pose: PxTransform, rayStart: PxVec3, unitDir: PxVec3, maxDist: PxReal, t: *PxReal, n: *PxVec3, p: *PxVec3) -> bool #no_context {
            return raycast(*shape, *pose, *rayStart, *unitDir, maxDist, t, n, p);
        }

        /*
        \brief Overlap test for two shapes.
        
        \param[in] a				Shape A support mapping
        \param[in] b				Shape B support mapping
        \param[in] poseA			Shape A transformation
        \param[in] poseB			Shape B transformation
        
        \return					True if the shapes overlap.
        */
        overlap :: (a: *Support, b: *Support, poseA: *PxTransform, poseB: *PxTransform) -> bool #foreign physxcommon_static "?overlap@PxGjkQuery@physx@@SA_NAEBUSupport@12@0AEBV?$PxTransformT@M@2@1@Z";
        overlap :: (a: Support, b: Support, poseA: PxTransform, poseB: PxTransform) -> bool #no_context {
            return overlap(*a, *b, *poseA, *poseB);
        }

        /*
        \brief Sweep the shape B in space and test for collision with the shape A.
        
        \param[in] a				Shape A support mapping
        \param[in] b				Shape B support mapping
        \param[in] poseA			Shape A transformation
        \param[in] poseB			Shape B transformation
        \param[in] unitDir		Normalized direction of the ray to test the shape against
        \param[in] maxDist		Maximum ray length, has to be in the [0, inf) range
        \param[out] t			Hit distance
        \param[out] n			Hit normal
        \param[out] p			Hit point
        
        \return					True if there is a hit.
        */
        sweep :: (a: *Support, b: *Support, poseA: *PxTransform, poseB: *PxTransform, unitDir: *PxVec3, maxDist: PxReal, t: *PxReal, n: *PxVec3, p: *PxVec3) -> bool #foreign physxcommon_static "?sweep@PxGjkQuery@physx@@SA_NAEBUSupport@12@0AEBV?$PxTransformT@M@2@1AEBV?$PxVec3T@M@2@MAEAMAEAV52@4@Z";
        sweep :: (a: Support, b: Support, poseA: PxTransform, poseB: PxTransform, unitDir: PxVec3, maxDist: PxReal, t: *PxReal, n: *PxVec3, p: *PxVec3) -> bool #no_context {
            return sweep(*a, *b, *poseA, *poseB, *unitDir, maxDist, t, n, p);
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Pre-made custom geometry callbacks implementations.
    */
    PxCustomGeometryExt :: struct {
        /// \cond PRIVATE
        BaseConvexCallbacks :: struct {
            #as using callbacks: PxCustomGeometry.Callbacks;
            #as support: PxGjkQuery.Support; // jai: no "using" to avoid name-clashes

            // Shape margin
            margin: float;
            #place callbacks; baseconvexcallbacks_vtable: *BaseConvexCallbacks_VTable;
        }
        BaseConvexCallbacks_VTable :: struct #type_info_none {
            using callbacks: Callbacks_VTable;
            getMargin: (this: *BaseConvexCallbacks) -> PxReal #cpp_method;

            useSubstituteGeometry: (this: *BaseConvexCallbacks, geom: *PxGeometryHolder, preTransform: *PxTransform, p: *PxContactPoint, pose0: *PxTransform) -> bool #cpp_method;
        }

        BaseConvexCallbacks_getMargin :: inline (this: *BaseConvexCallbacks) -> PxReal { return this.baseconvexcallbacks_vtable.getMargin(this); }

        BaseConvexCallbacks_useSubstituteGeometry :: inline (this: *BaseConvexCallbacks, geom: *PxGeometryHolder, preTransform: *PxTransform, p: *PxContactPoint, pose0: *PxTransform) -> bool { return this.baseconvexcallbacks_vtable.useSubstituteGeometry(this, geom, preTransform, p, pose0); }

        vtable :: (obj: *BaseConvexCallbacks) -> *BaseConvexCallbacks_VTable { return obj.baseconvexcallbacks_vtable; }


        /*
        \brief Cylinder geometry callbacks
        */
        CylinderCallbacks :: struct {
            #as using baseconvexcallbacks: BaseConvexCallbacks;

            // Cylinder height
            height: float;

            // Cylinder radius
            radius: float;

            // Cylinder axis
            axis:   s32;
            #place baseconvexcallbacks; cylindercallbacks_vtable: *CylinderCallbacks_VTable;
        }
        CylinderCallbacks_VTable :: struct #type_info_none {
            using baseconvexcallbacks: BaseConvexCallbacks_VTable;
            supportLocal: (this: *CylinderCallbacks, dir: *PxVec3) -> PxVec3 #cpp_method;
        }
        CylinderCallbacks_supportLocal :: inline (this: *CylinderCallbacks, dir: *PxVec3) -> PxVec3 { return this.cylindercallbacks_vtable.supportLocal(this, dir); }

        vtable :: (obj: *CylinderCallbacks) -> *CylinderCallbacks_VTable { return obj.cylindercallbacks_vtable; }


        /*
        \brief Cone geometry callbacks
        */
        ConeCallbacks :: struct {
            #as using baseconvexcallbacks: BaseConvexCallbacks;

            // Cone height
            height: float;

            // Cone radius
            radius: float;

            // Cone axis
            axis:   s32;
            #place baseconvexcallbacks; conecallbacks_vtable: *ConeCallbacks_VTable;
        }
        ConeCallbacks_VTable :: struct #type_info_none {
            using baseconvexcallbacks: BaseConvexCallbacks_VTable;
            supportLocal: (this: *ConeCallbacks, dir: *PxVec3) -> PxVec3 #cpp_method;
        }
        ConeCallbacks_supportLocal :: inline (this: *ConeCallbacks, dir: *PxVec3) -> PxVec3 { return this.conecallbacks_vtable.supportLocal(this, dir); }

        vtable :: (obj: *ConeCallbacks) -> *ConeCallbacks_VTable { return obj.conecallbacks_vtable; }

        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /// \cond PRIVATE
    // OmniPVD friendly aliases
    PxCustomGeometryExtBaseConvexCallbacks :: PxCustomGeometryExt.BaseConvexCallbacks;
    PxCustomGeometryExtCylinderCallbacks :: PxCustomGeometryExt.CylinderCallbacks;
    PxCustomGeometryExtConeCallbacks :: PxCustomGeometryExt.ConeCallbacks;

    /*
    \deprecated Binary conversion and binary meta data will be removed in a future version without replacement.
    */
    PxConverterReportMode :: struct {
        Enum :: enum s32 {
            NONE    :: 0;
            NORMAL  :: 1;
            VERBOSE :: 2;

            eNONE    :: NONE;
            eNORMAL  :: NORMAL;
            eVERBOSE :: VERBOSE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Binary converter for serialized streams.
    
    \deprecated Binary conversion and binary meta data will be removed in a future version without replacement.
    
    The binary converter class is targeted at converting binary streams from authoring platforms,
    such as windows, osx or linux to any game runtime platform supported by PhysX. Particularly
    it is currently not supported to run the converter on a platforms that has an endian mismatch
    with the platform corresponding to the source binary file and source meta data.
    
    If you want to use multiple threads for batch conversions, please create one instance
    of this class for each thread.
    
    \see PxSerialization.createBinaryConverter
    */
    PxBinaryConverter :: struct {
        vtable: *PxBinaryConverter_VTable;
    }
    PxBinaryConverter_VTable :: struct #type_info_none {
        release: (this: *PxBinaryConverter) -> void #cpp_method;

        setReportMode: (this: *PxBinaryConverter, mode: PxConverterReportMode.Enum) -> void #cpp_method;

        setMetaData: (this: *PxBinaryConverter, srcMetaData: *PxInputStream, dstMetaData: *PxInputStream) -> bool #cpp_method;

        compareMetaData: (this: *PxBinaryConverter) -> bool #cpp_method;

        convert: (this: *PxBinaryConverter, srcStream: *PxInputStream, srcSize: PxU32, targetStream: *PxOutputStream) -> bool #cpp_method;

        Destructor: (this: *PxBinaryConverter, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxBinaryConverter_release :: inline (this: *PxBinaryConverter) { this.vtable.release(this); }

    PxBinaryConverter_setReportMode :: inline (this: *PxBinaryConverter, mode: PxConverterReportMode.Enum) { this.vtable.setReportMode(this, mode); }

    PxBinaryConverter_setMetaData :: inline (this: *PxBinaryConverter, srcMetaData: *PxInputStream, dstMetaData: *PxInputStream) -> bool { return this.vtable.setMetaData(this, srcMetaData, dstMetaData); }

    PxBinaryConverter_compareMetaData :: inline (this: *PxBinaryConverter) -> bool { return this.vtable.compareMetaData(this); }

    PxBinaryConverter_convert :: inline (this: *PxBinaryConverter, srcStream: *PxInputStream, srcSize: PxU32, targetStream: *PxOutputStream) -> bool { return this.vtable.convert(this, srcStream, srcSize, targetStream); }

    PxBinaryConverter_Destructor :: inline (this: *PxBinaryConverter, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxBinaryConverter) -> *PxBinaryConverter_VTable { return obj.vtable; }


    /*
    \brief Helper class containing the mapping of id to object, and type name.
    
    \deprecated Xml serialization is deprecated. An alternative serialization system is provided through USD Physics.
    */
    PxRepXObject :: struct {
        /*
        \brief Identifies the extension meant to handle this object.
        \see PxTypeInfo, PX_DEFINE_TYPEINFO, PxRepXSerializer
        */
        typeName:     *u8;

        /*
        \brief Pointer to the serializable this was created from
        */
        serializable: *void;

        /*
        \brief Id given to this object at some point
        */
        id:           PxSerialObjectId;
    }

    /*
    \brief Arguments required to instantiate a serializable object from RepX.
    
    \deprecated Xml serialization is deprecated. An alternative serialization system is provided through USD Physics.
    
    Extra arguments can be added to the object map under special ids.
    
    \see PxRepXSerializer::objectToFile, PxRepXSerializer::fileToObject
    */
    PxRepXInstantiationArgs :: struct {
        physics:     *PxPhysics;
        cooker:      *PxCookingParams;
        stringTable: *PxStringTable;
    }

    XmlMemoryAllocator :: struct {}
    XmlWriter :: struct {}
    XmlReader :: struct {}
    MemoryBuffer :: struct {}

    /*
    \brief Serializer interface for RepX (Xml) serialization.
    
    \deprecated Xml serialization is deprecated. An alternative serialization system is provided through USD Physics.
    
    In order to serialize a class to RepX both a PxSerializer and
    a PxRepXSerializer implementation are needed.
    
    A repx Serializer provides the ability to capture a live
    object to a descriptor or static state and the ability to
    write that state out to a file.  Objects allocated
    by the Serializer using the allocator are freed when the
    collection itself is freed.
    SnRepXCoreSerializers.cpp implements a set of Serializers
    for the core PhysX types.
    
    \note Implementing a PxRepXSerializer is currently not practical without including the internal PhysXExtension header "SnRepXSerializerImpl.h".
    
    \see PxSerializer, PX_NEW_REPX_SERIALIZER, PxSerializationRegistry::registerRepXSerializer
    */
    PxRepXSerializer :: struct {
        vtable: *PxRepXSerializer_VTable;
    }
    PxRepXSerializer_VTable :: struct #type_info_none {
        Destructor: (this: *PxRepXSerializer, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

        getTypeName: (this: *PxRepXSerializer) -> *u8 #cpp_method;

        objectToFile: (this: *PxRepXSerializer, inLiveObject: *PxRepXObject, inCollection: *PxCollection, inWriter: *XmlWriter, inTempBuffer: *MemoryBuffer, inArgs: *PxRepXInstantiationArgs) -> void #cpp_method;

        fileToObject: (this: *PxRepXSerializer, inReader: *XmlReader, inAllocator: *XmlMemoryAllocator, inArgs: *PxRepXInstantiationArgs, inCollection: *PxCollection) -> PxRepXObject #cpp_method #cpp_return_type_is_non_pod;
    }

    PxRepXSerializer_Destructor :: inline (this: *PxRepXSerializer, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    PxRepXSerializer_getTypeName :: inline (this: *PxRepXSerializer) -> *u8 { return this.vtable.getTypeName(this); }

    PxRepXSerializer_objectToFile :: inline (this: *PxRepXSerializer, inLiveObject: *PxRepXObject, inCollection: *PxCollection, inWriter: *XmlWriter, inTempBuffer: *MemoryBuffer, inArgs: *PxRepXInstantiationArgs) { this.vtable.objectToFile(this, inLiveObject, inCollection, inWriter, inTempBuffer, inArgs); }

    PxRepXSerializer_fileToObject :: inline (this: *PxRepXSerializer, inReader: *XmlReader, inAllocator: *XmlMemoryAllocator, inArgs: *PxRepXInstantiationArgs, inCollection: *PxCollection) -> PxRepXObject { return this.vtable.fileToObject(this, inReader, inAllocator, inArgs, inCollection); }

    vtable :: (obj: *PxRepXSerializer) -> *PxRepXSerializer_VTable { return obj.vtable; }


    vehicle2 :: struct {
        PxVehicleLimits :: struct {
            Enum :: enum s32 {
                WHEELS :: 20;
                AXLES  :: 20;

                eMAX_NB_WHEELS :: WHEELS;
                eMAX_NB_AXLES  :: AXLES;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        PxVehicleComponent :: struct {
            vtable: *PxVehicleComponent_VTable;
        }
        PxVehicleComponent_VTable :: struct #type_info_none {
            Destructor: (this: *PxVehicleComponent, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

            update: (this: *PxVehicleComponent, dt: PxReal, _context: *PxVehicleSimulationContext) -> bool #cpp_method;
        }

        PxVehicleComponent_Destructor :: inline (this: *PxVehicleComponent, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

        PxVehicleComponent_update :: inline (this: *PxVehicleComponent, dt: PxReal, _context: *PxVehicleSimulationContext) -> bool { return this.vtable.update(this, dt, _context); }

        vtable :: (obj: *PxVehicleComponent) -> *PxVehicleComponent_VTable { return obj.vtable; }


        PxVehicleComponentSequenceLimits :: struct {
            Enum :: enum s32 {
                SUBGROUPS        :: 16;
                COMPONENTS       :: 64;
                SUBGROUPELEMENTS :: 80;

                eMAX_NB_SUBGROUPS        :: SUBGROUPS;
                eMAX_NB_COMPONENTS       :: COMPONENTS;
                eMAX_NB_SUBGROUPELEMENTS :: SUBGROUPELEMENTS;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        PxVehicleComponentSequence :: struct {
            anon_enum_1 :: enum s32 {
                eINVALID_SUBSTEP_GROUP :: 255;
            }

            eINVALID :: enum s32 {
                COMPONENT         :: 255;
                SUB_GROUP_ELEMENT :: 255;

                eINVALID_COMPONENT         :: COMPONENT;
                eINVALID_SUB_GROUP_ELEMENT :: SUB_GROUP_ELEMENT;
            }

            //Elements have the form of a linked list to allow traversal over a list of elements.
            //Each element is either a single component or a subgroup.
            SubGroupElement :: struct {
                childGroup:  PxU8;
                component:   PxU8;
                nextElement: PxU8;
            }

            //A group is a linked list of  elements to be processed in sequence.
            //Each group stores the first element in the sequence.
            //Each element in the sequence stores the next element in the sequence
            //to allow traversal over the  list of elements in the group.
            Group :: struct {
                parentGroup:  PxU8;
                firstElement: PxU8;
                nbSteps:      PxU8;
            }

            mComponents:         [64] *PxVehicleComponent;
            mNbComponents:       PxU8;

            mSubGroups:          [16] Group;
            mNbSubgroups:        PxU8;

            mSubGroupElements:   [80] SubGroupElement;
            mNbSubGroupElements: PxU8;

            mActiveSubgroup:     PxU8;
        }

        PxVehicleAxleDescription :: struct {
            nbAxles:             PxU32; //!< The number of axles on the vehicle
            nbWheelsPerAxle:     [20] PxU32; //!< The number of wheels on each axle.
            axleToWheelIds:      [20] PxU32; //!< The list of wheel ids for the ith axle begins at wheelIdsInAxleOrder[axleToWheelIds[i]]

            wheelIdsInAxleOrder: [20] PxU32; //!< The list of all wheel ids on the vehicle.	
            nbWheels:            PxU32; //!< The number of wheels on the vehicle.
        }

        PxVehicleAxes :: struct {
            Enum :: enum s32 {
                PosX        :: 0;
                NegX        :: 1;
                PosY        :: 2;
                NegY        :: 3;
                PosZ        :: 4;
                NegZ        :: 5;
                MAX_NB_AXES :: 6;

                ePosX        :: PosX;
                eNegX        :: NegX;
                ePosY        :: PosY;
                eNegY        :: NegY;
                ePosZ        :: PosZ;
                eNegZ        :: NegZ;
                eMAX_NB_AXES :: MAX_NB_AXES;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        PxVehicleFrame :: struct {
            lngAxis: PxVehicleAxes.Enum; //!< The axis defining the longitudinal (forward) direction of the vehicle.
            latAxis: PxVehicleAxes.Enum; //!< The axis defining the lateral (side) direction of the vehicle.
            vrtAxis: PxVehicleAxes.Enum; //!< The axis defining the vertical (up) direction of the vehicle.
        }

        PxVehicleScale :: struct {
            scale: PxReal; //!< The length scale used for the vehicle. For example, if 1.0 is considered meters, then 100.0 would be for centimeters.
        }

        /*
        \brief Helper struct to pass array type data to vehice components and functions.
        
        The Vehicle SDK tries to give the user a certain freedom in how the parameters and
        states are stored. This helper struct presents a way to either use array of structs
        or array of pointers to structs to pass data into the provided vehicle components
        and functions.
        */
        PxVehicleArrayData :: struct(T: Type) {
            DataFormat :: enum s32 {
                STRUCTS  :: 0;
                POINTERS :: 0;

                eARRAY_OF_STRUCTS  :: STRUCTS;
                eARRAY_OF_POINTERS :: POINTERS;
            }

            union {
                arrayOfStructs:  *T; //!< The data stored as an array of structs.
                arrayOfPointers: **T; //!< The data stored as an array of pointers.
            }

            dataFormat: PxU8;
        }

        PxVehicleSizedArrayData :: struct(T: Type) {
            #as pxvehiclearraydata: PxVehicleArrayData(T); // jai: no "using" to avoid name-clashes

            size: PxU32;
        }

        /*
        \brief Determine whether the PhysX actor associated with a vehicle is to be updated with a velocity change or an acceleration change.
        A velocity change will be immediately reflected in linear and angular velocity queries against the vehicle.  An acceleration change, on the other hand,
        will leave the linear and angular velocities unchanged until the next PhysX scene update has applied the acceleration update to the actor's linear and
        angular velocities.
        \see PxVehiclePhysXActorEndComponent
        \see PxVehicleWriteRigidBodyStateToPhysXActor
        */
        PxVehiclePhysXActorUpdateMode :: struct {
            Enum :: enum s32 {
                VELOCITY     :: 0;
                ACCELERATION :: 1;

                eAPPLY_VELOCITY     :: VELOCITY;
                eAPPLY_ACCELERATION :: ACCELERATION;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        /*
        \brief Tire slip values are computed using ratios with potential for divide-by-zero errors. PxVehicleTireSlipParams
        introduces a minimum value for the denominator of each of these ratios.
        */
        PxVehicleTireSlipParams :: struct {
            /*
            \brief The lateral slip angle is typically computed as a function of the ratio of lateral and longitudinal speeds
            of the rigid body in the tire's frame. This leads to a divide-by-zero in the event that the longitudinal speed
            approaches zero. The parameter minLatSlipDenominator sets a minimum denominator for the ratio of speeds used to
            compute the lateral slip angle.
            \note Larger timesteps typically require larger values of minLatSlipDenominator.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> velocity = length / time
            */
            minLatSlipDenominator:         PxReal;

            /*
            \brief The longitudinal slip represents the difference between the longitudinal speed of the rigid body in the tire's
            frame and the linear speed arising from the rotation of the wheel. This is typically normalized using the reciprocal
            of the longitudinal speed of the rigid body in the tire's frame. This leads to a divide-by-zero in the event that the
            longitudinal speed approaches zero. The parameter minPassiveLongSlipDenominator sets a minimum denominator for the normalized
            longitudinal slip when the wheel experiences zero drive torque and zero brake torque and zero handbrake torque. The aim is
            to bring the vehicle to rest without experiencing wheel rotational speeds that oscillate around zero.
            \note The vehicle will come to rest more smoothly with larger values of minPassiveLongSlipDenominator, particularly
            with large timesteps that often lead to oscillation in wheel rotation speeds when the wheel rotation speed approaches
            zero.
            \note It is recommended that minActiveLongSlipDenominator < minPassiveLongSlipDenominator.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> velocity = length / time
            */
            minPassiveLongSlipDenominator: PxReal;

            /*
            \brief The longitudinal slip represents the difference between the longitudinal speed of the rigid body in the tire's
            frame and the linear speed arising from the rotation of the wheel. This is typically normalized using the reciprocal
            of the longitudinal speed of the rigid body in the tire's frame. This leads to a divide-by-zero in the event that the
            longitudinal speed approaches zero. The parameter minActiveLongSlipDenominator sets a minimum denominator for the normalized
            longitudinal slip when the wheel experiences either a non-zero drive torque or a non-zero brake torque or a non-zero handbrake
            torque.
            \note Larger timesteps typically require larger values of minActiveLongSlipDenominator to avoid instabilities occurring when
            the vehicle is aggressively throttled from rest.
            \note It is recommended that minActiveLongSlipDenominator < minPassiveLongSlipDenominator.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> velocity = length / time
            */
            minActiveLongSlipDenominator:  PxReal;
        }

        /*
        \brief Tires have two important directions for the purposes of tire force computation: longitudinal and lateral.
        */
        PxVehicleTireDirectionModes :: struct {
            Enum :: enum s32 {
                LONGITUDINAL             :: 0;
                LATERAL                  :: 1;
                MAX_NB_PLANAR_DIRECTIONS :: 2;

                eLONGITUDINAL             :: LONGITUDINAL;
                eLATERAL                  :: LATERAL;
                eMAX_NB_PLANAR_DIRECTIONS :: MAX_NB_PLANAR_DIRECTIONS;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        /*
        \brief The low speed regime often presents numerical difficulties for the tire model due to the potential for divide-by-zero errors.
        This particularly affects scenarios where the vehicle is slowing down due to damping and drag. In scenarios where there is no
        significant brake or drive torque, numerical error begins to dominate and it can be difficult to bring the vehicle to rest. A solution
        to this problem is to recognise that the vehicle is close to rest and to replace the tire forces with velocity constraints that will
        bring the vehicle to rest. This regime is known as the "sticky tire" regime. PxVehicleTireAxisStickyParams describes velocity and time
        thresholds that categorise the "sticky tire" regime. It also describes the rate at which the velocity constraints approach zero speed.
        */
        PxVehicleTireAxisStickyParams :: struct {
            /*
            \brief A tire enters the "sticky tire" regime when it has been below a speed specified by #thresholdSpeed for a continuous time
            specified by #thresholdTime.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> velocity = length / time
            */
            thresholdSpeed: PxReal;

            /*
            \brief A tire enters the "sticky tire" regime when it has been below a speed specified by #thresholdSpeed for a continuous time
            specified by #thresholdTime.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> time
            */
            thresholdTime:  PxReal;

            /*
            \brief The rate at which the velocity constraint approaches zero is controlled by the damping parameter.
            \note Larger values of damping lead to faster approaches to zero. Since the damping behaves like a
            stiffness with respect to the velocity, too large a value can lead to instabilities.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> 1 / time (acceleration instead of force based damping, thus not mass/time)
            */
            damping:        PxReal;
        }

        /*
        \brief For each tire, the forces of the tire model may be replaced by velocity constraints when the tire enters the "sticky tire"
        regime. The "sticky tire" regime of the lateral and longitudinal directions of the tire are managed separately.
        */
        PxVehicleTireStickyParams :: struct {
            /*
            The "sticky tire" regime of the lateral and longitudinal directions of the tire are managed separately and are individually
            parameterized.
            */
            stickyParams: [2] PxVehicleTireAxisStickyParams;
        }

        PxVehicleSimulationContextType :: struct {
            Enum :: enum s32 {
                DEFAULT :: 0;
                PHYSX   :: 1;

                eDEFAULT :: DEFAULT;
                ePHYSX   :: PHYSX;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        /*
        \brief Structure to support Omni PVD, the PhysX Visual Debugger.
        */
        PxVehiclePvdContext :: struct {
            PxVehiclePvdAttributeHandles :: struct {}
            /*
            \brief The attribute handles used to reflect vehicle parameter and state data in omnipvd.
            \note A null value will result in no values being reflected in omnipvd.
            \note #attributeHandles and #writer both need to be non-NULL to reflect vehicle values in omnipvd.
            \see PxVehiclePvdAttributesCreate
            \see PxVehiclePvdAttributesRelease
            \see PxVehiclePVDComponent
            */
            attributeHandles: *PxVehiclePvdAttributeHandles;

            /*
            \brief An instance of OmniPvdWriter used to write vehicle prameter and state data to omnipvd.
            \note A null value will result in no values being reflected in omnipvd.
            \note #attributeHandles and #writer both need to be non-NULL to reflect vehicle values in omnipvd.
            \see PxVehiclePvdAttributesCreate
            \see PxVehiclePvdAttributesRelease
            \see PxVehiclePVDComponent
            */
            writer:           *OmniPvdWriter;
        }

        PxVehicleSimulationContext :: struct {
            gravity:                                       PxVec3;

            frame:                                         PxVehicleFrame;
            scale:                                         PxVehicleScale;

            //Tire
            tireSlipParams:                                PxVehicleTireSlipParams;
            tireStickyParams:                              PxVehicleTireStickyParams;

            /*
            \brief Forward wheel speed below which the wheel rotation speed gets blended with the rolling speed.
            
            The blended rotation speed is used to integrate the wheel rotation angle. At low forward wheel speed,
            the wheel rotation speed can get unstable (depending on the tire model used) and, for example, oscillate.
            
            \note If brake or throttle is applied, there will be no blending.
            
            <b>Unit:</b> velocity = length / time
            */
            thresholdForwardSpeedForWheelAngleIntegration: PxReal;

            /*
            \brief Structure to support Omni PVD, the PhysX Visual Debugger.
            */
            pvdContext:                                    PxVehiclePvdContext;

            type:                                          PxVehicleSimulationContextType.Enum;
        }

        PxVehiclePhysXSimulationContext :: struct {
            #as using pxvehiclesimulationcontext: PxVehicleSimulationContext;

            //Road geometry queries to find the plane under the wheel.
            physxUnitCylinderSweepMesh:      *PxConvexMesh;
            physxScene:                      *PxScene;

            //PhysX actor update
            physxActorUpdateMode:            PxVehiclePhysXActorUpdateMode.Enum;

            /*
            \brief Wake counter value to set on the physx actor if a reset is required.
            
            Certain vehicle states should keep a physx actor of a vehicle awake. This
            will be achieved by resetting the wake counter value if needed. The wake
            counter value is the minimum simulation time that a physx actor will stay
            awake.
            
            <b>Unit:</b> time
            
            \see physxActorWakeCounterThreshold PxVehiclePhysxActorKeepAwakeCheck
            */
            physxActorWakeCounterResetValue: PxReal;

            /*
            \brief Threshold below which to check whether the physx actor wake counter
            should get reset.
            
            <b>Unit:</b> time
            
            \see physxActorWakeCounterResetValue PxVehiclePhysxActorKeepAwakeCheck
            */
            physxActorWakeCounterThreshold:  PxReal;
        }

        /*
        * \brief Express a function as a sequence of points {(x, y)} that form a piecewise polynomial.
        */
        PxVehicleFixedSizeLookupTable :: struct(T: Type, NB_ELEMENTS: u32) {
            xVals:       [PxReal] PxReal;
            yVals:       [T] T;
            nbDataPairs: PxU32;
        }

        PxVehicleRoadGeometryState :: struct {
            plane:    PxPlane; //!< the plane under the wheel
            friction: PxReal; //!< the friction to be used by the tire model
            velocity: PxVec3; //!< the velocity of the road geometry
            hitState: bool; //!< true if a plane is found, false if there is no plane.
        }

        PxVehicleRigidBodyState :: struct {
            pose:                    PxTransform; //!< the body's pose (in world space)
            linearVelocity:          PxVec3; //!< the body's linear velocity (in world space)
            angularVelocity:         PxVec3; //!< the body's angular velocity (in world space)
            previousLinearVelocity:  PxVec3; //!< the previous linear velocity of the body (in world space)
            previousAngularVelocity: PxVec3; //!< the previous angular velocity of the body (in world space)
            externalForce:           PxVec3; //!< external force (in world space) affecting the rigid body (usually excluding gravitational force)
            externalTorque:          PxVec3; //!< external torque (in world space) affecting the rigid body
        }

        PxVehiclePhysXRoadGeometryQueryState :: struct {
            actor:       *PxRigidActor; //!< The actor that got hit by the query.
            shape:       *PxShape; //!< The shape that got hit by the query.
            material:    *PxMaterial; //!< The material at the hit point.
            hitPosition: PxVec3; //!< The hit position in world space.
        }

        /*
        \brief A description of the PhysX actor and shapes that represent the vehicle in an associated PxScene.
        */
        PxVehiclePhysXActor :: struct {
            /*
            \brief The PhysX rigid body that represents the vehcle in the associated PhysX scene.
            \note PxActorFlag::eDISABLE_GRAVITY must be set true on the PxRigidBody
            */
            rigidBody:   *PxRigidBody;

            /*
            \brief An array of shapes with one shape pointer (or NULL) for each wheel.
            */
            wheelShapes: [20] *PxShape;
        }

        /*
        \brief A description of the previous steer command applied to the vehicle.
        */
        PxVehiclePhysXSteerState :: struct {
            /*
            \brief The steer command that was most previously applied to the vehicle.
            */
            previousSteerCommand: PxReal;
        }

        PxVehicleVectorN :: struct {
            anon_enum_2 :: enum s32 {
                eMAX_SIZE :: 23;
            }

            mValues: [23] PxReal;
            mSize:   PxU32;
        }

        PxVehicleMatrixNN :: struct {
            mValues: [23] [23] PxReal;
            mSize:   PxU32;
        }

        /*
        LUPQ decomposition
        
        Based upon "Outer Product LU with Complete Pivoting," from Matrix Computations (4th Edition), Golub and Van Loan
        
        Solve A*x = b using:
        
        MatrixNNLUSolver solver;
        solver.decomposeLU(A);
        solver.solve(b, x);
        */
        PxVehicleMatrixNNLUSolver :: struct {
            mLU:   PxVehicleMatrixNN;
            mP:    [22] PxU32; // Row permutation
            mQ:    [22] PxU32; // Column permutation
            mDetM: PxReal;
        }

        PxVehicleMatrixNGaussSeidelSolver :: struct {
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        PxVehicleMatrix33Solver :: struct {
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        /*
        \brief Each command value may be associated with a table specifying a normalized response as a function of longitudinal speed.
        Multiple instances of PxVehicleCommandValueResponseTable allow a normalized response to be authored as a multi-variate
        piecewise polynomial with normalized command response expressed as a nonlinear function of command value and speed.
        */
        PxVehicleCommandValueResponseTable :: struct {
            Enum :: enum s32 {
                eMAX_NB_SPEED_RESPONSES :: 64;
            }

            /*
            \brief The command value associated with the table of speed responses.
            */
            commandValue:   PxReal;

            /*
            \brief A lookup table specifying the normalised response to the specified command value as a function of longitudinal speed.
            \note Each entry in the speedResponses table must be of the form (speed, normalizedResponse).
            \note The longitudinal speeds in the table must form a strictly increasing series.
            \note The normalized responses must be in range [0, 1].
            */
            speedResponses: PxVehicleFixedSizeLookupTable(PxReal, UnknownTemplateArgumentPlaceholder) = xx Enum.eMAX_NB_SPEED_RESPONSES;
        }

        /*
        \note Brake, drive and steer response typically reduce at increased longitudinal speed. Moreover, response to a brake, throttle or steer command is typically
        nonlinear and may be subject to dead zones where response is constant with either zero or non-zero response. PxVehicleCommandNonLinearResponseParams allows
        command responses to be authored as multi-variate piecewise polynomials with normalized command response a function of command value and longitudinal speed.
        */
        PxVehicleCommandNonLinearResponseParams :: struct {
            Enum :: enum s32 {
                eMAX_NB_COMMAND_VALUES :: 8;
            }

            /*
            \brief A ragged array of speeds and normalized responses.
            */
            speedResponses:                  [128] PxReal;

            /*
            \brief The number of speeds and normalized responses.
            */
            nbSpeedResponses:                PxU16;

            /*
            \brief The table of speed responses for the ith command value begins at speedResponses[2*speedResponsesPerCommandValue[i]]
            */
            speedResponsesPerCommandValue:   [8] PxU16;

            /*
            \brief The ith command value has N speed responses with N = nbSpeedRenponsesPerCommandValue[i].
            */
            nbSpeedResponsesPerCommandValue: [8] PxU16;

            /*
            \brief The command values.
            */
            commandValues:                   [8] PxReal;

            /*
            \brief The number of command values.
            */
            nbCommandValues:                 PxU16;
        }

        /*
        \brief A description of the per wheel response to an input command.
        */
        PxVehicleCommandResponseParams :: struct {
            /*
            \brief A nonlinear response to command value expressed as a lookup table of normalized response as a function of command value and longitudinal speed.
            \note The effect of the default state of nonlinearResponse is a linear response to command value that is independent of longitudinal speed.
            */
            nonlinearResponse:        PxVehicleCommandNonLinearResponseParams;

            /*
            \brief A description of the per wheel response multiplier to an input command.
            */
            wheelResponseMultipliers: [20] PxReal;

            /*
            \brief The maximum response that occurs when the wheel response multiplier has value 1.0 and nonlinearResponse is in the default state of linear response.
            */
            maxResponse:              PxF32;
        }

        /*
        \brief Distribute a brake response to the wheels of a vehicle.
        \note The brake torque of each wheel on the ith wheel is brakeCommand * maxResponse * wheelResponseMultipliers[i].
        \note A typical use case is to set maxResponse to be the vehicle's maximum achievable brake torque
        that occurs when the brake command is equal to 1.0.  The array wheelResponseMultipliers[i] would then be used
        to specify the maximum achievable brake torque per wheel as a fractional multiplier of the vehicle's maximum achievable brake torque.
        */
        PxVehicleBrakeCommandResponseParams :: struct {
            #as using pxvehiclecommandresponseparams: PxVehicleCommandResponseParams;
        }

        /*
        \brief A description of the state of commands that are applied to the vehicle
        \note brakes[0] and brakes[1] may be used to distinguish brake and handbrake controls.
        */
        PxVehicleCommandState :: struct {
            brakes:   [2] PxReal; //!< The instantaneous state of the brake controllers in range [0,1] with 1 denoting fully pressed and 0 fully depressed.
            nbBrakes: PxU32; //|< The number of brake commands.
            throttle: PxReal; //!< The instantaneous state of the throttle controller in range [0,1] with 1 denoting fully pressed and 0 fully depressed.
            steer:    PxReal; //!< The instantaneous state of the steer controller in range [-1,1].
        }

        /*
        \brief A description of the state of transmission-related commands that are applied to a vehicle with direct drive.
        */
        PxVehicleDirectDriveTransmissionCommandState :: struct {
            /*
            \brief Direct drive vehicles only have reverse, neutral or forward gear.
            */
            Enum :: enum s32 {
                REVERSE :: 0;
                NEUTRAL :: 1;
                FORWARD :: 2;

                eREVERSE :: REVERSE;
                eNEUTRAL :: NEUTRAL;
                eFORWARD :: FORWARD;
            }

            gear: Enum; //!< The desired gear of the input gear controller.
        }

        /*
        \brief A description of the state of transmission-related commands that are applied to a vehicle with engine drive.
        */
        PxVehicleEngineDriveTransmissionCommandState :: struct {
            Enum :: enum s32 {
                eAUTOMATIC_GEAR :: 255;
            }

            clutch:     PxReal; //!< The instantaneous state of the clutch controller in range [0,1] with 1 denoting fully pressed and 0 fully depressed.
            targetGear: PxU32; //!< The desired gear of the input gear controller.
        }

        /*
        \brief A description of the state of transmission-related commands that are applied to a vehicle with tank drive.
        */
        PxVehicleTankDriveTransmissionCommandState :: struct {
            #as using pxvehicleenginedrivetransmissioncommandstate: PxVehicleEngineDriveTransmissionCommandState;

            /*
            \brief The wheels of each tank track are either all connected to thrusts[0] or all connected to thrusts[1].
            \note The thrust commands are used to divert torque from the engine to the wheels of the tank tracks controlled by each thrust.
            \note thrusts[0] and thrusts[1] are in range [-1,1] with the sign dictating whether the thrust will be applied positively or negatively with respect to the gearing ratio.
            */
            thrusts: [2] PxReal;
        }

        /*
        \brief Distribute a throttle response to the wheels of a direct drive vehicle.
        \note The drive torque applied to each wheel on the ith axle is throttleCommand * maxResponse * wheelResponseMultipliers[i].
        \note A typical use case is to set maxResponse to be the vehicle's maximum achievable drive torque
        that occurs when the steer command is equal to 1.0. The array wheelResponseMultipliers[i] would then be used
        to specify the maximum achievable drive torque per wheel as a fractional multiplier of the vehicle's maximum achievable steer angle.
        */
        PxVehicleDirectDriveThrottleCommandResponseParams :: struct {
            #as using pxvehiclecommandresponseparams: PxVehicleCommandResponseParams;
        }

        /*
        \brief Specifies the maximum clutch strength that occurs when the clutch pedal is fully disengaged and the clutch is fully engaged.
        */
        PxVehicleClutchCommandResponseParams :: struct {
            /*
            \brief Strength of clutch.
            
            \note The clutch is the mechanism that couples the engine to the wheels.
            A stronger clutch more strongly couples the engine to the wheels, while a
            clutch of strength zero completely decouples the engine from the wheels.
            Stronger clutches more quickly bring the wheels and engine into equilibrium, while weaker
            clutches take longer, resulting in periods of clutch slip and delays in power transmission
            from the engine to the wheels.
            The torque generated by the clutch is proportional to the clutch strength and
            the velocity difference between the engine's rotational speed and the rotational speed of the
            driven wheels after accounting for the gear ratio.
            The torque at the clutch is applied negatively to the engine and positively to the driven wheels.
            
            <b>Range:</b> [0,inf)<br>
            <b>Unit:</b> torque * time = mass * (length^2) / time
            */
            maxResponse: PxReal;
        }

        /*
        \brief Choose between a potentially more expensive but more accurate solution to the clutch model or a potentially cheaper but less accurate solution.
        \see PxVehicleClutchParams
        */
        PxVehicleClutchAccuracyMode :: struct {
            Enum :: enum s32 {
                ESTIMATE      :: 0;
                BEST_POSSIBLE :: 1;

                eESTIMATE      :: ESTIMATE;
                eBEST_POSSIBLE :: BEST_POSSIBLE;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        /*
        \brief The clutch connects two plates together. One plate rotates with the speed of the engine. The second plate rotates with a weighted average of all
        wheels connected to the differential after accounting for the gear ratio. The difference in rotation speeds generates a restoring torque applied to engine and wheels
        that aims to reduce the difference in rotational speed. The restoring torque is proportional to the clutch strength and the clutch pedal position.
        */
        PxVehicleClutchParams :: struct {
            /*
            \brief The engine and wheel rotation speeds that are coupled through the clutch can be updated by choosing
            one of two modes: eESTIMATE and eBEST_POSSIBLE.
            
            \note If eESTIMATE is chosen the vehicle sdk will update the wheel and engine rotation speeds
            with estimated values to the implemented clutch model.
            
            \note If eBEST_POSSIBLE is chosen the vehicle sdk will compute the best possible
            solution (within floating point tolerance) to the implemented clutch model.
            This is the recommended mode.
            
            \note The clutch model remains the same if either eESTIMATE or eBEST_POSSIBLE is chosen but the accuracy and
            computational cost of the solution to the model can be tuned as required.
            */
            accuracyMode:       PxVehicleClutchAccuracyMode.Enum;

            /*
            \brief Tune the mathematical accuracy and computational cost of the computed estimate to the wheel and
            engine rotation speeds if eESTIMATE is chosen.
            
            \note As estimateIterations increases the computational cost of the clutch also increases and the solution
            approaches the solution that would be computed if eBEST_POSSIBLE was chosen instead.
            
            \note This has no effect if eBEST_POSSIBLE is chosen as the accuracy mode.
            
            \note A value of zero is not allowed if eESTIMATE is chosen as the accuracy mode.
            */
            estimateIterations: PxU32;
        }

        PxVehicleEngineParams :: struct {
            /*
            \brief Maximum supported number of points in the #torqueCurve graph.
            */
            anon_enum_3 :: enum s32 {
                eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES :: 8;
            }

            /*
            \brief Graph of normalized torque (torque/#peakTorque) against normalized engine speed ( engineRotationSpeed / #maxOmega ).
            
            \note The normalized engine speed is the x-axis of the graph, while the normalized torque is the y-axis of the graph.
            */
            torqueCurve:                             PxVehicleFixedSizeLookupTable(PxReal, UnknownTemplateArgumentPlaceholder) = xx anon_enum_3.eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES;

            /*
            \brief Moment of inertia of the engine around the axis of rotation.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass * (length^2)
            */
            moi:                                     PxReal;

            /*
            \brief Maximum torque available to apply to the engine when the accelerator pedal is at maximum.
            
            \note The torque available is the value of the accelerator pedal (in range [0, 1]) multiplied by the normalized torque as computed from #torqueCurve multiplied by #peakTorque.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> mass * (length^2) / (time^2)
            */
            peakTorque:                              PxReal;

            /*
            \brief Minimum rotation speed of the engine.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> radians / time
            */
            idleOmega:                               PxReal;

            /*
            \brief Maximum rotation speed of the engine.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> radians / time
            */
            maxOmega:                                PxReal;

            /*
            \brief Damping rate of engine when full throttle is applied.
            
            \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
            between #dampingRateZeroThrottleClutchEngaged and #dampingRateFullThrottle:
            #dampingRateZeroThrottleClutchEngaged + (#dampingRateFullThrottle-#dampingRateZeroThrottleClutchEngaged)*acceleratorPedal;
            
            \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
            between #dampingRateZeroThrottleClutchDisengaged and #dampingRateFullThrottle:
            #dampingRateZeroThrottleClutchDisengaged + (#dampingRateFullThrottle-#dampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> torque * time = mass * (length^2) / time
            */
            dampingRateFullThrottle:                 PxReal;

            /*
            \brief Damping rate of engine when no throttle is applied and with engaged clutch.
            
            \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
            between #dampingRateZeroThrottleClutchEngaged and #dampingRateFullThrottle:
            #dampingRateZeroThrottleClutchEngaged + (#dampingRateFullThrottle-#dampingRateZeroThrottleClutchEngaged)*acceleratorPedal;
            
            \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
            between #dampingRateZeroThrottleClutchDisengaged and #dampingRateFullThrottle:
            #dampingRateZeroThrottleClutchDisengaged + (#dampingRateFullThrottle-#dampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> torque * time = mass * (length^2) / time
            */
            dampingRateZeroThrottleClutchEngaged:    PxReal;

            /*
            \brief Damping rate of engine when no throttle is applied and with disengaged clutch.
            
            \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
            between #dampingRateZeroThrottleClutchEngaged and #dampingRateFullThrottle:
            #dampingRateZeroThrottleClutchEngaged + (#dampingRateFullThrottle-#dampingRateZeroThrottleClutchEngaged)*acceleratorPedal;
            
            \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
            between #dampingRateZeroThrottleClutchDisengaged and #dampingRateFullThrottle:
            #dampingRateZeroThrottleClutchDisengaged + (#dampingRateFullThrottle-#dampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> torque * time = mass * (length^2) / time
            */
            dampingRateZeroThrottleClutchDisengaged: PxReal;
        }

        PxVehicleGearboxParams :: struct {
            /*
            \brief The gear that denotes neutral gear
            */
            neutralGear: PxU32;

            /*
            \brief Maximum supported number of gears, including reverse and neutral.
            */
            Enum :: enum s32 {
                eMAX_NB_GEARS :: 32;
            }

            /*
            \brief Gear ratios
            
            The ratio for reverse gears must be negative, the ratio for the neutral gear
            has to be 0 and the ratio for forward gears must be positive.
            */
            ratios:      [32] PxReal;

            /*
            \brief Gear ratio applied is #ratios[currentGear]*#finalRatio
            
            <b>Range:</b> (0, inf)<br>
            */
            finalRatio:  PxReal;

            /*
            \brief Number of gears (including reverse and neutral).
            
            <b>Range:</b> [1, eMAX_NB_GEARS]<br>
            */
            nbRatios:    PxU32;

            /*
            \brief Time it takes to switch gear.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> time
            */
            switchTime:  PxReal;
        }

        PxVehicleAutoboxParams :: struct {
            /*
            \brief Value of ( engineRotationSpeed /maxEngineRevs ) that is high enough to increment gear.
            
            \note When ( engineRotationSpeed / #PxVehicleEngineParams::maxOmega ) > upRatios[currentGear] the autobox will begin
            a transition to currentGear+1 unless currentGear is the highest possible gear or neutral or reverse.
            
            <b>Range:</b> [0, 1]<br>
            */
            upRatios:   [32] PxReal;

            /*
            \brief Value of engineRevs/maxEngineRevs that is low enough to decrement gear.
            
            \note When ( engineRotationSpeed / #PxVehicleEngineParams::maxOmega) < downRatios[currentGear] the autobox will begin
            a transition to currentGear-1 unless currentGear is first gear or neutral or reverse.
            
            <b>Range:</b> [0, 1]<br>
            */
            downRatios: [32] PxReal;

            /*
            \brief Set the latency time of the autobox.
            
            \note Latency time is the minimum time that must pass between each gear change that is initiated by the autobox.
            The auto-box will only attempt to initiate another gear change up or down if the simulation time that has passed since the most recent
            automated gear change is greater than the specified latency.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> time
            */
            latency:    PxReal;
        }

        /*
        \deprecated This API was introduced with the new Vehicle API for transition purposes but will be removed in a future version.
        */
        PxVehicleFourWheelDriveDifferentialLegacyParams :: struct {
            Enum :: enum s32 {
                DIFF_TYPE_LS_4WD     :: 0;
                DIFF_TYPE_LS_FRONTWD :: 1;
                DIFF_TYPE_LS_REARWD  :: 2;
                MAX_NB_DIFF_TYPES    :: 3;

                eDIFF_TYPE_LS_4WD     :: DIFF_TYPE_LS_4WD;
                eDIFF_TYPE_LS_FRONTWD :: DIFF_TYPE_LS_FRONTWD;
                eDIFF_TYPE_LS_REARWD  :: DIFF_TYPE_LS_REARWD;
                eMAX_NB_DIFF_TYPES    :: MAX_NB_DIFF_TYPES;
            }

            /*
            \brief The two front wheels are specified by the array frontWheelIds.
            \note The states eDIFF_TYPE_LS_4WD, eDIFF_TYPE_LS_FRONTWD require knowledge of the front wheels
            to allow torque splits between front and rear axles as well as torque splits across the front axle.
            \note frontWheelIds[0] should specify the wheel on the front axle that is negatively placed on the lateral axis.
            \note frontWheelIds[1] should specify the wheel on the front axle that is positively placed on the lateral axis.
            \note If #frontNegPosSplit > 0.5, more torque will be delivered to the wheel specified by frontWheelIds[0] than to the wheel
            specified by frontWheelIds[1]. The converse is true if #frontNegPosSplit < 0.5.
            */
            frontWheelIds:    [2] PxU32;

            /*
            \brief The two rear wheels are specified by the array rearWheelIds.
            \note The states eDIFF_TYPE_LS_4WD, eDIFF_TYPE_LS_REARWD require knowledge of the rear wheels
            to allow torque splits between front and rear axles as well as torque splits across the rear axle.
            \note rearWheelIds[0] should specify the wheel on the rear axle that is negatively placed on the lateral axis.
            \note rearWheelIds[1] should specify the wheel on the rear axle that is positively placed on the lateral axis.
            \note If #rearNegPosSplit > 0.5, more torque will be delivered to the wheel specified by rearWheelIds[0] than to the wheel
            specified by rearWheelIds[1]. The converse is true if #rearNegPosSplit < 0.5.
            */
            rearWheelIds:     [2] PxU32;

            /*
            \brief Ratio of torque split between front and rear wheels (>0.5 means more front, <0.5 means more to rear).
            
            \note Only applied to DIFF_TYPE_LS_4WD
            
            <b>Range:</b> [0, 1]<br>
            */
            frontRearSplit:   PxReal;

            /*
            \brief Ratio of torque split between front-negative and front-positive wheels (>0.5 means more to #frontWheelIds[0], <0.5 means more to #frontWheelIds[1]).
            
            \note Only applied to DIFF_TYPE_LS_4WD and DIFF_TYPE_LS_FRONTWD
            
            <b>Range:</b> [0, 1]<br>
            */
            frontNegPosSplit: PxReal;

            /*
            \brief Ratio of torque split between rear-negative wheel and rear-positive wheels (>0.5 means more to #rearWheelIds[0], <0.5 means more to #rearWheelIds[1]).
            
            \note Only applied to DIFF_TYPE_LS_4WD and eDIFF_TYPE_LS_REARWD
            
            <b>Range:</b> [0, 1]<br>
            */
            rearNegPosSplit:  PxReal;

            /*
            \brief Maximum allowed ratio of average front wheel rotation speed and rear wheel rotation speeds.
            The differential will divert more torque to the slower wheels when the bias is exceeded.
            
            \note Only applied to DIFF_TYPE_LS_4WD
            
            <b>Range:</b> [1, inf)<br>
            */
            centerBias:       PxReal;

            /*
            \brief Maximum allowed ratio of front-left and front-right wheel rotation speeds.
            The differential will divert more torque to the slower wheel when the bias is exceeded.
            
            \note Only applied to DIFF_TYPE_LS_4WD and DIFF_TYPE_LS_FRONTWD
            
            <b>Range:</b> [1, inf)<br>
            */
            frontBias:        PxReal;

            /*
            \brief Maximum allowed ratio of rear-left and rear-right wheel rotation speeds.
            The differential will divert more torque to the slower wheel when the bias is exceeded.
            
            \note Only applied to DIFF_TYPE_LS_4WD and DIFF_TYPE_LS_REARWD
            
            <b>Range:</b> [1, inf)<br>
            */
            rearBias:         PxReal;

            /*
            \brief Type of differential.
            
            <b>Range:</b> [DIFF_TYPE_LS_4WD, eDIFF_TYPE_LS_REARWD]<br>
            */
            type:             Enum;
        }

        /*
        \brief PxVehicleMultiWheelDriveDifferentialParams specifies the wheels that are to receive drive torque from the differential
        and the division of torque between the wheels that are connected to the differential.
        */
        PxVehicleMultiWheelDriveDifferentialParams :: struct {
            /*
            \brief torqueRatios describes the fraction of torque delivered to each wheel through the differential.
            \note Wheels not connected to the differential must receive zero torque.
            \note Wheels connected to the differential may receive a non-zero torque.
            \note The sum of the absolute of the ratios of all wheels must equal to 1.0.
            \note A negative torque ratio simulates a wheel with negative gearing applied.
            
            <b>Range:</b> [1, -1]<br>
            */
            torqueRatios:        [20] PxReal;

            /*
            \brief aveWheelSpeedRatios describes the contribution of each wheel to the average wheel speed measured at the clutch.
            \note Wheels not connected to the differential do not contribute to the average wheel speed measured at the clutch.
            \note Wheels connected to the differential may delivere a non-zero contribution to the average wheel speed measured at the clutch.
            \note The sum of all ratios of all wheels must equal to 1.0.
            
            <b>Range:</b> [0, 1]<br>
            */
            aveWheelSpeedRatios: [20] PxReal;
        }

        /*
        \brief PxVehicleFourWheelDriveDifferentialParams specifies the wheels that are to receive drive torque from the differential
        and the division of torque between the wheels that are connected to the differential.  Additionally, it specifies the biases
        and strength of a limited slip differential that operates on two wheels specified as front wheels and two wheels specified
        as rear wheels.
        */
        PxVehicleFourWheelDriveDifferentialParams :: struct {
            #as using pxvehiclemultiwheeldrivedifferentialparams: PxVehicleMultiWheelDriveDifferentialParams;

            /*
            \brief The ids of the two wheels considered by the differential to be the front pair.
            \note When the ratio of the rotational speeds of the front wheels exceeds frontBias, drive torque is diverted so
            that the ratio approaches the value specified by frontTarget.  When the bias is not breached, the drive torque
            is specified by the corresponding entries in PxVehicleMultiWheelDriveDifferentialParams::torqueRatios.
            */
            frontWheelIds: [2] PxU32;

            /*
            \brief The ids of the two wheels considered by the differential to be the rear pair.
            \note When the ratio of the rotational speeds of the rear wheels exceeds rearBias, drive torque is diverted  so
            that the ratio approaches the value specified by rearTarget. When the bias is not breached, the drive torque
            is specified by the corresponding entries in PxVehicleMultiWheelDriveDifferentialParams::torqueRatios.
            */
            rearWheelIds:  [2] PxU32;

            /*
            \brief The parameter frontBias specifies the maximum angular speed ratio of the two front wheels specified by frontWheelIds[2].
            \note If frontBias has value 0.0, the differential will not try to enforce any relationship between the rotational speeds of the two front wheels.
            \note If frontBias has value 0.0, the torque split between the front wheels is specified by the array torqueRatios.
            \note frontBias must have value 0.0 (deactivated limited slip) or be greater than 1.0 (activated limited slip) or be equal to 1.0 (locked axle).
            \note If frontBias has value greater than or equal to 1.0 then the array frontWheelIds must be specified and the corresponding entries of
            the isConnected[] array must be set true.
            \note If frontBias has value greater than or equal to 1.0 then frontTarget must also be specified.
            \note A locked axle may be achieved by setting frontBias and frontTarget to 1.0.
            \note A limited slip differential may be achieved by setting frontBias > 1.0 and frontBias > frontTarget > 1.0.
            */
            frontBias:     PxReal;

            /*
            \brief The parameter frontTarget specifies the target rotational speed ratio of the two front wheels in the event that the ratio exceeds frontBias and frontBias
            is configured for an activated limited slip or locked axle.
            \note frontTarget must be less than frontBias and greater than 1.0 to implement a limited slip differential.
            \note Set frontTarget and frontBias to 1.0 to implement a locked axle.
            */
            frontTarget:   PxReal;

            /*
            \brief The parameter rearBias specifies the maximum angular speed ratio of the two rear wheels specified by rearWheelIds[2].
            \note If rearBias has value 0.0, the differential will not try to enforce any relationship between the rotational speeds of the two rear wheels.
            \note If rearBias has value 0.0, the torque split between the rear wheels is specified by the array torqueRatios.
            \note rearBias must have value 0.0 (deactivated limited slip) or be greater than 1.0 (activated limited slip) or be equal to 1.0 (locked axle).
            \note If rearBias has value greater than or equal to 1.0 then the array rearWheelIds must be specified and the corresponding entries of
            the isConnected[] array must be set true.
            \note If rearBias has value greater than or equal to 1.0 then rearTarget must also be specified.
            \note A locked axle may be achieved by setting rearBias and rearTarget to 1.0.
            \note A limited slip differential may be achieved by setting rearBias > 1.0 and rearBias > rearTarget > 1.0
            */
            rearBias:      PxReal;

            /*
            \brief The parameter rearTarget specifies the target rotational speed ratio of the two rear wheels in the event that the ratio exceeds rearBias and rearBias
            is configured for an activated limited slip or locked axle.
            \note rearTarget must be less than rearBias and greater than 1.0 to implement a limited slip differential.
            \note Set rearTarget and rearBias to 1.0 to implement a locked axle.
            */
            rearTarget:    PxReal;

            /*
            \brief The parameter centerBias specifies the maximum angular speed ratio of the sum of the two front wheels and the sum of the two rear wheels,
            as specified by frontWheelIds[2] and rearWheelIds[2].
            \note If centerBias has value 0.0, the differential will not try to enforce any relationship between the rotational speeds of the front and rear wheels.
            \note If centerBias has value 0.0, the torque split between the front and rear rear wheels is specified by the array torqueRatios.
            \note centerBias must have value 0.0 (deactivated limited slip) or be greater than 1.0 (activated limited slip) or be equal to 1.0 (locked).
            \note If centerBias has value greater than or equal to 1.0 then the arrays frontWheelIds and rearWheelIds must be specified and the corresponding entries of
            the isConnected[] array must be set true.
            \note If centerBias has value greater than or equal to 1.0 then centerTarget must also be specified.
            \note A locked front/rear differential may be achieved by setting centerBias and centerTarget to 1.0.
            \note A limited slip differential may be achieved by setting centerBias > 1.0 and centerBias > centerTarget > 1.0
            */
            centerBias:    PxReal;

            /*
            \brief The parameter centerTarget specifies the target rotational speed ratio of the sum of the two front wheels and the sum of the two rear wheels
            in the event that the ratio exceeds centerBias and centerBias is configured for an activated limited slip.
            \note centerTarget must be less than centerBias and greater than 1.0 to implement a limited slip differential.
            \note Set centerTarget and centerBias to 1.0 to implement a locked differential.
            */
            centerTarget:  PxReal;

            /*
            \brief The parameter rate specifies how quickly the ratio of rotational speeds approaches the target rotational speed ratio.
            \note strength must be in range [0,PX_VEHICLE_FOUR_WHEEL_DIFF_MAXIMUM_STRENGTH].
            \note The ratio of rotational speeds is decremented each update by rate*dt until the ratio is equal to the target ratio.
            \note A value of 0 will result in a deactivated limited slip.
            \note A value of PX_VEHICLE_FOUR_WHEEL_DIFF_MAXIMUM_STRENGTH will result in instantaneous correction of the rotational speed ratios.
            */
            rate:          PxReal;
        }

        /*
        \brief A description of a tank differential.
        \note The wheels on a tank may be connected to the differential or not connected to the differential.
        \note The wheels on a tank track may be connected to a tank track or not connected to a tank track.
        \note Wheels connected to the differential but not to a tank track receive the torque split specified by the
        corresponding elements of PxVehicleMultiWheelDriveDifferentialParams::torqueRatios[].
        \note Wheels connected to a tank track but not to the differential receive no torque from the engine.
        \note Wheels connected to a tank track and to the differential receive the torque split specified by the
        corresponding elements of PxVehicleMultiWheelDriveDifferentialParams::torqueRatios[] multiplied by the corresponding
        thrust controller value. If the thrust controller has a negative value, the wheels will receive a torque that is negative
        with respect to the gearing ratio.
        \note The wheels in each tank track have a constraint applied to them to enforce the rule that they all have the same longitudinal speed
        at the contact point between the wheel and the tank track.
        */
        PxVehicleTankDriveDifferentialParams :: struct {
            #as using pxvehiclemultiwheeldrivedifferentialparams: PxVehicleMultiWheelDriveDifferentialParams;

            nbTracks:             PxU32; //!< The number of tracks
            thrustIdPerTrack:     [20] PxU32; //!< The id of the thrust that will  control the track. Must have value 0 or 1.
            nbWheelsPerTrack:     [20] PxU32; //!< The number of wheels in each track
            trackToWheelIds:      [20] PxU32; //!< The list of wheel ids for the ith tank track begins at wheelIdsInTrackOrder[trackToWheelIds[i]]

            wheelIdsInTrackOrder: [20] PxU32; //!< The list of all wheel ids in all tracks
        }

        PxVehicleClutchCommandResponseState :: struct {
            normalisedCommandResponse: PxReal;
            commandResponse:           PxReal;
        }

        PxVehicleEngineDriveThrottleCommandResponseState :: struct {
            commandResponse: PxReal;
        }

        PxVehicleEngineState :: struct {
            /*
            \brief The rotation speed of the engine (radians per second).
            
            <b>Unit:</b> radians / time
            */
            rotationSpeed: PxReal;
        }

        PxVehicleGearboxState :: struct {
            /*
            \brief Current gear
            */
            currentGear:    PxU32;

            /*
            \brief Target gear (different from current gear if a gear change is underway)
            */
            targetGear:     PxU32;

            /*
            \brief Reported time that has passed since gear change started.
            
            The special value PX_VEHICLE_NO_GEAR_SWITCH_PENDING denotes that there is currently
            no gear change underway.
            
            If a gear switch was initiated, the special value PX_VEHICLE_GEAR_SWITCH_INITIATED
            will be used temporarily but get translated to 0 in the gearbox update immediately.
            This state might only get encountered, if the vehicle component update is split into
            multiple sequences that do not run in one go.
            
            <b>Unit:</b> time
            */
            gearSwitchTime: PxReal;
        }

        PxVehicleAutoboxState :: struct {
            /*
            \brief Time that has lapsed since the last autobox gear shift.
            
            <b>Unit:</b> time
            */
            timeSinceLastShift:     PxReal;

            /*
            \brief Describes whether a gear shift triggered by the autobox is still in flight.
            */
            activeAutoboxGearShift: bool;
        }

        PxVehicleDifferentialState :: struct {
            /*
            \brief A list of wheel indices that are connected to the differential.
            */
            connectedWheels:                    [20] PxU32;

            /*
            \brief The number of wheels that are connected to the differential.
            */
            nbConnectedWheels:                  PxU32;

            /*
            \brief The fraction of available torque that is delivered to each wheel through the differential.
            \note If a wheel is not connected to the differential then the fraction of available torque delivered to that wheel will be zero.
            \note A negative torque ratio for a wheel indicates a negative gearing is to be applied to that wheel.
            \note The sum of the absolute value of each fraction must equal 1.0.
            */
            torqueRatiosAllWheels:              [20] PxReal;

            /*
            \brief The contribution of each wheel to the average wheel rotation speed measured at the clutch.
            \note If a wheel is not connected to the differential then the contribution to the average rotation speed measured at the clutch must be zero.
            \note The sum of all contributions must equal 1.0.
            */
            aveWheelSpeedContributionAllWheels: [20] PxReal;
        }

        /*
        \brief Specify groups of wheels that are to be constrained to have pre-determined angular velocity relationship.
        */
        PxVehicleWheelConstraintGroupState :: struct {
            nbGroups:                     PxU32; //!< The number of constraint groups in the vehicle
            nbWheelsPerGroup:             [20] PxU32; //!< The number of wheels in each group
            groupToWheelIds:              [20] PxU32; //!< The list of wheel ids for the ith group begins at wheelIdsInGroupOrder[groupToWheelIds[i]]

            wheelIdsInGroupOrder:         [20] PxU32; //!< The list of all wheel ids in constraint groups 
            wheelMultipliersInGroupOrder: [20] PxF32; //!< The constraint multipliers for each constraint group.
            nbWheelsInGroups:             PxU32; //!< The number of wheels in a constraint group.
        }

        /*
        \brief The clutch is modelled as two spinning plates with one connected to the wheels through the gearing and the other connected to the engine. The clutch slip is angular speed difference of the two plates.
        */
        PxVehicleClutchSlipState :: struct {
            /*
            \brief The slip at the clutch.
            
            <b>Unit:</b> radians / time
            */
            clutchSlip: PxReal;
        }

        /*
        \brief Distribute a steer response to the wheels of a vehicle.
        \note The steer angle applied to each wheel on the ith wheel is steerCommand * maxResponse * wheelResponseMultipliers[i].
        \note A typical use case is to set maxResponse to be the vehicle's maximum achievable steer angle
        that occurs when the steer command is equal to 1.0. The array wheelResponseMultipliers[i] would then be used
        to specify the maximum achievable steer angle per wheel as a fractional multiplier of the vehicle's maximum achievable steer angle.
        */
        PxVehicleSteerCommandResponseParams :: struct {
            #as using pxvehiclecommandresponseparams: PxVehicleCommandResponseParams;
        }

        /*
        \brief A description of a single axle that is to be affected by Ackermann steer correction.
        */
        PxVehicleAckermannParams :: struct {
            wheelIds:   [2] PxU32; //!< wheelIds[0] is the id of the wheel that is negative along the lateral axis, wheelIds[1] is the wheel id that is positive along the lateral axis.
            wheelBase:  PxReal; //!< wheelBase is the longitudinal distance between the axle that is affected by Ackermann correction and a reference axle.
            trackWidth: PxReal; //!< trackWidth is the width of the axle specified by #wheelIds
            strength:   PxReal; //!< is the strength of the correction with 0 denoting no correction and 1 denoting perfect correction.
        }

        /*
        \brief It is useful to know if a brake or drive torque is to be applied to a wheel.
        */
        PxVehicleWheelActuationState :: struct {
            isBrakeApplied: bool; //!< True if a brake torque is applied, false if not.
            isDriveApplied: bool; //!< True if a drive torque is applied, false if not.
        }

        PxVehicleWheelRigidBody1dState :: struct {
            /*
            \brief The rotation speed of the wheel around the lateral axis.
            
            <b>Unit:</b> radians / time
            */
            rotationSpeed:          PxReal;

            /*
            \brief The corrected rotation speed of the wheel around the lateral axis in radians per second.
            
            At low forward wheel speed, the wheel rotation speed can get unstable (depending on the tire
            model used) and, for example, oscillate. To integrate the wheel rotation angle, a (potentially)
            blended rotation speed is used which gets stored in #correctedRotationSpeed.
            
            <b>Unit:</b> radians / time
            
            \see PxVehicleSimulationContext::thresholdForwardSpeedForWheelAngleIntegration
            */
            correctedRotationSpeed: PxReal;

            /*
            \brief The accumulated angle of the wheel around the lateral axis in radians in range (-2*Pi,2*Pi)
            */
            rotationAngle:          PxReal;
        }

        PxVehicleWheelLocalPose :: struct {
            localPose: PxTransform; //!< The pose of the wheel in the rigid body frame.
        }

        PxVehicleWheelParams :: struct {
            /*
            \brief Radius of unit that includes metal wheel plus rubber tire.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> length
            */
            radius:      PxReal;

            /*
            \brief Half-width of unit that includes wheel plus tire.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> length
            */
            halfWidth:   PxReal;

            /*
            \brief Mass of unit that includes wheel plus tire.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass
            */
            mass:        PxReal;

            /*
            \brief Moment of inertia of unit that includes wheel plus tire about the rolling axis.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass * (length^2)
            */
            moi:         PxReal;

            /*
            \brief Damping rate applied to wheel.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> torque * time = mass * (length^2) / time
            */
            dampingRate: PxReal;
        }

        /*
        \brief PxVehicleTireDirectionState stores the world frame lateral and longtidinal axes of the tire after
        projecting the wheel pose in the world frame onto the road geometry plane (also in the world frame).
        */
        PxVehicleTireDirectionState :: struct {
            directions: [2] PxVec3;
        }

        /*
        \brief PxVehicleTireSpeedState stores the components of the instantaneous velocity of the rigid body at the tire contact point projected
        along the lateral and longitudinal axes of the tire.
        \see PxVehicleTireDirectionState
        */
        PxVehicleTireSpeedState :: struct {
            speedStates: [2] PxReal;
        }

        /*
        \brief The lateral and longitudinal tire slips.
        \see PxVehicleTireSpeedState
        */
        PxVehicleTireSlipState :: struct {
            slips: [2] PxReal;
        }

        /*
        \brief The load and friction experienced by a tire.
        */
        PxVehicleTireGripState :: struct {
            /*
            \brief The tire load
            
            <b>Unit:</b> force = mass * length / (time^2)
            */
            load:     PxReal;

            /*
            \brief The tire friction is the product of the road geometry friction and a friction response multiplier.
            */
            friction: PxReal;
        }

        /*
        \brief Camber angle of the tire relative to the ground plane.
        */
        PxVehicleTireCamberAngleState :: struct {
            camberAngle: PxReal;
        }

        /*
        \brief Prolonged low speeds in the lateral and longitudinal directions may be handled with "sticky" velocity constraints that activate after
        a speed below a threshold has been recorded for a threshold time.
        \see PxVehicleTireStickyParams
        \see PxVehicleTireSpeedState
        */
        PxVehicleTireStickyState :: struct {
            lowSpeedTime: [2] PxReal;
            activeStatus: [2] bool;
        }

        /*
        \brief The longitudinal/lateral forces/torques that develop on the tire.
        */
        PxVehicleTireForce :: struct {
            /*
            \brief The tire forces that develop along the tire's longitudinal and lateral directions. Specified in the world frame.
            */
            forces:         [2] PxVec3;

            /*
            \brief The tire torques that develop around the tire's longitudinal and lateral directions. Specified in the world frame.
            */
            torques:        [2] PxVec3;

            /*
            \brief The aligning moment may be propagated to a torque-driven steering controller.
            */
            aligningMoment: PxReal;

            /*
            \brief The torque to apply to the wheel's 1d rigid body.
            */
            wheelTorque:    PxReal;
        }

        /*
        \brief Forward the applicable set of control values for a direct drive vehicle to a command response state for each
        applicable control value.
        \note The applicable control values are brake, handbrake, throttle and steer.
        \see PxVehicleDirectDriveActuationStateComponent
        \see PxVehicleDirectDrivetrainComponent
        \see PxVehicleBrakeCommandLinearUpdate
        \see PxVehicleDirectDriveThrottleLinearCommandUpdate
        \see PxVehicleSteerCommandLinearUpdate
        \see PxVehicleAckermannSteerUpdate
        */
        PxVehicleDirectDriveCommandResponseComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicledirectdrivecommandresponsecomponent_vtable: *PxVehicleDirectDriveCommandResponseComponent_VTable;
        }
        PxVehicleDirectDriveCommandResponseComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForDirectDriveCommandResponseComponent: (this: *PxVehicleDirectDriveCommandResponseComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseParams: *PxVehicleSizedArrayData(PxVehicleBrakeCommandResponseParams), throttleResponseParams: **PxVehicleDirectDriveThrottleCommandResponseParams, steerResponseParams: **PxVehicleSteerCommandResponseParams, ackermannParams: *PxVehicleSizedArrayData(PxVehicleAckermannParams), commands: **PxVehicleCommandState, transmissionCommands: **PxVehicleDirectDriveTransmissionCommandState, rigidBodyState: **PxVehicleRigidBodyState, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseStates: *PxVehicleArrayData(PxReal), steerResponseStates: *PxVehicleArrayData(PxReal)) -> void #cpp_method;
        }
        PxVehicleDirectDriveCommandResponseComponent_getDataForDirectDriveCommandResponseComponent :: inline (this: *PxVehicleDirectDriveCommandResponseComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseParams: *PxVehicleSizedArrayData(PxVehicleBrakeCommandResponseParams), throttleResponseParams: **PxVehicleDirectDriveThrottleCommandResponseParams, steerResponseParams: **PxVehicleSteerCommandResponseParams, ackermannParams: *PxVehicleSizedArrayData(PxVehicleAckermannParams), commands: **PxVehicleCommandState, transmissionCommands: **PxVehicleDirectDriveTransmissionCommandState, rigidBodyState: **PxVehicleRigidBodyState, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseStates: *PxVehicleArrayData(PxReal), steerResponseStates: *PxVehicleArrayData(PxReal)) { this.pxvehicledirectdrivecommandresponsecomponent_vtable.getDataForDirectDriveCommandResponseComponent(this, axleDescription, brakeResponseParams, throttleResponseParams, steerResponseParams, ackermannParams, commands, transmissionCommands, rigidBodyState, brakeResponseStates, throttleResponseStates, steerResponseStates); }

        vtable :: (obj: *PxVehicleDirectDriveCommandResponseComponent) -> *PxVehicleDirectDriveCommandResponseComponent_VTable { return obj.pxvehicledirectdrivecommandresponsecomponent_vtable; }


        /*
        \brief Determine the actuation state for each wheel of a direct drive vehicle.
        \note The actuation state for each wheel contains a binary record of whether brake and drive torque are to be applied to the wheel.
        \see PxVehicleDirectDriveCommandResponseComponent
        \see PxVehicleDirectDrivetrainComponent
        \see PxVehicleDirectDriveActuationStateUpdate
        */
        PxVehicleDirectDriveActuationStateComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicledirectdriveactuationstatecomponent_vtable: *PxVehicleDirectDriveActuationStateComponent_VTable;
        }
        PxVehicleDirectDriveActuationStateComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForDirectDriveActuationStateComponent: (this: *PxVehicleDirectDriveActuationStateComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseStates: *PxVehicleArrayData(PxReal), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState)) -> void #cpp_method;
        }
        PxVehicleDirectDriveActuationStateComponent_getDataForDirectDriveActuationStateComponent :: inline (this: *PxVehicleDirectDriveActuationStateComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseStates: *PxVehicleArrayData(PxReal), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState)) { this.pxvehicledirectdriveactuationstatecomponent_vtable.getDataForDirectDriveActuationStateComponent(this, axleDescription, brakeResponseStates, throttleResponseStates, actuationStates); }

        vtable :: (obj: *PxVehicleDirectDriveActuationStateComponent) -> *PxVehicleDirectDriveActuationStateComponent_VTable { return obj.pxvehicledirectdriveactuationstatecomponent_vtable; }


        /*
        \brief Forward integrate the angular speed of each wheel on a vehicle by integrating the
        brake and drive torque applied to each wheel and the torque that develops on the tire as a response
        to the longitudinal tire force.
        \see PxVehicleDirectDriveUpdate
        */
        PxVehicleDirectDrivetrainComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicledirectdrivetraincomponent_vtable: *PxVehicleDirectDrivetrainComponent_VTable;
        }
        PxVehicleDirectDrivetrainComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForDirectDrivetrainComponent: (this: *PxVehicleDirectDrivetrainComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseStates: *PxVehicleArrayData(PxReal), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), tireForces: *PxVehicleArrayData(PxVehicleTireForce), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState)) -> void #cpp_method;
        }
        PxVehicleDirectDrivetrainComponent_getDataForDirectDrivetrainComponent :: inline (this: *PxVehicleDirectDrivetrainComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseStates: *PxVehicleArrayData(PxReal), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), tireForces: *PxVehicleArrayData(PxVehicleTireForce), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState)) { this.pxvehicledirectdrivetraincomponent_vtable.getDataForDirectDrivetrainComponent(this, axleDescription, brakeResponseStates, throttleResponseStates, wheelParams, actuationStates, tireForces, wheelRigidBody1dStates); }

        vtable :: (obj: *PxVehicleDirectDrivetrainComponent) -> *PxVehicleDirectDrivetrainComponent_VTable { return obj.pxvehicledirectdrivetraincomponent_vtable; }


        /*
        \brief Forward the applicable set of control values for a vehicle driven by an engine to a command response state for each
        applicable control value.
        
        If parameters for an autobox are provided, the autobox will determine if a gear change should begin in order to
        maintain a desired engine revs.
        
        \see PxVehicleBrakeCommandLinearUpdate
        \see PxVehicleClutchCommandResponseLinearUpdate
        \see PxVehicleEngineDriveThrottleCommandResponseUpdate
        \see PxVehicleSteerCommandLinearUpdate
        \see PxVehicleAckermannSteerUpdate
        \see PxVehicleAutoBoxUpdate
        \see PxVehicleGearCommandResponseUpdate
        */
        PxVehicleEngineDriveCommandResponseComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicleenginedrivecommandresponsecomponent_vtable: *PxVehicleEngineDriveCommandResponseComponent_VTable;
        }
        PxVehicleEngineDriveCommandResponseComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForEngineDriveCommandResponseComponent: (this: *PxVehicleEngineDriveCommandResponseComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseParams: *PxVehicleSizedArrayData(PxVehicleBrakeCommandResponseParams), steerResponseParams: **PxVehicleSteerCommandResponseParams, ackermannParams: *PxVehicleSizedArrayData(PxVehicleAckermannParams), gearboxParams: **PxVehicleGearboxParams, clutchResponseParams: **PxVehicleClutchCommandResponseParams, engineParams: **PxVehicleEngineParams, rigidBodyState: **PxVehicleRigidBodyState, engineState: **PxVehicleEngineState, autoboxParams: **PxVehicleAutoboxParams, commands: **PxVehicleCommandState, transmissionCommands: **PxVehicleEngineDriveTransmissionCommandState, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, steerResponseStates: *PxVehicleArrayData(PxReal), gearboxResponseState: **PxVehicleGearboxState, clutchResponseState: **PxVehicleClutchCommandResponseState, autoboxState: **PxVehicleAutoboxState) -> void #cpp_method;
        }
        PxVehicleEngineDriveCommandResponseComponent_getDataForEngineDriveCommandResponseComponent :: inline (this: *PxVehicleEngineDriveCommandResponseComponent, axleDescription: **PxVehicleAxleDescription, brakeResponseParams: *PxVehicleSizedArrayData(PxVehicleBrakeCommandResponseParams), steerResponseParams: **PxVehicleSteerCommandResponseParams, ackermannParams: *PxVehicleSizedArrayData(PxVehicleAckermannParams), gearboxParams: **PxVehicleGearboxParams, clutchResponseParams: **PxVehicleClutchCommandResponseParams, engineParams: **PxVehicleEngineParams, rigidBodyState: **PxVehicleRigidBodyState, engineState: **PxVehicleEngineState, autoboxParams: **PxVehicleAutoboxParams, commands: **PxVehicleCommandState, transmissionCommands: **PxVehicleEngineDriveTransmissionCommandState, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, steerResponseStates: *PxVehicleArrayData(PxReal), gearboxResponseState: **PxVehicleGearboxState, clutchResponseState: **PxVehicleClutchCommandResponseState, autoboxState: **PxVehicleAutoboxState) { this.pxvehicleenginedrivecommandresponsecomponent_vtable.getDataForEngineDriveCommandResponseComponent(this, axleDescription, brakeResponseParams, steerResponseParams, ackermannParams, gearboxParams, clutchResponseParams, engineParams, rigidBodyState, engineState, autoboxParams, commands, transmissionCommands, brakeResponseStates, throttleResponseState, steerResponseStates, gearboxResponseState, clutchResponseState, autoboxState); }

        vtable :: (obj: *PxVehicleEngineDriveCommandResponseComponent) -> *PxVehicleEngineDriveCommandResponseComponent_VTable { return obj.pxvehicleenginedrivecommandresponsecomponent_vtable; }


        /*
        \brief Compute the per wheel drive torque split of a multi-wheel drive differential.
        \see PxVehicleDifferentialStateUpdate
        */
        PxVehicleMultiWheelDriveDifferentialStateComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclemultiwheeldrivedifferentialstatecomponent_vtable: *PxVehicleMultiWheelDriveDifferentialStateComponent_VTable;
        }
        PxVehicleMultiWheelDriveDifferentialStateComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForMultiWheelDriveDifferentialStateComponent: (this: *PxVehicleMultiWheelDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, differentialParams: **PxVehicleMultiWheelDriveDifferentialParams, differentialState: **PxVehicleDifferentialState) -> void #cpp_method;
        }
        PxVehicleMultiWheelDriveDifferentialStateComponent_getDataForMultiWheelDriveDifferentialStateComponent :: inline (this: *PxVehicleMultiWheelDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, differentialParams: **PxVehicleMultiWheelDriveDifferentialParams, differentialState: **PxVehicleDifferentialState) { this.pxvehiclemultiwheeldrivedifferentialstatecomponent_vtable.getDataForMultiWheelDriveDifferentialStateComponent(this, axleDescription, differentialParams, differentialState); }

        vtable :: (obj: *PxVehicleMultiWheelDriveDifferentialStateComponent) -> *PxVehicleMultiWheelDriveDifferentialStateComponent_VTable { return obj.pxvehiclemultiwheeldrivedifferentialstatecomponent_vtable; }


        /*
        \brief Compute the per wheel drive torque split of a differential delivering torque to multiple wheels
        with limited slip applied to specified wheel pairs.
        \see PxVehicleDifferentialStateUpdate
        */
        PxVehicleFourWheelDriveDifferentialStateComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclefourwheeldrivedifferentialstatecomponent_vtable: *PxVehicleFourWheelDriveDifferentialStateComponent_VTable;
        }
        PxVehicleFourWheelDriveDifferentialStateComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForFourWheelDriveDifferentialStateComponent: (this: *PxVehicleFourWheelDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, differentialParams: **PxVehicleFourWheelDriveDifferentialParams, wheelRigidbody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), differentialState: **PxVehicleDifferentialState, wheelConstraintGroupState: **PxVehicleWheelConstraintGroupState) -> void #cpp_method;
        }
        PxVehicleFourWheelDriveDifferentialStateComponent_getDataForFourWheelDriveDifferentialStateComponent :: inline (this: *PxVehicleFourWheelDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, differentialParams: **PxVehicleFourWheelDriveDifferentialParams, wheelRigidbody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), differentialState: **PxVehicleDifferentialState, wheelConstraintGroupState: **PxVehicleWheelConstraintGroupState) { this.pxvehiclefourwheeldrivedifferentialstatecomponent_vtable.getDataForFourWheelDriveDifferentialStateComponent(this, axleDescription, differentialParams, wheelRigidbody1dStates, differentialState, wheelConstraintGroupState); }

        vtable :: (obj: *PxVehicleFourWheelDriveDifferentialStateComponent) -> *PxVehicleFourWheelDriveDifferentialStateComponent_VTable { return obj.pxvehiclefourwheeldrivedifferentialstatecomponent_vtable; }


        /*
        \brief Compute the per wheel drive torque split of a tank drive differential.
        \see PxVehicleDifferentialStateUpdate
        */
        PxVehicleTankDriveDifferentialStateComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicletankdrivedifferentialstatecomponent_vtable: *PxVehicleTankDriveDifferentialStateComponent_VTable;
        }
        PxVehicleTankDriveDifferentialStateComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForTankDriveDifferentialStateComponent: (this: *PxVehicleTankDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, transmissionCommands: **PxVehicleTankDriveTransmissionCommandState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), differentialParams: **PxVehicleTankDriveDifferentialParams, differentialState: **PxVehicleDifferentialState, constraintGroupState: **PxVehicleWheelConstraintGroupState) -> void #cpp_method;
        }
        PxVehicleTankDriveDifferentialStateComponent_getDataForTankDriveDifferentialStateComponent :: inline (this: *PxVehicleTankDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, transmissionCommands: **PxVehicleTankDriveTransmissionCommandState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), differentialParams: **PxVehicleTankDriveDifferentialParams, differentialState: **PxVehicleDifferentialState, constraintGroupState: **PxVehicleWheelConstraintGroupState) { this.pxvehicletankdrivedifferentialstatecomponent_vtable.getDataForTankDriveDifferentialStateComponent(this, axleDescription, transmissionCommands, wheelParams, differentialParams, differentialState, constraintGroupState); }

        vtable :: (obj: *PxVehicleTankDriveDifferentialStateComponent) -> *PxVehicleTankDriveDifferentialStateComponent_VTable { return obj.pxvehicletankdrivedifferentialstatecomponent_vtable; }


        /*
        \deprecated This API was introduced with the new Vehicle API for transition purposes but will be removed in a future version.
        
        \brief Compute the per wheel drive torque split of a four wheel drive differential.
        \see PxVehicleDifferentialStateUpdate
        */
        PxVehicleLegacyFourWheelDriveDifferentialStateComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclelegacyfourwheeldrivedifferentialstatecomponent_vtable: *PxVehicleLegacyFourWheelDriveDifferentialStateComponent_VTable;
        }
        PxVehicleLegacyFourWheelDriveDifferentialStateComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForLegacyFourWheelDriveDifferentialStateComponent: (this: *PxVehicleLegacyFourWheelDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, differentialParams: **PxVehicleFourWheelDriveDifferentialLegacyParams, wheelRigidbody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), differentialState: **PxVehicleDifferentialState) -> void #cpp_method;
        }
        PxVehicleLegacyFourWheelDriveDifferentialStateComponent_getDataForLegacyFourWheelDriveDifferentialStateComponent :: inline (this: *PxVehicleLegacyFourWheelDriveDifferentialStateComponent, axleDescription: **PxVehicleAxleDescription, differentialParams: **PxVehicleFourWheelDriveDifferentialLegacyParams, wheelRigidbody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), differentialState: **PxVehicleDifferentialState) { this.pxvehiclelegacyfourwheeldrivedifferentialstatecomponent_vtable.getDataForLegacyFourWheelDriveDifferentialStateComponent(this, axleDescription, differentialParams, wheelRigidbody1dStates, differentialState); }

        vtable :: (obj: *PxVehicleLegacyFourWheelDriveDifferentialStateComponent) -> *PxVehicleLegacyFourWheelDriveDifferentialStateComponent_VTable { return obj.pxvehiclelegacyfourwheeldrivedifferentialstatecomponent_vtable; }


        /*
        \brief Determine the actuation state for each wheel for a vehicle propelled by engine torque.
        \note The actuation state for each wheel contains a binary record of whether brake and drive torque are to be applied to the wheel.
        \see PxVehicleEngineDriveActuationStateUpdate
        */
        PxVehicleEngineDriveActuationStateComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicleenginedriveactuationstatecomponent_vtable: *PxVehicleEngineDriveActuationStateComponent_VTable;
        }
        PxVehicleEngineDriveActuationStateComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForEngineDriveActuationStateComponent: (this: *PxVehicleEngineDriveActuationStateComponent, axleDescription: **PxVehicleAxleDescription, gearboxParams: **PxVehicleGearboxParams, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, gearboxState: **PxVehicleGearboxState, differentialState: **PxVehicleDifferentialState, clutchResponseState: **PxVehicleClutchCommandResponseState, actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState)) -> void #cpp_method;
        }
        PxVehicleEngineDriveActuationStateComponent_getDataForEngineDriveActuationStateComponent :: inline (this: *PxVehicleEngineDriveActuationStateComponent, axleDescription: **PxVehicleAxleDescription, gearboxParams: **PxVehicleGearboxParams, brakeResponseStates: *PxVehicleArrayData(PxReal), throttleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, gearboxState: **PxVehicleGearboxState, differentialState: **PxVehicleDifferentialState, clutchResponseState: **PxVehicleClutchCommandResponseState, actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState)) { this.pxvehicleenginedriveactuationstatecomponent_vtable.getDataForEngineDriveActuationStateComponent(this, axleDescription, gearboxParams, brakeResponseStates, throttleResponseState, gearboxState, differentialState, clutchResponseState, actuationStates); }

        vtable :: (obj: *PxVehicleEngineDriveActuationStateComponent) -> *PxVehicleEngineDriveActuationStateComponent_VTable { return obj.pxvehicleenginedriveactuationstatecomponent_vtable; }


        /*
        \brief Forward integrate the angular speed of each wheel and of the engine, accounting for the
        state of the clutch, gearbox and differential.
        \see PxVehicleGearboxUpdate
        \see PxVehicleEngineDrivetrainUpdate
        */
        PxVehicleEngineDrivetrainComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicleenginedrivetraincomponent_vtable: *PxVehicleEngineDrivetrainComponent_VTable;
        }
        PxVehicleEngineDrivetrainComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForEngineDrivetrainComponent: (this: *PxVehicleEngineDrivetrainComponent, axleDescription: **PxVehicleAxleDescription, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), engineParams: **PxVehicleEngineParams, clutchParams: **PxVehicleClutchParams, gearboxParams: **PxVehicleGearboxParams, brakeResponseStates: *PxVehicleArrayData(PxReal), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), tireForces: *PxVehicleArrayData(PxVehicleTireForce), throttleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, clutchResponseState: **PxVehicleClutchCommandResponseState, differentialState: **PxVehicleDifferentialState, constraintGroupState: **PxVehicleWheelConstraintGroupState, wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), engineState: **PxVehicleEngineState, gearboxState: **PxVehicleGearboxState, clutchState: **PxVehicleClutchSlipState) -> void #cpp_method;
        }
        PxVehicleEngineDrivetrainComponent_getDataForEngineDrivetrainComponent :: inline (this: *PxVehicleEngineDrivetrainComponent, axleDescription: **PxVehicleAxleDescription, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), engineParams: **PxVehicleEngineParams, clutchParams: **PxVehicleClutchParams, gearboxParams: **PxVehicleGearboxParams, brakeResponseStates: *PxVehicleArrayData(PxReal), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), tireForces: *PxVehicleArrayData(PxVehicleTireForce), throttleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, clutchResponseState: **PxVehicleClutchCommandResponseState, differentialState: **PxVehicleDifferentialState, constraintGroupState: **PxVehicleWheelConstraintGroupState, wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), engineState: **PxVehicleEngineState, gearboxState: **PxVehicleGearboxState, clutchState: **PxVehicleClutchSlipState) { this.pxvehicleenginedrivetraincomponent_vtable.getDataForEngineDrivetrainComponent(this, axleDescription, wheelParams, engineParams, clutchParams, gearboxParams, brakeResponseStates, actuationStates, tireForces, throttleResponseState, clutchResponseState, differentialState, constraintGroupState, wheelRigidBody1dStates, engineState, gearboxState, clutchState); }

        vtable :: (obj: *PxVehicleEngineDrivetrainComponent) -> *PxVehicleEngineDrivetrainComponent_VTable { return obj.pxvehicleenginedrivetraincomponent_vtable; }


        PxVehiclePhysXRigidActorParams :: struct {
            rigidBodyParams: *PxVehicleRigidBodyParams;
            physxActorName:  *u8;
        }

        PxVehiclePhysXRigidActorShapeParams :: struct {
            geometry:             *PxGeometry;
            localPose:            *PxTransform;
            material:             *PxMaterial;
            flags:                PxShapeFlags;
            simulationFilterData: PxFilterData;
            queryFilterData:      PxFilterData;
        }

        PxVehiclePhysXWheelParams :: struct {
            axleDescription: *PxVehicleAxleDescription;
            wheelParams:     *PxVehicleWheelParams;
        }

        PxVehiclePhysXWheelShapeParams :: struct {
            material:             *PxMaterial;
            flags:                PxShapeFlags;
            simulationFilterData: PxFilterData;
            queryFilterData:      PxFilterData;
        }

        /*
        \brief Work items at the beginning of an update step for a PhysX actor based vehicle.
        
        Includes:
        - Waking the actor up if it is sleeping and a throttle or steer command is issued.
        - Clearing certain states if the actor is sleeping.
        - Reading the state from the PhysX actor and copy to the vehicle internal state.
        
        \see PxVehiclePhysxActorWakeup PxVehiclePhysxActorSleepCheck PxVehicleReadRigidBodyStateFromPhysXActor
        */
        PxVehiclePhysXActorBeginComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclephysxactorbegincomponent_vtable: *PxVehiclePhysXActorBeginComponent_VTable;
        }
        PxVehiclePhysXActorBeginComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForPhysXActorBeginComponent: (this: *PxVehiclePhysXActorBeginComponent, axleDescription: **PxVehicleAxleDescription, commands: **PxVehicleCommandState, transmissionCommands: **PxVehicleEngineDriveTransmissionCommandState, gearParams: **PxVehicleGearboxParams, gearState: **PxVehicleGearboxState, engineParams: **PxVehicleEngineParams, physxActor: **PxVehiclePhysXActor, physxSteerState: **PxVehiclePhysXSteerState, physxConstraints: **PxVehiclePhysXConstraints, rigidBodyState: **PxVehicleRigidBodyState, wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), engineState: **PxVehicleEngineState) -> void #cpp_method;
        }
        PxVehiclePhysXActorBeginComponent_getDataForPhysXActorBeginComponent :: inline (this: *PxVehiclePhysXActorBeginComponent, axleDescription: **PxVehicleAxleDescription, commands: **PxVehicleCommandState, transmissionCommands: **PxVehicleEngineDriveTransmissionCommandState, gearParams: **PxVehicleGearboxParams, gearState: **PxVehicleGearboxState, engineParams: **PxVehicleEngineParams, physxActor: **PxVehiclePhysXActor, physxSteerState: **PxVehiclePhysXSteerState, physxConstraints: **PxVehiclePhysXConstraints, rigidBodyState: **PxVehicleRigidBodyState, wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), engineState: **PxVehicleEngineState) { this.pxvehiclephysxactorbegincomponent_vtable.getDataForPhysXActorBeginComponent(this, axleDescription, commands, transmissionCommands, gearParams, gearState, engineParams, physxActor, physxSteerState, physxConstraints, rigidBodyState, wheelRigidBody1dStates, engineState); }

        vtable :: (obj: *PxVehiclePhysXActorBeginComponent) -> *PxVehiclePhysXActorBeginComponent_VTable { return obj.pxvehiclephysxactorbegincomponent_vtable; }


        /*
        \brief Work items at the end of an update step for a PhysX actor based vehicle.
        
        Includes:
        - Writing vehicle internal state to the PhysX actor.
        - Keeping the vehicle awake if certain criteria are met.
        */
        PxVehiclePhysXActorEndComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclephysxactorendcomponent_vtable: *PxVehiclePhysXActorEndComponent_VTable;
        }
        PxVehiclePhysXActorEndComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForPhysXActorEndComponent: (this: *PxVehiclePhysXActorEndComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), wheelShapeLocalPoses: *PxVehicleArrayData(PxTransform), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), wheelLocalPoses: *PxVehicleArrayData(PxVehicleWheelLocalPose), gearState: **PxVehicleGearboxState, throttle: **PxReal, physxActor: **PxVehiclePhysXActor) -> void #cpp_method;
        }
        PxVehiclePhysXActorEndComponent_getDataForPhysXActorEndComponent :: inline (this: *PxVehiclePhysXActorEndComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), wheelShapeLocalPoses: *PxVehicleArrayData(PxTransform), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), wheelLocalPoses: *PxVehicleArrayData(PxVehicleWheelLocalPose), gearState: **PxVehicleGearboxState, throttle: **PxReal, physxActor: **PxVehiclePhysXActor) { this.pxvehiclephysxactorendcomponent_vtable.getDataForPhysXActorEndComponent(this, axleDescription, rigidBodyState, wheelParams, wheelShapeLocalPoses, wheelRigidBody1dStates, wheelLocalPoses, gearState, throttle, physxActor); }

        vtable :: (obj: *PxVehiclePhysXActorEndComponent) -> *PxVehiclePhysXActorEndComponent_VTable { return obj.pxvehiclephysxactorendcomponent_vtable; }


        /*
        \brief A description of the PhysX models employed to resolve suspension limit constraints.
        \see PxVehiclePhysXConstraintState
        */
        PxVehiclePhysXSuspensionLimitConstraintParams :: struct {
            /*
            \brief restitution is used by the restitution model used to generate a target velocity when resolving suspension limit
            constraints.
            \note A value of 0.0 means that the restitution model is not employed.
            \note Restitution has no effect if directionForSuspensionLimitConstraint has value Enum::eNONE.
            \see Px1DConstraintFlag::eRESTITUTION
            \see Px1DConstraint::RestitutionModifiers::restitution
            */
            restitution:                           PxReal;

            /*
            \brief Set the direction to apply a constraint impulse when the suspension cannot place the wheel on the ground
            and simultaneously respect the limits of suspension travel. The choices are to push along the ground normal to resolve the
            geometric error or to push along the suspension direction. The former choice can be thought of as mimicing a force applied
            by the tire's contact with the ground, while the latter can be thought of as mimicing a force arising from a suspension limit spring.
            When the ground normal and the suspension direction are approximately aligned, both do an equivalent job of maintaining the wheel above
            the ground. When the vehicle is on its side, eSUSPENSION does a better job of keeping the wheels above
            the ground but comes at the cost of an unnaturally strong torque that can lead to unwanted self-righting behaviour.
            eROAD_GEOMETRY_NORMAL is a good choice to avoid self-righting behaviour and still do a reasonable job at maintaining
            the wheel above the ground in the event that the vehicle is tending towards a roll onto its side.
            eNONE should be chosen if it is desired that no extra impulse is applied when the suspension alone cannot keep the wheels above
            the ground plane.
            */
            DirectionSpecifier :: enum s32 {
                SUSPENSION           :: 0;
                ROAD_GEOMETRY_NORMAL :: 1;
                NONE                 :: 2;

                eSUSPENSION           :: SUSPENSION;
                eROAD_GEOMETRY_NORMAL :: ROAD_GEOMETRY_NORMAL;
                eNONE                 :: NONE;
            }

            directionForSuspensionLimitConstraint: DirectionSpecifier;
        }

        /*
        \brief A description of the number of PxConstraintConnector instances per vehicle required to maintain suspension limit
        and sticky tire instances.
        */
        PxVehiclePhysXConstraintLimits :: struct {
            Enum :: enum s32 {
                DOFS_PER_PXCONSTRAINT   :: 12;
                DOFS_PER_WHEEL          :: 3;
                WHEELS_PER_PXCONSTRAINT :: 4;
                CONSTRAINTS_PER_VEHICLE :: 5;

                eNB_DOFS_PER_PXCONSTRAINT   :: DOFS_PER_PXCONSTRAINT;
                eNB_DOFS_PER_WHEEL          :: DOFS_PER_WHEEL;
                eNB_WHEELS_PER_PXCONSTRAINT :: WHEELS_PER_PXCONSTRAINT;
                eNB_CONSTRAINTS_PER_VEHICLE :: CONSTRAINTS_PER_VEHICLE;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        /*
        \brief PxVehiclePhysXConstraintState is a data structure used to write
        constraint data to the internal state of the associated PxScene.
        \see Px1dConstraint
        */
        PxVehiclePhysXConstraintState :: struct {
            /*
            \brief a boolean describing whether to trigger a low speed constraint along the tire longitudinal and lateral directions.
            */
            tireActiveStatus:   [2] bool;

            /*
            \brief linear component of velocity jacobian in world space for the tire's longitudinal and lateral directions.
            */
            tireLinears:        [2] PxVec3;

            /*
            \brief angular component of velocity jacobian in world space for the tire's longitudinal and lateral directions.
            */
            tireAngulars:       [2] PxVec3;

            /*
            \brief damping coefficient applied to the tire's longitudinal and lateral velocities.
            
            The constraint sets a target velocity of 0 and the damping coefficient will impact the size of the
            impulse applied to reach the target. Since damping acts as a stiffness with respect to the velocity,
            too large a value can cause instabilities.
            */
            tireDamping:        [2] PxReal;

            /*
            \brief a boolean describing whether to trigger a suspension limit constraint.
            */
            suspActiveStatus:   bool;

            /*
            \brief linear component of velocity jacobian in the world frame.
            */
            suspLinear:         PxVec3;

            /*
            \brief angular component of velocity jacobian in the world frame.
            */
            suspAngular:        PxVec3;

            /*
            \brief the excess suspension compression to be resolved by the constraint that cannot be resolved due to the travel limit
            of the suspension spring.
            
            \note The expected error value is the excess suspension compression projected onto the ground plane normal and should have
            a negative sign.
            */
            suspGeometricError: PxReal;

            /*
            \brief restitution value of the restitution model used to generate a target velocity that will resolve the geometric error.
            \note A value of 0.0 means that the restitution model is not employed.
            \see Px1DConstraintFlag::eRESTITUTION
            \see Px1DConstraint::RestitutionModifiers::restitution
            */
            restitution:        PxReal;
        }

        PxVehicleConstraintConnector :: struct {
            #as using pxconstraintconnector: PxConstraintConnector;

            mVehicleConstraintState: *PxVehiclePhysXConstraintState;
        }

        /*
        \brief A mapping between constraint state data and the associated PxConstraint instances.
        */
        PxVehiclePhysXConstraints :: struct {
            /*
            \brief PxVehiclePhysXConstraintComponent writes to the constraintStates array and a
            callback invoked by PxScene::simulate() reads a portion from it for a block of wheels
            and writes that portion to an associated PxConstraint instance.
            */
            constraintStates:     [20] PxVehiclePhysXConstraintState;

            /*
            \brief PxVehiclePhysXConstraintComponent writes to the constraintStates array and a
            callback invoked by PxScene::simulate() reads a portion from it for a block of wheels
            and writes that portion to an associated PxConstraint instance.
            */
            constraints:          [5] *PxConstraint;

            /*
            \brief A constraint connector is necessary to connect each PxConstraint to a portion of the constraintStates array.
            */
            constraintConnectors: [5] *PxVehicleConstraintConnector;
        }

        PxVehicleSuspensionParams :: struct {
            /*
            \brief suspensionAttachment specifies the wheel pose at maximum compression.
            \note suspensionAttachment is specified in the frame of the rigid body.
            \note camber, steer and toe angles are all applied in the suspension frame.
            */
            suspensionAttachment: PxTransform;

            /*
            \brief suspensionTravelDir specifies the direction of suspension travel.
            \note suspensionTravelDir is specified in the frame of the rigid body.
            */
            suspensionTravelDir:  PxVec3;

            /*
            \brief suspensionTravelDist is the maximum distance that the suspenson can elongate along #suspensionTravelDir
            from the pose specified by #suspensionAttachment.
            \note The position suspensionAttachment.p + #suspensionTravelDir*#suspensionTravelDist corresponds to the
            the suspension at maximum droop in the rigid body frame.
            */
            suspensionTravelDist: PxReal;

            /*
            \brief wheelAttachment is the pose of the wheel in the suspension frame.
            \note The rotation angle around the wheel's lateral axis is applied in the wheel attachment frame.
            */
            wheelAttachment:      PxTransform;
        }

        PxVehicleSuspensionJounceCalculationType :: struct {
            Enum :: enum s32 {
                RAYCAST :: 0;
                SWEEP   :: 1;
                MAX_NB  :: 2;

                eRAYCAST :: RAYCAST;
                eSWEEP   :: SWEEP;
                eMAX_NB  :: MAX_NB;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        PxVehicleSuspensionStateCalculationParams :: struct {
            suspensionJounceCalculationType:  PxVehicleSuspensionJounceCalculationType.Enum;

            /*
            \brief Limit the suspension expansion dynamics.
            
            If a hit with the ground is detected, the suspension jounce will be set such that the wheel
            is placed on the ground. This can result in large changes to jounce within a single
            simulation frame, if the ground surface has high frequency or if the simulation time step
            is large. As a result, large damping forces can evolve and cause undesired behavior. If this
            parameter is set to true, the suspension expansion speed will be limited to what can be
            achieved given the time step, suspension stiffness etc. As a consequence, handling of the
            vehicle will be affected as the wheel might loose contact with the ground more easily.
            */
            limitSuspensionExpansionVelocity: bool;
        }

        /*
        \brief Compliance describes how toe and camber angle and force application points are affected by suspension compression.
        \note Each compliance term is in the form of a graph with up to 3 points.
        \note Each point in the graph has form (jounce/suspensionTravelDist, complianceValue).
        \note The sequence of points must respresent monotonically increasing values of jounce.
        \note The compliance value can be computed by linear interpolation.
        \note If any graph has zero points in it, a value of 0.0 is used for the compliance value.
        \note If any graph has 1 point in it, the compliance value of that point is used directly.
        */
        PxVehicleSuspensionComplianceParams :: struct {
            /*
            \brief A graph of toe angle against jounce/suspensionTravelDist with the toe angle expressed in radians.
            \note The toe angle is applied in the suspension frame.
            */
            wheelToeAngle:     PxVehicleFixedSizeLookupTable(PxReal, UnknownTemplateArgumentPlaceholder) = 3;

            /*
            \brief A graph of camber angle against jounce/suspensionTravelDist with the camber angle expressed in radians.
            \note The camber angle is applied in the suspension frame.
            */
            wheelCamberAngle:  PxVehicleFixedSizeLookupTable(PxReal, UnknownTemplateArgumentPlaceholder) = 3;

            /*
            \brief Suspension forces are applied at an offset from the suspension frame. suspForceAppPoint
            specifies the (X, Y, Z) components of that offset as a function of jounce/suspensionTravelDist.
            */
            suspForceAppPoint: PxVehicleFixedSizeLookupTable(PxVec3, UnknownTemplateArgumentPlaceholder) = 3;

            /*
            \brief Tire forces are applied at an offset from the suspension frame. tireForceAppPoint
            specifies the (X, Y, Z) components of that offset as a function of jounce/suspensionTravelDist.
            */
            tireForceAppPoint: PxVehicleFixedSizeLookupTable(PxVec3, UnknownTemplateArgumentPlaceholder) = 3;
        }

        /*
        \brief Suspension force is computed by converting suspenson state to suspension force under the assumption of a linear spring.
        \see PxVehicleSuspensionForceUpdate
        */
        PxVehicleSuspensionForceParams :: struct {
            /*
            \brief Spring strength of suspension.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass / (time^2)
            */
            stiffness:  PxReal;

            /*
            \brief Spring damper rate of suspension.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> mass / time
            */
            damping:    PxReal;

            /*
            \brief Part of the vehicle mass that is supported by the suspension spring.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass
            */
            sprungMass: PxReal;
        }

        /*
        \deprecated This API was introduced with the new Vehicle API for transition purposes but will be removed in a future version.
        
        \brief Suspension force is computed by converting suspenson state to suspension force under the assumption of a linear spring.
        \see PxVehicleSuspensionLegacyForceUpdate
        */
        PxVehicleSuspensionForceLegacyParams :: struct {
            /*
            \brief Spring strength of suspension.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass / (time^2)
            */
            stiffness:    PxReal;

            /*
            \brief Spring damper rate of suspension.
            
            <b>Range:</b> [0, inf)<br>
            <b>Unit:</b> mass / time
            */
            damping:      PxReal;

            /*
            \brief The suspension compression that balances the gravitational force acting on the sprung mass.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> length
            */
            restDistance: PxReal;

            /*
            \brief The mass supported by the suspension spring.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass
            */
            sprungMass:   PxReal;
        }

        /*
        \brief The purpose of the anti-roll bar is to generate a torque to apply to the vehicle's rigid body that will reduce the jounce difference arising
        between any pair of chosen wheels. If the chosen wheels share an axle, the anti-roll bar will attempt to reduce the roll angle of the vehicle's rigid body.
        Alternatively, if the chosen wheels are the front and rear wheels along one side of the vehicle, the anti-roll bar will attempt to reduce the pitch angle of the
        vehicle's rigid body.
        */
        PxVehicleAntiRollForceParams :: struct {
            /*
            \brief The anti-roll bar connects two wheels with indices wheel0 and wheel1
            \note wheel0 and wheel1 may be chosen to have the effect of an anti-dive bar or to have the effect of an anti-roll bar.
            */
            wheel0:    PxU32;

            /*
            \brief The anti-roll bar connects two wheels with indices wheel0 and wheel1
            \note wheel0 and wheel1 may be chosen to have the effect of an anti-dive bar or to have the effect of an anti-roll bar.
            */
            wheel1:    PxU32;

            /*
            \brief The linear stiffness of the anti-roll bar.
            \note A positive stiffness will work to reduce the discrepancy in jounce between wheel0 and wheel1.
            \note A negative stiffness will work to increase the discrepancy in jounce between wheel0 and wheel1.
            
            <b>Unit:</b> mass / (time^2)
            */
            stiffness: PxReal;
        }

        /*
        
        */
        PxVehicleSuspensionState :: struct {
            /*
            \brief jounce is the distance from maximum droop.
            \note jounce is positive semi-definite
            \note A value of 0.0 represents the suspension at maximum droop and zero suspension force.
            \note A value of suspensionTravelDist represents the suspension at maximum compression.
            \note jounce is clamped in range [0, suspensionTravelDist].
            */
            jounce:      PxReal;

            /*
            \brief jounceSpeed is the rate of change of jounce.
            */
            jounceSpeed: PxReal;

            /*
            \brief separation holds extra information about the contact state of the wheel with the ground.
            
            If the suspension travel range is enough to place the wheel on the ground, then separation will be 0.
            If separation holds a negative value, then the wheel penetrates into the ground at maximum compression
            as well as maximum droop. The suspension would need to go beyond maximum compression (ground normal
            pointing in opposite direction of suspension) or beyond maximum droop (ground normal pointing in same
            direction as suspension) to place the wheel on the ground. In that case the separation value defines
            how much the wheel penetrates into the ground along the ground plane normal. This penetration may be
            resolved by using a constraint that simulates the effect of a bump stop.
            If separation holds a positive value, then the wheel does not penetrate the ground at maximum droop
            but can not touch the ground because the suspension would need to expand beyond max droop to reach it
            or because the suspension could not expand fast enough to reach the ground.
            */
            separation:  PxReal;
        }

        /*
        \brief The effect of suspension compliance on toe and camber angle and on the tire and suspension force application points.
        */
        PxVehicleSuspensionComplianceState :: struct {
            /*
            \brief The toe angle in radians that arises from suspension compliance.
            \note toe is expressed in the suspension frame.
            */
            toe:               PxReal;

            /*
            \brief The camber angle in radians that arises from suspension compliance.
            \note camber is expressed in the suspension frame.
            */
            camber:            PxReal;

            /*
            \brief The tire force application point that arises from suspension compliance.
            \note tireForceAppPoint is expressed in the suspension frame.
            */
            tireForceAppPoint: PxVec3;

            /*
            \brief The suspension force application point that arises from suspension compliance.
            \note suspForceAppPoint is expressed in the suspension frame.
            */
            suspForceAppPoint: PxVec3;
        }

        /*
        \brief The force and torque for a single suspension to apply to the vehicle's rigid body.
        */
        PxVehicleSuspensionForce :: struct {
            /*
            \brief The force to apply to the rigid body.
            \note force is expressed in the world frame.
            
            <b>Unit:</b> mass * length / (time^2)
            */
            force:       PxVec3;

            /*
            \brief The torque to apply to the rigid body.
            \note torque is expressed in the world frame.
            
            <b>Unit:</b> mass * (length^2) / (time^2)
            */
            torque:      PxVec3;

            /*
            \brief The component of force that lies along the normal of the plane under the wheel.
            \note normalForce may be used by the tire model as the tire load.
            
            <b>Unit:</b> mass * length / (time^2)
            */
            normalForce: PxReal;
        }

        /*
        \brief The anti-roll torque of all anti-roll bars accumulates in a single torque to apply
        to the vehicle's rigid body.
        */
        PxVehicleAntiRollTorque :: struct {
            /*
            \brief The accumulated torque to apply to the rigid body.
            \note antiRollTorque is expressed in the world frame.
            
            <b>Unit:</b> mass * (length^2) / (time^2)
            */
            antiRollTorque: PxVec3;
        }

        PxVehiclePhysXConstraintComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclephysxconstraintcomponent_vtable: *PxVehiclePhysXConstraintComponent_VTable;
        }
        PxVehiclePhysXConstraintComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForPhysXConstraintComponent: (this: *PxVehiclePhysXConstraintComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyState: **PxVehicleRigidBodyState, suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspensionLimitParams: *PxVehicleArrayData(PxVehiclePhysXSuspensionLimitConstraintParams), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), wheelRoadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), constraints: **PxVehiclePhysXConstraints) -> void #cpp_method;
        }
        PxVehiclePhysXConstraintComponent_getDataForPhysXConstraintComponent :: inline (this: *PxVehiclePhysXConstraintComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyState: **PxVehicleRigidBodyState, suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspensionLimitParams: *PxVehicleArrayData(PxVehiclePhysXSuspensionLimitConstraintParams), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), wheelRoadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), constraints: **PxVehiclePhysXConstraints) { this.pxvehiclephysxconstraintcomponent_vtable.getDataForPhysXConstraintComponent(this, axleDescription, rigidBodyState, suspensionParams, suspensionLimitParams, suspensionStates, suspensionComplianceStates, wheelRoadGeomStates, tireDirectionStates, tireStickyStates, constraints); }

        vtable :: (obj: *PxVehiclePhysXConstraintComponent) -> *PxVehiclePhysXConstraintComponent_VTable { return obj.pxvehiclephysxconstraintcomponent_vtable; }


        /*
        \brief PhysX scene queries may be raycasts or sweeps.
        \note eNONE will result in no PhysX scene query. This option will not overwrite the associated PxVehicleRoadGeometryState.
        */
        PxVehiclePhysXRoadGeometryQueryType :: struct {
            Enum :: enum s32 {
                NONE    :: 0;
                RAYCAST :: 1;
                SWEEP   :: 2;
                MAX_NB  :: 3;

                eNONE    :: NONE;
                eRAYCAST :: RAYCAST;
                eSWEEP   :: SWEEP;
                eMAX_NB  :: MAX_NB;
            }
            __empty_struct_padding: u8; // C++ makes empty structs have length 1
        }

        /*
        \brief A description of type of PhysX scene query and the filter data to apply to the query.
        */
        PxVehiclePhysXRoadGeometryQueryParams :: struct {
            /*
            \brief The default filter data to use for the physx scene query.
            
            If per wheel filter data is provided in #filterDataEntries, then this member
            will be ignored.
            
            \see PxSceneQuerySystemBase::raycast
            \see PxSceneQuerySystemBase::sweep
            */
            defaultFilterData:     PxQueryFilterData;

            /*
            \brief Array of filter data entries (one per wheel) to use for the physx scene query.
            
            A null pointer is allowed in which case #defaultFilterData will be used for all wheels.
            
            \see PxSceneQuerySystemBase::raycast
            \see PxSceneQuerySystemBase::sweep
            */
            filterDataEntries:     *PxQueryFilterData;

            /*
            \brief A filter callback to be used by the physx scene query
            \note A null pointer is allowed.
            \see PxSceneQuerySystemBase::raycast
            \see PxSceneQuerySystemBase::sweep
            */
            filterCallback:        *PxQueryFilterCallback;

            /*
            \brief A description of the type of physx scene query to employ.
            \see PxSceneQuerySystemBase::raycast
            \see PxSceneQuerySystemBase::sweep
            */
            roadGeometryQueryType: PxVehiclePhysXRoadGeometryQueryType.Enum;
        }

        /*
        A mapping between PxMaterial and a friction value to be used by the tire model.
        \see PxVehiclePhysXMaterialFrictionParams
        */
        PxVehiclePhysXMaterialFriction :: struct {
            /*
            \brief A PxMaterial instance that is to be mapped to a friction value.
            */
            material: *PxMaterial;

            /*
            \brief A friction value that is to be mapped to a PxMaterial instance.
            \note friction must have value greater than or equal to zero.
            
            <b>Range:</b> [0, inf)<br>
            
            \see PxVehicleTireGripState::friction
            */
            friction: PxReal;
        }

        /*
        \brief A mappping between PxMaterial instance and friction for multiple PxMaterial intances.
        */
        PxVehiclePhysXMaterialFrictionParams :: struct {
            materialFrictions:   *PxVehiclePhysXMaterialFriction; //!< An array of mappings between PxMaterial and friction.
            nbMaterialFrictions: PxU32; //!< The number of mappings between PxMaterial and friction.
            defaultFriction:     PxReal; //!< A default friction value to be used in the event that the PxMaterial under the tire is not found in the array #materialFrictions.
        }

        PxVehiclePhysXRoadGeometrySceneQueryComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclephysxroadgeometryscenequerycomponent_vtable: *PxVehiclePhysXRoadGeometrySceneQueryComponent_VTable;
        }
        PxVehiclePhysXRoadGeometrySceneQueryComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForPhysXRoadGeometrySceneQueryComponent: (this: *PxVehiclePhysXRoadGeometrySceneQueryComponent, axleDescription: **PxVehicleAxleDescription, roadGeomParams: **PxVehiclePhysXRoadGeometryQueryParams, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), materialFrictionParams: *PxVehicleArrayData(PxVehiclePhysXMaterialFrictionParams), roadGeometryStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), physxRoadGeometryStates: *PxVehicleArrayData(PxVehiclePhysXRoadGeometryQueryState)) -> void #cpp_method;
        }
        PxVehiclePhysXRoadGeometrySceneQueryComponent_getDataForPhysXRoadGeometrySceneQueryComponent :: inline (this: *PxVehiclePhysXRoadGeometrySceneQueryComponent, axleDescription: **PxVehicleAxleDescription, roadGeomParams: **PxVehiclePhysXRoadGeometryQueryParams, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), materialFrictionParams: *PxVehicleArrayData(PxVehiclePhysXMaterialFrictionParams), roadGeometryStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), physxRoadGeometryStates: *PxVehicleArrayData(PxVehiclePhysXRoadGeometryQueryState)) { this.pxvehiclephysxroadgeometryscenequerycomponent_vtable.getDataForPhysXRoadGeometrySceneQueryComponent(this, axleDescription, roadGeomParams, steerResponseStates, rigidBodyState, wheelParams, suspensionParams, materialFrictionParams, roadGeometryStates, physxRoadGeometryStates); }

        vtable :: (obj: *PxVehiclePhysXRoadGeometrySceneQueryComponent) -> *PxVehiclePhysXRoadGeometrySceneQueryComponent_VTable { return obj.pxvehiclephysxroadgeometryscenequerycomponent_vtable; }


        PxVehiclePvdObjectHandles :: struct {}

        PxVehicleTireForceParams :: struct {
            /*
            \brief Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and
            flattens at large loads. latStiffX describes the minimum normalized load (load/restLoad) that gives a
            flat lateral stiffness response to load.
            \note A value of 0.0 indicates that the tire lateral stiffness is independent of load and will adopt
            the value #latStiffY for all values of tire load.
            */
            latStiffX:      PxReal;

            /*
            \brief Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and
            flattens at large loads. latStiffY describes the maximum possible value of lateral stiffness that occurs
            when (load/restLoad) >= #latStiffX.
            
            <b>Unit:</b> force per lateral slip = mass * length / (time^2)
            */
            latStiffY:      PxReal;

            /*
            \brief Tire Longitudinal stiffness
            \note Longitudinal force can be approximated as longStiff*longitudinalSlip.
            
            <b>Unit:</b> force per longitudinal slip = mass * length / (time^2)
            */
            longStiff:      PxReal;

            /*
            \brief Tire camber stiffness
            \note Camber force can be approximated as camberStiff*camberAngle.
            
            <b>Unit:</b> force per radian = mass * length / (time^2)
            */
            camberStiff:    PxReal;

            frictionVsSlip: [3] [2] PxReal; //3 (x,y) points

            /*
            \brief The rest load is the load that develops on the tire when the vehicle is at rest on a flat plane.
            \note The rest load is approximately the product of gravitational acceleration and (sprungMass + wheelMass).
            
            <b>Unit:</b> force = mass * length / (time^2)
            */
            restLoad:       PxReal;

            loadFilter:     [2] [2] PxReal; //2 (x,y) points
        }

        PxVehiclePVDComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;

            firstTime: bool;
            #place pxvehiclecomponent; pxvehiclepvdcomponent_vtable: *PxVehiclePVDComponent_VTable;
        }
        PxVehiclePVDComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForPVDComponent: (this: *PxVehiclePVDComponent, axleDescription: **PxVehicleAxleDescription, rbodyParams: **PxVehicleRigidBodyParams, rbodyState: **PxVehicleRigidBodyState, suspStateCalcParams: **PxVehicleSuspensionStateCalculationParams, brakeResponseParams: *PxVehicleSizedArrayData(PxVehicleBrakeCommandResponseParams), steerResponseParams: **PxVehicleSteerCommandResponseParams, ackermannParams: **PxVehicleAckermannParams, brakeResponseStates: *PxVehicleArrayData(PxReal), steerResponseStates: *PxVehicleArrayData(PxReal), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), wheelActuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), wheelLocalPoses: *PxVehicleArrayData(PxVehicleWheelLocalPose), roadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspCompParams: *PxVehicleArrayData(PxVehicleSuspensionComplianceParams), suspForceParams: *PxVehicleArrayData(PxVehicleSuspensionForceParams), suspStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspCompStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspForces: *PxVehicleArrayData(PxVehicleSuspensionForce), tireForceParams: *PxVehicleArrayData(PxVehicleTireForceParams), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), tireSlipStates: *PxVehicleArrayData(PxVehicleTireSlipState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), tireGripStates: *PxVehicleArrayData(PxVehicleTireGripState), tireCamberStates: *PxVehicleArrayData(PxVehicleTireCamberAngleState), tireForces: *PxVehicleArrayData(PxVehicleTireForce), antiRollForceParams: *PxVehicleSizedArrayData(PxVehicleAntiRollForceParams), antiRollTorque: **PxVehicleAntiRollTorque, commandState: **PxVehicleCommandState, directDriveThrottleResponseParams: **PxVehicleDirectDriveThrottleCommandResponseParams, directDriveTransmissionState: **PxVehicleDirectDriveTransmissionCommandState, directDrivethrottleResponseState: *PxVehicleArrayData(PxReal), clutchResponseParams: **PxVehicleClutchCommandResponseParams, clutchParams: **PxVehicleClutchParams, engineParams: **PxVehicleEngineParams, gearboxParams: **PxVehicleGearboxParams, autoboxParams: **PxVehicleAutoboxParams, multiWheelDiffParams: **PxVehicleMultiWheelDriveDifferentialParams, fourWheelDiffParams: **PxVehicleFourWheelDriveDifferentialParams, tankDiffParams: **PxVehicleTankDriveDifferentialParams, engineDriveTransmissionState: **PxVehicleEngineDriveTransmissionCommandState, tankDriveTransmissionState: **PxVehicleTankDriveTransmissionCommandState, clutchResponseState: **PxVehicleClutchCommandResponseState, engineDriveThrottleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, engineState: **PxVehicleEngineState, gearboxState: **PxVehicleGearboxState, autoboxState: **PxVehicleAutoboxState, diffState: **PxVehicleDifferentialState, clutchSlipState: **PxVehicleClutchSlipState, physxConstraintParams: *PxVehicleArrayData(PxVehiclePhysXSuspensionLimitConstraintParams), physxMaterialFrictionParams: *PxVehicleArrayData(PxVehiclePhysXMaterialFrictionParams), physxActor: **PxVehiclePhysXActor, physxRoadGeomQryParams: **PxVehiclePhysXRoadGeometryQueryParams, physxRoadGeomStates: *PxVehicleArrayData(PxVehiclePhysXRoadGeometryQueryState), physxConstraintStates: *PxVehicleArrayData(PxVehiclePhysXConstraintState), physxSteerState: **PxVehiclePhysXSteerState, objectHandles: **PxVehiclePvdObjectHandles) -> void #cpp_method;
        }
        PxVehiclePVDComponent_getDataForPVDComponent :: inline (this: *PxVehiclePVDComponent, axleDescription: **PxVehicleAxleDescription, rbodyParams: **PxVehicleRigidBodyParams, rbodyState: **PxVehicleRigidBodyState, suspStateCalcParams: **PxVehicleSuspensionStateCalculationParams, brakeResponseParams: *PxVehicleSizedArrayData(PxVehicleBrakeCommandResponseParams), steerResponseParams: **PxVehicleSteerCommandResponseParams, ackermannParams: **PxVehicleAckermannParams, brakeResponseStates: *PxVehicleArrayData(PxReal), steerResponseStates: *PxVehicleArrayData(PxReal), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), wheelActuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), wheelLocalPoses: *PxVehicleArrayData(PxVehicleWheelLocalPose), roadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspCompParams: *PxVehicleArrayData(PxVehicleSuspensionComplianceParams), suspForceParams: *PxVehicleArrayData(PxVehicleSuspensionForceParams), suspStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspCompStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspForces: *PxVehicleArrayData(PxVehicleSuspensionForce), tireForceParams: *PxVehicleArrayData(PxVehicleTireForceParams), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), tireSlipStates: *PxVehicleArrayData(PxVehicleTireSlipState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), tireGripStates: *PxVehicleArrayData(PxVehicleTireGripState), tireCamberStates: *PxVehicleArrayData(PxVehicleTireCamberAngleState), tireForces: *PxVehicleArrayData(PxVehicleTireForce), antiRollForceParams: *PxVehicleSizedArrayData(PxVehicleAntiRollForceParams), antiRollTorque: **PxVehicleAntiRollTorque, commandState: **PxVehicleCommandState, directDriveThrottleResponseParams: **PxVehicleDirectDriveThrottleCommandResponseParams, directDriveTransmissionState: **PxVehicleDirectDriveTransmissionCommandState, directDrivethrottleResponseState: *PxVehicleArrayData(PxReal), clutchResponseParams: **PxVehicleClutchCommandResponseParams, clutchParams: **PxVehicleClutchParams, engineParams: **PxVehicleEngineParams, gearboxParams: **PxVehicleGearboxParams, autoboxParams: **PxVehicleAutoboxParams, multiWheelDiffParams: **PxVehicleMultiWheelDriveDifferentialParams, fourWheelDiffParams: **PxVehicleFourWheelDriveDifferentialParams, tankDiffParams: **PxVehicleTankDriveDifferentialParams, engineDriveTransmissionState: **PxVehicleEngineDriveTransmissionCommandState, tankDriveTransmissionState: **PxVehicleTankDriveTransmissionCommandState, clutchResponseState: **PxVehicleClutchCommandResponseState, engineDriveThrottleResponseState: **PxVehicleEngineDriveThrottleCommandResponseState, engineState: **PxVehicleEngineState, gearboxState: **PxVehicleGearboxState, autoboxState: **PxVehicleAutoboxState, diffState: **PxVehicleDifferentialState, clutchSlipState: **PxVehicleClutchSlipState, physxConstraintParams: *PxVehicleArrayData(PxVehiclePhysXSuspensionLimitConstraintParams), physxMaterialFrictionParams: *PxVehicleArrayData(PxVehiclePhysXMaterialFrictionParams), physxActor: **PxVehiclePhysXActor, physxRoadGeomQryParams: **PxVehiclePhysXRoadGeometryQueryParams, physxRoadGeomStates: *PxVehicleArrayData(PxVehiclePhysXRoadGeometryQueryState), physxConstraintStates: *PxVehicleArrayData(PxVehiclePhysXConstraintState), physxSteerState: **PxVehiclePhysXSteerState, objectHandles: **PxVehiclePvdObjectHandles) { this.pxvehiclepvdcomponent_vtable.getDataForPVDComponent(this, axleDescription, rbodyParams, rbodyState, suspStateCalcParams, brakeResponseParams, steerResponseParams, ackermannParams, brakeResponseStates, steerResponseStates, wheelParams, wheelActuationStates, wheelRigidBody1dStates, wheelLocalPoses, roadGeomStates, suspParams, suspCompParams, suspForceParams, suspStates, suspCompStates, suspForces, tireForceParams, tireDirectionStates, tireSpeedStates, tireSlipStates, tireStickyStates, tireGripStates, tireCamberStates, tireForces, antiRollForceParams, antiRollTorque, commandState, directDriveThrottleResponseParams, directDriveTransmissionState, directDrivethrottleResponseState, clutchResponseParams, clutchParams, engineParams, gearboxParams, autoboxParams, multiWheelDiffParams, fourWheelDiffParams, tankDiffParams, engineDriveTransmissionState, tankDriveTransmissionState, clutchResponseState, engineDriveThrottleResponseState, engineState, gearboxState, autoboxState, diffState, clutchSlipState, physxConstraintParams, physxMaterialFrictionParams, physxActor, physxRoadGeomQryParams, physxRoadGeomStates, physxConstraintStates, physxSteerState, objectHandles); }

        vtable :: (obj: *PxVehiclePVDComponent) -> *PxVehiclePVDComponent_VTable { return obj.pxvehiclepvdcomponent_vtable; }


        /*
        \brief The properties of the rigid body.
        */
        PxVehicleRigidBodyParams :: struct {
            /*
            \brief The mass of the rigid body.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass
            */
            mass: PxReal;

            /*
            \brief The moment of inertia of the rigid body.
            
            <b>Range:</b> (0, inf)<br>
            <b>Unit:</b> mass * (length^2)
            */
            moi:  PxVec3;
        }

        /*
        \brief Forward integrate the momentum and pose of the vehicle's rigid body after applying forces and torques
        from the suspension, tires and anti-roll bars.
        */
        PxVehicleRigidBodyComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclerigidbodycomponent_vtable: *PxVehicleRigidBodyComponent_VTable;
        }
        PxVehicleRigidBodyComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForRigidBodyComponent: (this: *PxVehicleRigidBodyComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyParams: **PxVehicleRigidBodyParams, suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), tireForces: *PxVehicleArrayData(PxVehicleTireForce), antiRollTorque: **PxVehicleAntiRollTorque, rigidBodyState: **PxVehicleRigidBodyState) -> void #cpp_method;
        }
        PxVehicleRigidBodyComponent_getDataForRigidBodyComponent :: inline (this: *PxVehicleRigidBodyComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyParams: **PxVehicleRigidBodyParams, suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), tireForces: *PxVehicleArrayData(PxVehicleTireForce), antiRollTorque: **PxVehicleAntiRollTorque, rigidBodyState: **PxVehicleRigidBodyState) { this.pxvehiclerigidbodycomponent_vtable.getDataForRigidBodyComponent(this, axleDescription, rigidBodyParams, suspensionForces, tireForces, antiRollTorque, rigidBodyState); }

        vtable :: (obj: *PxVehicleRigidBodyComponent) -> *PxVehicleRigidBodyComponent_VTable { return obj.pxvehiclerigidbodycomponent_vtable; }


        PxVehicleSuspensionComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclesuspensioncomponent_vtable: *PxVehicleSuspensionComponent_VTable;
        }
        PxVehicleSuspensionComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForSuspensionComponent: (this: *PxVehicleSuspensionComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyParams: **PxVehicleRigidBodyParams, suspensionStateCalculationParams: **PxVehicleSuspensionStateCalculationParams, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspensionComplianceParams: *PxVehicleArrayData(PxVehicleSuspensionComplianceParams), suspensionForceParams: *PxVehicleArrayData(PxVehicleSuspensionForceParams), antiRollForceParams: *PxVehicleSizedArrayData(PxVehicleAntiRollForceParams), wheelRoadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), antiRollTorque: **PxVehicleAntiRollTorque) -> void #cpp_method;
        }
        PxVehicleSuspensionComponent_getDataForSuspensionComponent :: inline (this: *PxVehicleSuspensionComponent, axleDescription: **PxVehicleAxleDescription, rigidBodyParams: **PxVehicleRigidBodyParams, suspensionStateCalculationParams: **PxVehicleSuspensionStateCalculationParams, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspensionComplianceParams: *PxVehicleArrayData(PxVehicleSuspensionComplianceParams), suspensionForceParams: *PxVehicleArrayData(PxVehicleSuspensionForceParams), antiRollForceParams: *PxVehicleSizedArrayData(PxVehicleAntiRollForceParams), wheelRoadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), antiRollTorque: **PxVehicleAntiRollTorque) { this.pxvehiclesuspensioncomponent_vtable.getDataForSuspensionComponent(this, axleDescription, rigidBodyParams, suspensionStateCalculationParams, steerResponseStates, rigidBodyState, wheelParams, suspensionParams, suspensionComplianceParams, suspensionForceParams, antiRollForceParams, wheelRoadGeomStates, suspensionStates, suspensionComplianceStates, suspensionForces, antiRollTorque); }

        vtable :: (obj: *PxVehicleSuspensionComponent) -> *PxVehicleSuspensionComponent_VTable { return obj.pxvehiclesuspensioncomponent_vtable; }


        /*
        \deprecated This API was introduced with the new Vehicle API for transition purposes but will be removed in a future version.
        */
        PxVehicleLegacySuspensionComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclelegacysuspensioncomponent_vtable: *PxVehicleLegacySuspensionComponent_VTable;
        }
        PxVehicleLegacySuspensionComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForLegacySuspensionComponent: (this: *PxVehicleLegacySuspensionComponent, axleDescription: **PxVehicleAxleDescription, suspensionStateCalculationParams: **PxVehicleSuspensionStateCalculationParams, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspensionComplianceParams: *PxVehicleArrayData(PxVehicleSuspensionComplianceParams), suspensionForceParams: *PxVehicleArrayData(PxVehicleSuspensionForceLegacyParams), antiRollForceParams: *PxVehicleSizedArrayData(PxVehicleAntiRollForceParams), wheelRoadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), antiRollTorque: **PxVehicleAntiRollTorque) -> void #cpp_method;
        }
        PxVehicleLegacySuspensionComponent_getDataForLegacySuspensionComponent :: inline (this: *PxVehicleLegacySuspensionComponent, axleDescription: **PxVehicleAxleDescription, suspensionStateCalculationParams: **PxVehicleSuspensionStateCalculationParams, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), suspensionComplianceParams: *PxVehicleArrayData(PxVehicleSuspensionComplianceParams), suspensionForceParams: *PxVehicleArrayData(PxVehicleSuspensionForceLegacyParams), antiRollForceParams: *PxVehicleSizedArrayData(PxVehicleAntiRollForceParams), wheelRoadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), antiRollTorque: **PxVehicleAntiRollTorque) { this.pxvehiclelegacysuspensioncomponent_vtable.getDataForLegacySuspensionComponent(this, axleDescription, suspensionStateCalculationParams, steerResponseStates, rigidBodyState, wheelParams, suspensionParams, suspensionComplianceParams, suspensionForceParams, antiRollForceParams, wheelRoadGeomStates, suspensionStates, suspensionComplianceStates, suspensionForces, antiRollTorque); }

        vtable :: (obj: *PxVehicleLegacySuspensionComponent) -> *PxVehicleLegacySuspensionComponent_VTable { return obj.pxvehiclelegacysuspensioncomponent_vtable; }


        PxVehicleTireComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehicletirecomponent_vtable: *PxVehicleTireComponent_VTable;
        }
        PxVehicleTireComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForTireComponent: (this: *PxVehicleTireComponent, axleDescription: **PxVehicleAxleDescription, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), tireForceParams: *PxVehicleArrayData(PxVehicleTireForceParams), roadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), wheelRigidBody1DStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), tireGripStates: *PxVehicleArrayData(PxVehicleTireGripState), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), tireSlipStates: *PxVehicleArrayData(PxVehicleTireSlipState), tireCamberAngleStates: *PxVehicleArrayData(PxVehicleTireCamberAngleState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), tireForces: *PxVehicleArrayData(PxVehicleTireForce)) -> void #cpp_method;
        }
        PxVehicleTireComponent_getDataForTireComponent :: inline (this: *PxVehicleTireComponent, axleDescription: **PxVehicleAxleDescription, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), tireForceParams: *PxVehicleArrayData(PxVehicleTireForceParams), roadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), wheelRigidBody1DStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), tireGripStates: *PxVehicleArrayData(PxVehicleTireGripState), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), tireSlipStates: *PxVehicleArrayData(PxVehicleTireSlipState), tireCamberAngleStates: *PxVehicleArrayData(PxVehicleTireCamberAngleState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), tireForces: *PxVehicleArrayData(PxVehicleTireForce)) { this.pxvehicletirecomponent_vtable.getDataForTireComponent(this, axleDescription, steerResponseStates, rigidBodyState, actuationStates, wheelParams, suspensionParams, tireForceParams, roadGeomStates, suspensionStates, suspensionComplianceStates, suspensionForces, wheelRigidBody1DStates, tireGripStates, tireDirectionStates, tireSpeedStates, tireSlipStates, tireCamberAngleStates, tireStickyStates, tireForces); }

        vtable :: (obj: *PxVehicleTireComponent) -> *PxVehicleTireComponent_VTable { return obj.pxvehicletirecomponent_vtable; }


        /*
        \deprecated This API was introduced with the new Vehicle API for transition purposes but will be removed in a future version.
        */
        PxVehicleLegacyTireComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclelegacytirecomponent_vtable: *PxVehicleLegacyTireComponent_VTable;
        }
        PxVehicleLegacyTireComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForLegacyTireComponent: (this: *PxVehicleLegacyTireComponent, axleDescription: **PxVehicleAxleDescription, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), tireForceParams: *PxVehicleArrayData(PxVehicleTireForceParams), roadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), wheelRigidBody1DStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), tireGripStates: *PxVehicleArrayData(PxVehicleTireGripState), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), tireSlipStates: *PxVehicleArrayData(PxVehicleTireSlipState), tireCamberAngleStates: *PxVehicleArrayData(PxVehicleTireCamberAngleState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), tireForces: *PxVehicleArrayData(PxVehicleTireForce)) -> void #cpp_method;
        }
        PxVehicleLegacyTireComponent_getDataForLegacyTireComponent :: inline (this: *PxVehicleLegacyTireComponent, axleDescription: **PxVehicleAxleDescription, steerResponseStates: *PxVehicleArrayData(PxReal), rigidBodyState: **PxVehicleRigidBodyState, actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), tireForceParams: *PxVehicleArrayData(PxVehicleTireForceParams), roadGeomStates: *PxVehicleArrayData(PxVehicleRoadGeometryState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), suspensionForces: *PxVehicleArrayData(PxVehicleSuspensionForce), wheelRigidBody1DStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), tireGripStates: *PxVehicleArrayData(PxVehicleTireGripState), tireDirectionStates: *PxVehicleArrayData(PxVehicleTireDirectionState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), tireSlipStates: *PxVehicleArrayData(PxVehicleTireSlipState), tireCamberAngleStates: *PxVehicleArrayData(PxVehicleTireCamberAngleState), tireStickyStates: *PxVehicleArrayData(PxVehicleTireStickyState), tireForces: *PxVehicleArrayData(PxVehicleTireForce)) { this.pxvehiclelegacytirecomponent_vtable.getDataForLegacyTireComponent(this, axleDescription, steerResponseStates, rigidBodyState, actuationStates, wheelParams, suspensionParams, tireForceParams, roadGeomStates, suspensionStates, suspensionComplianceStates, suspensionForces, wheelRigidBody1DStates, tireGripStates, tireDirectionStates, tireSpeedStates, tireSlipStates, tireCamberAngleStates, tireStickyStates, tireForces); }

        vtable :: (obj: *PxVehicleLegacyTireComponent) -> *PxVehicleLegacyTireComponent_VTable { return obj.pxvehiclelegacytirecomponent_vtable; }


        PxVehicleWheelComponent :: struct {
            #as using pxvehiclecomponent: PxVehicleComponent;
            #place pxvehiclecomponent; pxvehiclewheelcomponent_vtable: *PxVehicleWheelComponent_VTable;
        }
        PxVehicleWheelComponent_VTable :: struct #type_info_none {
            using pxvehiclecomponent: PxVehicleComponent_VTable;
            getDataForWheelComponent: (this: *PxVehicleWheelComponent, axleDescription: **PxVehicleAxleDescription, steerResponseStates: *PxVehicleArrayData(PxReal), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), wheelLocalPoses: *PxVehicleArrayData(PxVehicleWheelLocalPose)) -> void #cpp_method;
        }
        PxVehicleWheelComponent_getDataForWheelComponent :: inline (this: *PxVehicleWheelComponent, axleDescription: **PxVehicleAxleDescription, steerResponseStates: *PxVehicleArrayData(PxReal), wheelParams: *PxVehicleArrayData(PxVehicleWheelParams), suspensionParams: *PxVehicleArrayData(PxVehicleSuspensionParams), actuationStates: *PxVehicleArrayData(PxVehicleWheelActuationState), suspensionStates: *PxVehicleArrayData(PxVehicleSuspensionState), suspensionComplianceStates: *PxVehicleArrayData(PxVehicleSuspensionComplianceState), tireSpeedStates: *PxVehicleArrayData(PxVehicleTireSpeedState), wheelRigidBody1dStates: *PxVehicleArrayData(PxVehicleWheelRigidBody1dState), wheelLocalPoses: *PxVehicleArrayData(PxVehicleWheelLocalPose)) { this.pxvehiclewheelcomponent_vtable.getDataForWheelComponent(this, axleDescription, steerResponseStates, wheelParams, suspensionParams, actuationStates, suspensionStates, suspensionComplianceStates, tireSpeedStates, wheelRigidBody1dStates, wheelLocalPoses); }

        vtable :: (obj: *PxVehicleWheelComponent) -> *PxVehicleWheelComponent_VTable { return obj.pxvehiclewheelcomponent_vtable; }

    }

    /*
    \see PxVehicleDrive4W, PxVehicleDriveTank, PxVehicleDriveNW, PxVehicleNoDrive, PxVehicleWheels::getVehicleType
    */
    PxVehicleTypes :: struct {
        Enum :: enum s32 {
            DRIVE4W              :: 0;
            DRIVENW              :: 1;
            DRIVETANK            :: 2;
            NODRIVE              :: 3;
            USER1                :: 4;
            USER2                :: 5;
            USER3                :: 6;
            MAX_NB_VEHICLE_TYPES :: 7;

            eDRIVE4W              :: DRIVE4W;
            eDRIVENW              :: DRIVENW;
            eDRIVETANK            :: DRIVETANK;
            eNODRIVE              :: NODRIVE;
            eUSER1                :: USER1;
            eUSER2                :: USER2;
            eUSER3                :: USER3;
            eMAX_NB_VEHICLE_TYPES :: MAX_NB_VEHICLE_TYPES;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief An enumeration of concrete vehicle classes inheriting from PxBase.
    \note This enum can be used to identify a vehicle object stored in a PxCollection.
    \see PxBase, PxTypeInfo, PxBase::getConcreteType
    */
    PxVehicleConcreteType :: struct {
        Enum :: enum s32 {
            NoDrive   :: 512;
            Drive4W   :: 513;
            DriveNW   :: 514;
            DriveTank :: 515;

            eVehicleNoDrive   :: NoDrive;
            eVehicleDrive4W   :: Drive4W;
            eVehicleDriveNW   :: DriveNW;
            eVehicleDriveTank :: DriveTank;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \see PxVehicleSetUpdateMode
    */
    PxVehicleUpdateMode :: struct {
        Enum :: enum s32 {
            VELOCITY_CHANGE :: 0;
            ACCELERATION    :: 1;

            eVELOCITY_CHANGE :: VELOCITY_CHANGE;
            eACCELERATION    :: ACCELERATION;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Common parameters and settings used for the vehicle simulation.
    
    To be passed into PxVehicleUpdates(), for example.
    
    \see PxVehicleUpdates()
    */
    PxVehicleContext :: struct {
        /*
        \brief The axis denoting the up direction for vehicles.
        
        <b>Range:</b> unit length vector<br>
        <b>Default:</b> PxVec3(0,1,0)
        
        \see PxVehicleSetBasisVectors()
        */
        upAxis:                           PxVec3;

        /*
        \brief The axis denoting the forward direction for vehicles.
        
        <b>Range:</b> unit length vector<br>
        <b>Default:</b> PxVec3(0,0,1)
        
        \see PxVehicleSetBasisVectors()
        */
        forwardAxis:                      PxVec3;

        /*
        \brief The axis denoting the side direction for vehicles.
        
        Has to be the cross product of the up- and forward-axis. The method
        computeSideAxis() can be used to do that computation for you.
        
        <b>Range:</b> unit length vector<br>
        <b>Default:</b> PxVec3(1,0,0)
        
        \see PxVehicleSetBasisVectors(), computeSideAxis()
        */
        sideAxis:                         PxVec3;

        /*
        \brief Apply vehicle simulation results as acceleration or velocity modification.
        
        See PxVehicleSetUpdateMode() for details.
        
        <b>Default:</b> eVELOCITY_CHANGE
        
        \see PxVehicleSetUpdateMode()
        */
        updateMode:                       PxVehicleUpdateMode.Enum;

        /*
        \brief Cosine of threshold angle for rejecting sweep hits.
        
        See PxVehicleSetSweepHitRejectionAngles() for details.
        
        <b>Range:</b> (1, -1)<br>
        <b>Default:</b> 0.707f (cosine of 45 degrees)
        
        \see PxVehicleSetSweepHitRejectionAngles()
        */
        pointRejectAngleThresholdCosine:  PxF32;

        /*
        \brief Cosine of threshold angle for rejecting sweep hits.
        
        See PxVehicleSetSweepHitRejectionAngles() for details.
        
        <b>Range:</b> (1, -1)<br>
        <b>Default:</b> 0.707f (cosine of 45 degrees)
        
        \see PxVehicleSetSweepHitRejectionAngles()
        */
        normalRejectAngleThresholdCosine: PxF32;

        /*
        \brief Maximum acceleration experienced by PxRigidDynamic instances that are found to be in contact with a wheel.
        
        See PxVehicleSetMaxHitActorAcceleration() for details.
        
        <b>Range:</b> [0, PX_MAX_REAL]<br>
        <b>Default:</b> PX_MAX_REAL
        
        \see PxVehicleSetMaxHitActorAcceleration()
        */
        maxHitActorAcceleration:          PxF32;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleChassisData :: struct {
        /*
        \brief Moment of inertia of vehicle rigid body actor.
        
        \note Specified in kilograms metres-squared (kg m^2).
        */
        mMOI:      PxVec3;

        /*
        \brief Mass of vehicle rigid body actor.
        
        \note Specified in kilograms (kg).
        */
        mMass:     PxReal;

        /*
        \brief Center of mass offset of vehicle rigid body actor.
        
        \note Specified in metres (m).
        */
        mCMOffset: PxVec3;

        pad:       PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleEngineData :: struct {
        anon_enum_4 :: enum s32 {
            eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES :: 8;
        }

        /*
        \brief Graph of normalized torque (torque/mPeakTorque) against normalized engine speed ( engineRotationSpeed / mMaxOmega ).
        
        \note The normalized engine speed is the x-axis of the graph, while the normalized torque is the y-axis of the graph.
        */
        mTorqueCurve:                             PxFixedSizeLookupTable(UnknownTemplateArgumentPlaceholder) = xx anon_enum_4.eMAX_NB_ENGINE_TORQUE_CURVE_ENTRIES;

        /*
        \brief Moment of inertia of the engine around the axis of rotation.
        
        \note Specified in kilograms metres-squared (kg m^2)
        */
        mMOI:                                     PxReal;

        /*
        \brief Maximum torque available to apply to the engine when the accelerator pedal is at maximum.
        
        \note The torque available is the value of the accelerator pedal (in range [0, 1]) multiplied by the normalized torque as computed from mTorqueCurve multiplied by mPeakTorque.
        
        \note Specified in kilograms metres-squared per second-squared (kg m^2 s^-2).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mPeakTorque:                              PxReal;

        /*
        \brief Maximum rotation speed of the engine.
        
        \note Specified in radians per second (s^-1).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxOmega:                                PxReal;

        /*
        \brief Damping rate of engine when full throttle is applied.
        
        \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchEngaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchEngaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchEngaged)*acceleratorPedal;
        
        \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchDisengaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchDisengaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;
        
        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRateFullThrottle:                 PxReal;

        /*
        \brief Damping rate of engine when full throttle is applied.
        
        \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchEngaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchEngaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchEngaged)*acceleratorPedal;
        
        \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchDisengaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchDisengaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;
        
        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRateZeroThrottleClutchEngaged:    PxReal;

        /*
        \brief Damping rate of engine when full throttle is applied.
        
        \note If the clutch is engaged (any gear except neutral) then the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchEngaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchEngaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchEngaged)*acceleratorPedal;
        
        \note If the clutch is disengaged (in neutral gear) the damping rate applied at run-time is an interpolation
        between mDampingRateZeroThrottleClutchDisengaged and mDampingRateFullThrottle:
        mDampingRateZeroThrottleClutchDisengaged + (mDampingRateFullThrottle-mDampingRateZeroThrottleClutchDisengaged)*acceleratorPedal;
        
        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRateZeroThrottleClutchDisengaged: PxReal;

        /*
        \brief Reciprocal of the engine moment of inertia.
        
        \note Not necessary to set this value because it is set by PxVehicleDriveSimData::setEngineData
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipMOI:                                PxReal;

        /*
        \brief Reciprocal of the maximum rotation speed of the engine.
        
        \note Not necessary to set this value because it is set by PxVehicleDriveSimData::setEngineData
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipMaxOmega:                           PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleGearsData :: struct {
        Enum :: enum s32 {
            REVERSE          :: 0;
            NEUTRAL          :: 1;
            FIRST            :: 2;
            SECOND           :: 3;
            THIRD            :: 4;
            FOURTH           :: 5;
            FIFTH            :: 6;
            SIXTH            :: 7;
            SEVENTH          :: 8;
            EIGHTH           :: 9;
            NINTH            :: 10;
            TENTH            :: 11;
            ELEVENTH         :: 12;
            TWELFTH          :: 13;
            THIRTEENTH       :: 14;
            FOURTEENTH       :: 15;
            FIFTEENTH        :: 16;
            SIXTEENTH        :: 17;
            SEVENTEENTH      :: 18;
            EIGHTEENTH       :: 19;
            NINETEENTH       :: 20;
            TWENTIETH        :: 21;
            TWENTYFIRST      :: 22;
            TWENTYSECOND     :: 23;
            TWENTYTHIRD      :: 24;
            TWENTYFOURTH     :: 25;
            TWENTYFIFTH      :: 26;
            TWENTYSIXTH      :: 27;
            TWENTYSEVENTH    :: 28;
            TWENTYEIGHTH     :: 29;
            TWENTYNINTH      :: 30;
            THIRTIETH        :: 31;
            GEARSRATIO_COUNT :: 32;

            eREVERSE          :: REVERSE;
            eNEUTRAL          :: NEUTRAL;
            eFIRST            :: FIRST;
            eSECOND           :: SECOND;
            eTHIRD            :: THIRD;
            eFOURTH           :: FOURTH;
            eFIFTH            :: FIFTH;
            eSIXTH            :: SIXTH;
            eSEVENTH          :: SEVENTH;
            eEIGHTH           :: EIGHTH;
            eNINTH            :: NINTH;
            eTENTH            :: TENTH;
            eELEVENTH         :: ELEVENTH;
            eTWELFTH          :: TWELFTH;
            eTHIRTEENTH       :: THIRTEENTH;
            eFOURTEENTH       :: FOURTEENTH;
            eFIFTEENTH        :: FIFTEENTH;
            eSIXTEENTH        :: SIXTEENTH;
            eSEVENTEENTH      :: SEVENTEENTH;
            eEIGHTEENTH       :: EIGHTEENTH;
            eNINETEENTH       :: NINETEENTH;
            eTWENTIETH        :: TWENTIETH;
            eTWENTYFIRST      :: TWENTYFIRST;
            eTWENTYSECOND     :: TWENTYSECOND;
            eTWENTYTHIRD      :: TWENTYTHIRD;
            eTWENTYFOURTH     :: TWENTYFOURTH;
            eTWENTYFIFTH      :: TWENTYFIFTH;
            eTWENTYSIXTH      :: TWENTYSIXTH;
            eTWENTYSEVENTH    :: TWENTYSEVENTH;
            eTWENTYEIGHTH     :: TWENTYEIGHTH;
            eTWENTYNINTH      :: TWENTYNINTH;
            eTHIRTIETH        :: THIRTIETH;
            eGEARSRATIO_COUNT :: GEARSRATIO_COUNT;
        }

        /*
        \brief Gear ratios
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRatios:     [32] PxReal;

        /*
        \brief Gear ratio applied is mRatios[currentGear]*finalRatio
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mFinalRatio: PxReal;

        /*
        \brief Number of gears (including reverse and neutral).
        
        <b>Range:</b> (0, MAX_NB_GEAR_RATIOS)<br>
        */
        mNbRatios:   PxU32;

        /*
        \brief Time it takes to switch gear.
        
        \note Specified in seconds (s).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSwitchTime: PxReal;

        mPad:        PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleAutoBoxData :: struct {
        /*
        \brief Value of ( engineRotationSpeed / PxVehicleEngineData::mMaxOmega ) that is high enough to increment gear.
        
        \note When ( engineRotationSpeed / PxVehicleEngineData::mMaxOmega ) > mUpRatios[currentGear] the autobox will begin
        a transition to currentGear+1 unless currentGear is the highest possible gear or neutral or reverse.
        
        <b>Range:</b> [0, 1]<br>
        */
        mUpRatios:   [32] PxReal;

        /*
        \brief Value of engineRevs/maxEngineRevs that is low enough to decrement gear.
        
        \note When ( engineRotationSpeed / PxVehicleEngineData::mMaxOmega ) < mDownRatios[currentGear] the autobox will begin
        a transition to currentGear-1 unless currentGear is first gear or neutral or reverse.
        
        <b>Range:</b> [0, 1]<br>
        */
        mDownRatios: [32] PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleDifferential4WData :: struct {
        Enum :: enum s32 {
            DIFF_TYPE_LS_4WD       :: 0;
            DIFF_TYPE_LS_FRONTWD   :: 1;
            DIFF_TYPE_LS_REARWD    :: 2;
            DIFF_TYPE_OPEN_4WD     :: 3;
            DIFF_TYPE_OPEN_FRONTWD :: 4;
            DIFF_TYPE_OPEN_REARWD  :: 5;
            MAX_NB_DIFF_TYPES      :: 6;

            eDIFF_TYPE_LS_4WD       :: DIFF_TYPE_LS_4WD;
            eDIFF_TYPE_LS_FRONTWD   :: DIFF_TYPE_LS_FRONTWD;
            eDIFF_TYPE_LS_REARWD    :: DIFF_TYPE_LS_REARWD;
            eDIFF_TYPE_OPEN_4WD     :: DIFF_TYPE_OPEN_4WD;
            eDIFF_TYPE_OPEN_FRONTWD :: DIFF_TYPE_OPEN_FRONTWD;
            eDIFF_TYPE_OPEN_REARWD  :: DIFF_TYPE_OPEN_REARWD;
            eMAX_NB_DIFF_TYPES      :: MAX_NB_DIFF_TYPES;
        }

        /*
        \brief Ratio of torque split between front and rear (>0.5 means more to front, <0.5 means more to rear).
        
        \note Only applied to DIFF_TYPE_LS_4WD and eDIFF_TYPE_OPEN_4WD
        
        <b>Range:</b> [0, 1]<br>
        */
        mFrontRearSplit:      PxReal;

        /*
        \brief Ratio of torque split between front-left and front-right (>0.5 means more to front-left, <0.5 means more to front-right).
        
        \note Only applied to DIFF_TYPE_LS_4WD and eDIFF_TYPE_OPEN_4WD and eDIFF_TYPE_LS_FRONTWD
        
        <b>Range:</b> [0, 1]<br>
        */
        mFrontLeftRightSplit: PxReal;

        /*
        \brief Ratio of torque split between rear-left and rear-right (>0.5 means more to rear-left, <0.5 means more to rear-right).
        
        \note Only applied to DIFF_TYPE_LS_4WD and eDIFF_TYPE_OPEN_4WD and eDIFF_TYPE_LS_REARWD
        
        <b>Range:</b> [0, 1]<br>
        */
        mRearLeftRightSplit:  PxReal;

        /*
        \brief Maximum allowed ratio of average front wheel rotation speed and rear wheel rotation speeds
        The differential will divert more torque to the slower wheels when the bias is exceeded.
        
        \note Only applied to DIFF_TYPE_LS_4WD
        
        <b>Range:</b> [1, PX_MAX_F32)<br>
        */
        mCentreBias:          PxReal;

        /*
        \brief Maximum allowed ratio of front-left and front-right wheel rotation speeds.
        The differential will divert more torque to the slower wheel when the bias is exceeded.
        
        \note Only applied to DIFF_TYPE_LS_4WD and DIFF_TYPE_LS_FRONTWD
        
        <b>Range:</b> [1, PX_MAX_F32)<br>
        */
        mFrontBias:           PxReal;

        /*
        \brief Maximum allowed ratio of rear-left and rear-right wheel rotation speeds.
        The differential will divert more torque to the slower wheel when the bias is exceeded.
        
        \note Only applied to DIFF_TYPE_LS_4WD and DIFF_TYPE_LS_REARWD
        
        <b>Range:</b> [1, PX_MAX_F32)<br>
        */
        mRearBias:            PxReal;

        /*
        \brief Type of differential.
        
        <b>Range:</b> [DIFF_TYPE_LS_4WD, DIFF_TYPE_OPEN_FRONTWD]<br>
        */
        mType:                Enum;

        mPad:                 [1] PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleDifferentialNWData :: struct {
        mBitmapBuffer:      [1] PxU32;
        mNbDrivenWheels:    PxU32;
        mInvNbDrivenWheels: PxReal;
        mPad:               PxU32;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleAckermannGeometryData :: struct {
        /*
        \brief Accuracy of Ackermann steer calculation.
        
        \note Accuracy with value 0.0 results in no Ackermann steer-correction, while
        accuracy with value 1.0 results in perfect Ackermann steer-correction.
        
        \note Perfect Ackermann steer correction modifies the steer angles applied to the front-left and
        front-right wheels so that the perpendiculars to the wheels' longitudinal directions cross the
        extended vector of the rear axle at the same point.  It is also applied to any steer angle applied
        to the rear wheels but instead using the extended vector of the front axle.
        
        \note In general, more steer correction produces better cornering behavior.
        
        <b>Range:</b> [0, 1]<br>
        */
        mAccuracy:       PxReal;

        /*
        \brief Distance between center-point of the two front wheels.
        
        \note Specified in metres (m).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mFrontWidth:     PxReal;

        /*
        \brief Distance between center-point of the two rear wheels.
        
        \note Specified in metres (m).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRearWidth:      PxReal;

        /*
        \brief Distance between center of front axle and center of rear axle.
        
        \note Specified in metres (m).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mAxleSeparation: PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Choose between a potentially more expensive but more accurate solution to the clutch model or a potentially cheaper but less accurate solution.
    \see PxVehicleClutchData
    */
    PxVehicleClutchAccuracyMode :: struct {
        Enum :: enum s32 {
            ESTIMATE      :: 0;
            BEST_POSSIBLE :: 1;

            eESTIMATE      :: ESTIMATE;
            eBEST_POSSIBLE :: BEST_POSSIBLE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleClutchData :: struct {
        /*
        \brief Strength of clutch.
        
        \note The clutch is the mechanism that couples the engine to the wheels.
        A stronger clutch more strongly couples the engine to the wheels, while a
        clutch of strength zero completely decouples the engine from the wheels.
        Stronger clutches more quickly bring the wheels and engine into equilibrium, while weaker
        clutches take longer, resulting in periods of clutch slip and delays in power transmission
        from the engine to the wheels.
        The torque generated by the clutch is proportional to the clutch strength and
        the velocity difference between the engine's rotational speed and the rotational speed of the
        driven wheels after accounting for the gear ratio.
        The torque at the clutch is applied negatively to the engine and positively to the driven wheels.
        
        \note Specified in kilograms metres-squared per second (kg m^2 s^-1)
        
        <b>Range:</b> [0,PX_MAX_F32)<br>
        */
        mStrength:           PxReal;

        /*
        \brief The engine and wheel rotation speeds that are coupled through the clutch can be updated by choosing
        one of two modes: eESTIMATE and eBEST_POSSIBLE.
        
        \note If eESTIMATE is chosen the vehicle sdk will update the wheel and engine rotation speeds
        with estimated values to the implemented clutch model.
        
        \note If eBEST_POSSIBLE is chosen the vehicle sdk will compute the best possible
        solution (within floating point tolerance) to the implemented clutch model.
        This is the recommended mode.
        
        \note The clutch model remains the same if either eESTIMATE or eBEST_POSSIBLE is chosen but the accuracy and
        computational cost of the solution to the model can be tuned as required.
        */
        mAccuracyMode:       PxVehicleClutchAccuracyMode.Enum;

        /*
        \brief Tune the mathematical accuracy and computational cost of the computed estimate to the wheel and
        engine rotation speeds if eESTIMATE is chosen.
        
        \note As mEstimateIterations increases the computational cost of the clutch also increases and the solution
        approaches the solution that would be computed if eBEST_POSSIBLE was chosen instead.
        
        \note This has no effect if eBEST_POSSIBLE is chosen as the accuracy mode.
        
        \note A value of zero is not allowed if eESTIMATE is chosen as the accuracy mode.
        */
        mEstimateIterations: PxU32;

        mPad:                [4] PxU8;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief Tire load variation can be strongly dependent on the time-step so it is a good idea to filter it
    to give less jerky handling behavior.
    
    \note The x-axis of the graph is normalized tire load, while the y-axis is the filtered normalized tire load.
    
    \note The normalized load is the force acting downwards on the tire divided by the force experienced by the tire when the car is at rest on the ground.
    
    \note The rest load is approximately the product of the value of gravitational acceleration and PxVehicleSuspensionData::mSprungMass.
    
    \note The minimum possible normalized load is zero.
    
    \note There are two points on the graph: (mMinNormalisedLoad, mMinNormalisedFilteredLoad) and (mMaxNormalisedLoad, mMaxFilteredNormalisedLoad).
    
    \note Normalized loads less than mMinNormalisedLoad have filtered normalized load = mMinNormalisedFilteredLoad.
    
    \note Normalized loads greater than mMaxNormalisedLoad have filtered normalized load = mMaxFilteredNormalisedLoad.
    
    \note Normalized loads in-between are linearly interpolated between mMinNormalisedFilteredLoad and mMaxFilteredNormalisedLoad.
    
    \note The tire load applied as input to the tire force computation is the filtered normalized load multiplied by the rest load.
    */
    PxVehicleTireLoadFilterData :: struct {
        /*
        \brief Graph point (mMinNormalisedLoad,mMinFilteredNormalisedLoad)
        */
        mMinNormalisedLoad:         PxReal;

        /*
        \brief Graph point (mMinNormalisedLoad,mMinFilteredNormalisedLoad)
        */
        mMinFilteredNormalisedLoad: PxReal;

        /*
        \brief Graph point (mMaxNormalisedLoad,mMaxFilteredNormalisedLoad)
        */
        mMaxNormalisedLoad:         PxReal;

        /*
        \brief Graph point (mMaxNormalisedLoad,mMaxFilteredNormalisedLoad)
        */
        mMaxFilteredNormalisedLoad: PxReal;

        /*
        \brief Not necessary to set this value.
        */
        //1.0f/(mMaxNormalisedLoad-mMinNormalisedLoad) for quick calculations
        mDenominator:               PxReal;

        mPad:                       [3] PxU32;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleWheelData :: struct {
        /*
        \brief Radius of unit that includes metal wheel plus rubber tire.
        
        \note Specified in metres (m).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRadius:             PxReal;

        /*
        \brief Maximum width of unit that includes wheel plus tire.
        
        \note Specified in metres (m).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mWidth:              PxReal;

        /*
        \brief Mass of unit that includes wheel plus tire.
        
        \note Specified in kilograms (kg).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMass:               PxReal;

        /*
        \brief Moment of inertia of unit that includes wheel plus tire about the rolling axis.
        
        \note Specified in kilograms metres-squared (kg m^2).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMOI:                PxReal;

        /*
        \brief Damping rate applied to wheel.
        
        \note Specified in kilograms metres-squared per second (kg m^2 s^-1).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mDampingRate:        PxReal;

        /*
        \brief Max brake torque that can be applied to wheel.
        
        \note Specified in kilograms metres-squared per second-squared (kg m^2 s^-2)
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxBrakeTorque:     PxReal;

        /*
        \brief Max handbrake torque that can be applied to wheel.
        
        \note Specified in kilograms metres-squared per second-squared (kg m^2 s^-2)
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxHandBrakeTorque: PxReal;

        /*
        \brief Max steer angle that can be achieved by the wheel.
        
        \note Specified in radians.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxSteer:           PxReal;

        mToeAngle:           PxReal; //in radians

        /*
        \brief Reciprocal of radius of unit that includes metal wheel plus rubber tire.
        
        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setWheelData
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipRadius:        PxReal;

        /*
        \brief Reciprocal of moment of inertia of unit that includes wheel plus tire about single allowed axis of rotation.
        
        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setWheelData
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mRecipMOI:           PxReal;

        mPad:                [1] PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleSuspensionData :: struct {
        /*
        \brief Spring strength of suspension unit.
        
        \note Specified in kilograms per second-squared (kg s^-2).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSpringStrength:         PxReal;

        /*
        \brief Spring damper rate of suspension unit.
        
        \note Specified in kilograms per second (kg s^-1).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSpringDamperRate:       PxReal;

        /*
        \brief Maximum compression allowed by suspension spring.
        
        \note Specified in metres (m).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxCompression:         PxReal;

        /*
        \brief Maximum elongation allowed by suspension spring.
        
        \note Specified in metres (m).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mMaxDroop:               PxReal;

        /*
        \brief Mass of vehicle that is supported by suspension spring.
        
        \note Specified in kilograms (kg).
        
        \note Each suspension is guaranteed to generate an upwards force of |gravity|*mSprungMass along the suspension direction when the wheel is perfectly
        at rest and sitting at the rest pose defined by the wheel centre offset.
        
        \note The sum of the sprung masses of all suspensions of a vehicle should match the mass of the PxRigidDynamic associated with the vehicle.
        When this condition is satisfied for a vehicle on a horizontal plane the wheels of the vehicle are guaranteed to sit at the rest pose
        defined by the wheel centre offset. For special cases, where this condition can not be met easily, the flag
        #PxVehicleWheelsSimFlag::eDISABLE_SPRUNG_MASS_SUM_CHECK allows to provide sprung mass values that do not sum up to the mass of the PxRigidDynamic.
        
        \note As the wheel compresses or elongates along the suspension direction the force generated by the spring is
        F = |gravity|*mSprungMass + deltaX*mSpringStrength + deltaXDot*mSpringDamperRate
        where deltaX is the deviation from the defined rest pose and deltaXDot is the velocity of the sprung mass along the suspension direction.
        In practice, deltaXDot is computed by comparing the current and previous deviation from the rest pose and dividing the difference
        by the simulation timestep.
        
        \note If a single suspension spring is hanging in the air and generates zero force the remaining springs of the vehicle will necessarily
        sit in a compressed configuration.  In summary, the sum of the remaining suspension forces cannot balance the downwards gravitational force
        acting on the vehicle without extra force arising from the deltaX*mSpringStrength force term.
        
        \note Theoretically, a suspension spring should generate zero force at maximum elongation and increase linearly as the suspension approaches the rest pose.
        PxVehicleSuspensionData will only enforce this physical law if the spring is configured so that |gravity|*mSprungMass == mMaxDroop*mSpringStrength.
        To help decouple vehicle handling from visual wheel positioning this condition is not enforced.
        In practice, the value of |gravity|*mSprungMass + deltaX*mSpringStrength is clamped at zero to ensure it never falls negative.
        
        \see PxVehicleComputeSprungMasses, PxVehicleWheelsSimData::setWheelCentreOffset, PxVehicleSuspensionData::mSpringStrength, PxVehicleSuspensionData::mSpringDamperRate, PxVehicleSuspensionData::mMaxDroop
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mSprungMass:             PxReal;

        /*
        \brief Camber angle (in radians) of wheel when the suspension is at its rest position.
        
        \note Specified in radians.
        
        <b>Range:</b> [-pi/2, pi/2]<br>
        
        */
        mCamberAtRest:           PxReal;

        /*
        \brief Camber angle (in radians) of wheel when the suspension is at maximum compression.
        
        \note For compressed suspensions the camber angle is a linear interpolation of
        mCamberAngleAtRest and mCamberAtMaxCompression
        
        \note Specified in radians.
        
        <b>Range:</b> [-pi/2, pi/2]<br>
        */
        mCamberAtMaxCompression: PxReal;

        /*
        \brief Camber angle (in radians) of wheel when the suspension is at maximum droop.
        
        \note For extended suspensions the camber angle is linearly interpolation of
        mCamberAngleAtRest and mCamberAtMaxDroop
        
        \note Specified in radians.
        
        <b>Range:</b> [-pi/2, pi/2]<br>
        */
        mCamberAtMaxDroop:       PxReal;

        /*
        \brief Cached value of 1.0f/mMaxCompression
        
        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setSuspensionData
        */
        mRecipMaxCompression:    PxReal;

        /*
        \brief Cached value of 1.0f/mMaxDroop
        
        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setSuspensionData
        */
        mRecipMaxDroop:          PxReal;

        //padding
        mPad:                    [2] PxReal;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleAntiRollBarData :: struct {
        /*
        \brief The anti-roll bar connects two wheels with indices mWheel0 and mWheel1
        */
        mWheel0:    PxU32;

        /*
        \brief The anti-roll bar connects two wheels with indices mWheel0 and mWheel1
        */
        mWheel1:    PxU32;

        /*
        \brief The stiffness of the anti-roll bar.
        
        \note Specified in kilograms per second-squared (kg s^-2).
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mStiffness: PxF32;

        mPad:       [1] PxF32;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleTireData :: struct {
        /*
        \brief Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and
        flattens at large loads.  mLatStiffX describes the minimum normalized load (load/restLoad) that gives a
        flat lateral stiffness response to load.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mLatStiffX:                                PxReal;

        /*
        \brief Tire lateral stiffness is a graph of tire load that has linear behavior near zero load and
        flattens at large loads. mLatStiffY describes the maximum possible value of lateralStiffness/restLoad that occurs
        when (load/restLoad)>= mLatStiffX.
        
        \note If load/restLoad is greater than mLatStiffX then the lateral stiffness is mLatStiffY*restLoad.
        
        \note If load/restLoad is less than mLatStiffX then the lateral stiffness is mLastStiffY*(load/mLatStiffX)
        
        \note Lateral force can be approximated as lateralStiffness * lateralSlip.
        
        \note Specified in per radian.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mLatStiffY:                                PxReal;

        /*
        \brief Tire Longitudinal stiffness per unit gravitational acceleration.
        
        \note Longitudinal stiffness of the tire is calculated as gravitationalAcceleration*mLongitudinalStiffnessPerUnitGravity.
        
        \note Longitudinal force can be approximated as gravitationalAcceleration*mLongitudinalStiffnessPerUnitGravity*longitudinalSlip.
        
        \note Specified in kilograms per radian.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mLongitudinalStiffnessPerUnitGravity:      PxReal;

        /*
        \brief tire Tire camber stiffness per unity gravitational acceleration.
        
        \note Camber stiffness of the tire is calculated as gravitationalAcceleration*mCamberStiffnessPerUnitGravity
        
        \note Camber force can be approximated as gravitationalAcceleration*mCamberStiffnessPerUnitGravity*camberAngle.
        
        \note Specified in kilograms per radian.
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mCamberStiffnessPerUnitGravity:            PxReal;

        /*
        \brief Graph of friction vs longitudinal slip with 3 points.
        
        \note mFrictionVsSlipGraph[0][0] is always zero.
        
        \note mFrictionVsSlipGraph[0][1] is the friction available at zero longitudinal slip.
        
        \note mFrictionVsSlipGraph[1][0] is the value of longitudinal slip with maximum friction.
        
        \note mFrictionVsSlipGraph[1][1] is the maximum friction.
        
        \note mFrictionVsSlipGraph[2][0] is the end point of the graph.
        
        \note mFrictionVsSlipGraph[2][1] is the value of friction for slips greater than mFrictionVsSlipGraph[2][0].
        
        \note The friction value computed from the friction vs longitudinal slip graph is used to scale the friction
        value for the combination of material and tire type (PxVehicleDrivableSurfaceToTireFrictionPairs).
        
        \note mFrictionVsSlipGraph[2][0] > mFrictionVsSlipGraph[1][0] > mFrictionVsSlipGraph[0][0]
        
        \note mFrictionVsSlipGraph[1][1] is typically greater than  mFrictionVsSlipGraph[0][1]
        
        \note mFrictionVsSlipGraph[2][1] is typically smaller than mFrictionVsSlipGraph[1][1]
        
        \note longitudinal slips > mFrictionVsSlipGraph[2][0] use friction multiplier mFrictionVsSlipGraph[2][1]
        
        \note The final friction value used by the tire model is the value returned by PxVehicleDrivableSurfaceToTireFrictionPairs
        multiplied by the value computed from mFrictionVsSlipGraph.
        
        \see PxVehicleDrivableSurfaceToTireFrictionPairs, PxVehicleComputeTireForce
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mFrictionVsSlipGraph:                      [3] [2] PxReal;

        /*
        \brief Tire type denoting slicks, wets, snow, winter, summer, all-terrain, mud etc.
        
        \see PxVehicleDrivableSurfaceToTireFrictionPairs
        
        <b>Range:</b> [0, PX_MAX_F32)<br>
        */
        mType:                                     PxU32;

        /*
        \brief Cached value of 1.0/mLongitudinalStiffnessPerUnitGravity.
        
        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setTireData
        
        \see PxVehicleWheelsSimData::setTireData
        */
        mRecipLongitudinalStiffnessPerUnitGravity: PxReal;

        /*
        \brief Cached value of 1.0f/(mFrictionVsSlipGraph[1][0]-mFrictionVsSlipGraph[0][0])
        
        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setTireData
        
        \see PxVehicleWheelsSimData::setTireData
        */
        mFrictionVsSlipGraphRecipx1Minusx0:        PxReal;

        /*
        \brief Cached value of 1.0f/(mFrictionVsSlipGraph[2][0]-mFrictionVsSlipGraph[1][0])
        
        \note Not necessary to set this value because it is set by PxVehicleWheelsSimData::setTireData
        
        \see PxVehicleWheelsSimData::setTireData
        */
        mFrictionVsSlipGraphRecipx2Minusx1:        PxReal;

        mPad:                                      [2] PxReal;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Prototype of shader function that is used to compute wheel torque and tire forces.
    \param[in]  shaderData is the shader data for the tire being processed.  The shader data describes the tire data in the format required by the tire model that is implemented by the shader function.
    \param[in]  tireFriction is the value of friction for the contact between the tire and the ground.
    \param[in]  longSlip is the value of longitudinal slip experienced by the tire.
    \param[in]  latSlip is the value of lateral slip experienced by the tire.
    \param[in]  camber is the camber angle of the tire in radians.
    \param[in]  wheelOmega is the rotational speed of the wheel.
    \param[in]  wheelRadius is the distance from the tire surface to the center of the wheel.
    \param[in]  recipWheelRadius is the reciprocal of wheelRadius.
    \param[in]  restTireLoad is the load force experienced by the tire when the vehicle is at rest.
    \param[in]  normalisedTireLoad is a pre-computed value equal to the load force on the tire divided by restTireLoad.
    \param[in]  tireLoad is the load force currently experienced by the tire (= restTireLoad*normalisedTireLoad)
    \param[in]  gravity is the magnitude of gravitational acceleration.
    \param[in]  recipGravity is the reciprocal of the magnitude of gravitational acceleration.
    \param[out] wheelTorque is the torque that is to be applied to the wheel around the wheel's axle.
    \param[out] tireLongForceMag is the magnitude of the longitudinal tire force to be applied to the vehicle's rigid body.
    \param[out] tireLatForceMag is the magnitude of the lateral tire force to be applied to the vehicle's rigid body.
    \param[out] tireAlignMoment is the aligning moment of the tire that is to be applied to the vehicle's rigid body (not currently used).
    \see PxVehicleWheelsDynData::setTireForceShaderFunction, PxVehicleWheelsDynData::setTireForceShaderData
    */
    PxVehicleComputeTireForce :: #type (shaderData: *void, tireFriction: PxF32, longSlip: PxF32, latSlip: PxF32, camber: PxF32, wheelOmega: PxF32, wheelRadius: PxF32, recipWheelRadius: PxF32, restTireLoad: PxF32, normalisedTireLoad: PxF32, tireLoad: PxF32, gravity: PxF32, recipGravity: PxF32, wheelTorque: *PxF32, tireLongForceMag: *PxF32, tireLatForceMag: *PxF32, tireAlignMoment: *PxF32) -> void #c_call;

    PxVehicleWheels4SimData :: struct {}
    PxVehicleWheels4DynData :: struct {}
    PxVehicleTireForceCalculator :: struct {}

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Flags to configure the vehicle wheel simulation.
    
    \see PxVehicleWheelsSimData::setFlags(), PxVehicleWheelsSimData::getFlags()
    */
    PxVehicleWheelsSimFlag :: struct {
        Enum :: enum s32 {
            LIMIT_SUSPENSION_EXPANSION_VELOCITY               :: 1;

            DISABLE_INTERNAL_CYLINDER_PLANE_INTERSECTION_TEST :: 2;

            DISABLE_SUSPENSION_FORCE_PROJECTION               :: 4;

            DISABLE_SPRUNG_MASS_SUM_CHECK                     :: 8;

            eLIMIT_SUSPENSION_EXPANSION_VELOCITY               :: LIMIT_SUSPENSION_EXPANSION_VELOCITY;

            eDISABLE_INTERNAL_CYLINDER_PLANE_INTERSECTION_TEST :: DISABLE_INTERNAL_CYLINDER_PLANE_INTERSECTION_TEST;

            eDISABLE_SUSPENSION_FORCE_PROJECTION               :: DISABLE_SUSPENSION_FORCE_PROJECTION;

            eDISABLE_SPRUNG_MASS_SUM_CHECK                     :: DISABLE_SPRUNG_MASS_SUM_CHECK;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Collection of set bits defined in #PxVehicleWheelsSimFlag.
    
    \see PxVehicleWheelsSimFlag
    */
    PxVehicleWheelsSimFlags :: PxFlags(PxVehicleWheelsSimFlag.Enum, PxU32);

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Data structure describing configuration data of a vehicle with up to 20 wheels.
    */
    PxVehicleWheelsSimData :: struct {
        /*
        \brief Graph to filter normalised load
        \see setTireLoadFilterData, getTireLoadFilterData
        */
        mNormalisedLoadFilter:         PxVehicleTireLoadFilterData;

        /*
        \brief Wheels data organised in blocks of 4 wheels.
        */
        mWheels4SimData:               *PxVehicleWheels4SimData;

        /*
        \brief Number of blocks of 4 wheels.
        */
        mNbWheels4:                    PxU32;

        /*
        \brief Number of actual wheels (<=(mNbWheels4*4))
        */
        mNbActiveWheels:               PxU32;

        /*
        \brief Anti-roll bars
        */
        mAntiRollBars:                 *PxVehicleAntiRollBarData;

        /*
        \brief 2 anti-rollbars allocated for each block of 4 wheels.
        */
        mNbAntiRollBars4:              PxU32;

        /*
        \brief Number of active anti-roll bars.
        */
        mNbActiveAntiRollBars:         PxU32;

        /*
        \brief Which of the mNbActiveWheels are active or disabled?
        The default is that all mNbActiveWheels wheels are active.
        */
        mActiveWheelsBitmapBuffer:     [1] PxU32;

        /*
        \brief Threshold longitudinal speed used to decide whether to use
        mLowForwardSpeedSubStepCount or mHighForwardSpeedSubStepCount as the
        number of sub-steps that will be peformed.
        */
        mThresholdLongitudinalSpeed:   PxF32;

        /*
        \brief Number of sub-steps that will be performed if the longitudinal speed
        of the vehicle is smaller than mThresholdLongitudinalSpeed.
        */
        mLowForwardSpeedSubStepCount:  PxU32;

        /*
        \brief Number of sub-steps that will be performed if the longitudinal speed
        of the vehicle is greater than or equal to mThresholdLongitudinalSpeed.
        */
        mHighForwardSpeedSubStepCount: PxU32;

        /*
        \brief Minimum long slip denominator
        */
        mMinLongSlipDenominator:       PxF32;

        /*
        \brief The vehicle wheel simulation flags.
        
        \see PxVehicleWheelsSimFlags
        */
        mFlags:                        PxU32;

        mPad:                          [1] PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Description of the per wheel intersection method to be used by PxVehicleWheelsDynData::setTireContacts()
    */
    PxTireContactIntersectionMethod :: struct {
        Enum :: enum s32 {
            RAY      :: 0;
            CYLINDER :: 1;

            eRAY      :: RAY;
            eCYLINDER :: CYLINDER;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Data structure with instanced dynamics data for wheels
    */
    PxVehicleWheelsDynData :: struct {
        /*
        \brief Dynamics data arranged in blocks of 4 wheels.
        */
        mWheels4DynData:       *PxVehicleWheels4DynData;

        /*
        \brief Shader data and function for tire force calculations.
        */
        mTireForceCalculators: *PxVehicleTireForceCalculator;

        /*
        \brief A userData pointer can be stored for each wheel.
        \see setUserData, getUserData
        */
        mUserDatas:            **void;

        /*
        \brief Number of blocks of 4 wheels.
        */
        mNbWheels4:            PxU32;

        /*
        \brief Number of wheels (mNbActiveWheels <= (mNbWheels4*4))
        */
        mNbActiveWheels:       PxU32;

        mPad:                  [3] PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with just wheels
    \see PxVehicleDrive, PxVehicleDrive4W, PxVehicleDriveTank
    */
    PxVehicleWheels :: struct {
        #as using pxbase: PxBase;

        /*
        \brief Data describing the setup of all the wheels/suspensions/tires.
        */
        mWheelsSimData:              PxVehicleWheelsSimData;

        /*
        \brief Data describing the dynamic state of all wheels/suspension/tires.
        */
        mWheelsDynData:              PxVehicleWheelsDynData;

        /*
        \brief The rigid body actor that represents the vehicle in the PhysX SDK.
        */
        mActor:                      *PxRigidDynamic;

        /*
        \brief Count the number of constraint connectors that have hit their callback when deleting a vehicle.
        Can only delete the vehicle's memory when all constraint connectors have hit their callback.
        */
        mNbNonDrivenWheels:          PxU32;

        mOnConstraintReleaseCounter: PxU8;

        /*
        \brief Vehicle type (eVehicleDriveTypes)
        */
        mType:                       PxU8;

        mPad0:                       [14] PxU8;
        #place pxbase; pxvehiclewheels_vtable: *PxVehicleWheels_VTable;
    }
    PxVehicleWheels_VTable :: struct #type_info_none {
        using pxbase: PxBase_VTable;
        init: (this: *PxVehicleWheels, numWheels: PxU32) -> void #cpp_method;

        requiresObjects: (this: *PxVehicleWheels, c: *PxProcessPxBaseCallback) -> void #cpp_method;

        preExportDataReset: (this: *PxVehicleWheels) -> void #cpp_method;
        exportExtraData: (this: *PxVehicleWheels, unknown0: *PxSerializationContext) -> void #cpp_method;
    }

    PxVehicleWheels_init :: inline (this: *PxVehicleWheels, numWheels: PxU32) { this.pxvehiclewheels_vtable.init(this, numWheels); }

    PxVehicleWheels_requiresObjects :: inline (this: *PxVehicleWheels, c: *PxProcessPxBaseCallback) { this.pxvehiclewheels_vtable.requiresObjects(this, c); }

    PxVehicleWheels_preExportDataReset :: inline (this: *PxVehicleWheels) { this.pxvehiclewheels_vtable.preExportDataReset(this); }
    PxVehicleWheels_exportExtraData :: inline (this: *PxVehicleWheels, unknown0: *PxSerializationContext) { this.pxvehiclewheels_vtable.exportExtraData(this, unknown0); }

    vtable :: (obj: *PxVehicleWheels) -> *PxVehicleWheels_VTable { return obj.pxvehiclewheels_vtable; }


    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief Data structure describing non-wheel configuration data of a vehicle that has engine, gears, clutch, and auto-box.
    \see PxVehicleWheelsSimData for wheels configuration data.
    */
    PxVehicleDriveSimData :: struct {
        /*
        \brief Engine simulation data
        \see setEngineData, getEngineData
        */
        mEngine:  PxVehicleEngineData;

        /*
        \brief Gear simulation data
        \see setGearsData, getGearsData
        */
        mGears:   PxVehicleGearsData;

        /*
        \brief Clutch simulation data
        \see setClutchData, getClutchData
        */
        mClutch:  PxVehicleClutchData;

        /*
        \brief Autobox simulation data
        \see setAutoboxData, getAutoboxData
        */
        mAutoBox: PxVehicleAutoBoxData;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief Data structure with instanced dynamics data for vehicle with engine, clutch, gears, autobox
    \see PxVehicleWheelsDynData for wheels dynamics data.
    */
    PxVehicleDriveDynData :: struct {
        anon_enum_5 :: enum s32 {
            eMAX_NB_ANALOG_INPUTS :: 16;
        }

        /*
        \brief Analog control values used by vehicle simulation.
        \see setAnalogInput, getAnalogInput, PxVehicleDrive4WControl, PxVehicleDriveNWControl, PxVehicleDriveTankControl
        */
        mControlAnalogVals: [16] PxReal;

        /*
        \brief Auto-gear flag used by vehicle simulation.  Set true to enable the autobox, false to disable the autobox.
        \see setUseAutoGears, setUseAutoGears, toggleAutoGears, PxVehicleAutoBoxData
        */
        mUseAutoGears:      bool;

        /*
        \brief Gear-up digital control value used by vehicle simulation.
        
        \note If true a gear change will be initiated towards currentGear+1 (or to first gear if in reverse).
        
        \see setDigitalInput, getDigitalInput
        */
        mGearUpPressed:     bool;

        /*
        \brief Gear-down digital control value used by vehicle simulation.
        
        \note If true a gear change will be initiated towards currentGear-1 (or to reverse if in first).
        
        \see setDigitalInput, getDigitalInput
        */
        mGearDownPressed:   bool;

        /*
        \brief Current gear
        \see startGearChange, forceGearChange, getCurrentGear, PxVehicleGearsData
        */
        mCurrentGear:       PxU32;

        /*
        \brief Target gear (different from current gear if a gear change is underway)
        \see startGearChange, forceGearChange, getTargetGear, PxVehicleGearsData
        */
        mTargetGear:        PxU32;

        /*
        \brief Rotation speed of engine
        \see setToRestState, getEngineRotationSpeed
        */
        mEnginespeed:       PxReal;

        /*
        \brief Reported time that has passed since gear change started.
        \see setToRestState, startGearChange, PxVehicleGearsData::mSwitchTime
        */
        mGearSwitchTime:    PxReal;

        /*
        \brief Reported time that has passed since last autobox gearup/geardown decision.
        \see setToRestState, PxVehicleAutoBoxData::setLatency
        */
        mAutoBoxSwitchTime: PxReal;

        mPad:               [2] PxU32;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief A complete vehicle with instance dynamics data and configuration data for wheels and engine,clutch,gears,autobox.
    \see PxVehicleDrive4W, PxVehicleDriveTank
    */
    PxVehicleDrive :: struct {
        #as using pxvehiclewheels: PxVehicleWheels;

        /*
        \brief Dynamics data of vehicle instance.
        \see setup
        */
        mDriveDynData: PxVehicleDriveDynData;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief Data structure describing the drive model components of a vehicle with up to 4 driven wheels and up to 16 un-driven wheels.
    The drive model incorporates engine, clutch, gears, autobox, differential, and Ackermann steer correction.
    \see PxVehicleDriveSimData
    */
    PxVehicleDriveSimData4W :: struct {
        #as using pxvehicledrivesimdata: PxVehicleDriveSimData;

        /*
        \brief Differential simulation data
        \see setDiffData, getDiffData
        */
        mDiff:              PxVehicleDifferential4WData;

        /*
        \brief Data for ackermann steer angle computation.
        \see setAckermannGeometryData, getAckermannGeometryData
        */
        mAckermannGeometry: PxVehicleAckermannGeometryData;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief The ordering of the driven and steered wheels of a PxVehicleDrive4W.
    
    \see PxVehicleWheelsSimData, PxVehicleWheelsDynData
    */
    PxVehicleDrive4WWheelOrder :: struct {
        Enum :: enum s32 {
            FRONT_LEFT  :: 0;
            FRONT_RIGHT :: 1;
            REAR_LEFT   :: 2;
            REAR_RIGHT  :: 3;

            eFRONT_LEFT  :: FRONT_LEFT;
            eFRONT_RIGHT :: FRONT_RIGHT;
            eREAR_LEFT   :: REAR_LEFT;
            eREAR_RIGHT  :: REAR_RIGHT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief The control inputs for a PxVehicleDrive4W.
    
    \see PxVehicleDriveDynData::setAnalogInput, PxVehicleDriveDynData::getAnalogInput
    */
    PxVehicleDrive4WControl :: struct {
        Enum :: enum s32 {
            ANALOG_INPUT_ACCEL           :: 0;
            ANALOG_INPUT_BRAKE           :: 1;
            ANALOG_INPUT_HANDBRAKE       :: 2;
            ANALOG_INPUT_STEER_LEFT      :: 3;
            ANALOG_INPUT_STEER_RIGHT     :: 4;
            MAX_NB_DRIVE4W_ANALOG_INPUTS :: 5;

            eANALOG_INPUT_ACCEL           :: ANALOG_INPUT_ACCEL;
            eANALOG_INPUT_BRAKE           :: ANALOG_INPUT_BRAKE;
            eANALOG_INPUT_HANDBRAKE       :: ANALOG_INPUT_HANDBRAKE;
            eANALOG_INPUT_STEER_LEFT      :: ANALOG_INPUT_STEER_LEFT;
            eANALOG_INPUT_STEER_RIGHT     :: ANALOG_INPUT_STEER_RIGHT;
            eMAX_NB_DRIVE4W_ANALOG_INPUTS :: MAX_NB_DRIVE4W_ANALOG_INPUTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with up to 4 driven wheels and up to 16 non-driven wheels.
    */
    PxVehicleDrive4W :: struct {
        #as using pxvehicledrive: PxVehicleDrive;

        /*
        \brief Simulation data that describes the configuration of the vehicle's drive model.
        \see setup, create
        */
        mDriveSimData: PxVehicleDriveSimData4W;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief The ordering of the wheels of a PxVehicleDriveTank.
    
    \see PxVehicleWheelsSimData, PxVehicleWheelsDynData
    */
    PxVehicleDriveTankWheelOrder :: struct {
        Enum :: enum s32 {
            FRONT_LEFT            :: 0;
            FRONT_RIGHT           :: 1;
            _1ST_FROM_FRONT_LEFT  :: 2;
            _1ST_FROM_FRONT_RIGHT :: 3;
            _2ND_FROM_FRONT_LEFT  :: 4;
            _2ND_FROM_FRONT_RIGHT :: 5;
            _3RD_FROM_FRONT_LEFT  :: 6;
            _3RD_FROM_FRONT_RIGHT :: 7;
            _4TH_FROM_FRONT_LEFT  :: 8;
            _4TH_FROM_FRONT_RIGHT :: 9;
            _5TH_FROM_FRONT_LEFT  :: 10;
            _5TH_FROM_FRONT_RIGHT :: 11;
            _6TH_FROM_FRONT_LEFT  :: 12;
            _6TH_FROM_FRONT_RIGHT :: 13;
            _7TH_FROM_FRONT_LEFT  :: 14;
            _7TH_FROM_FRONT_RIGHT :: 15;
            _8TH_FROM_FRONT_LEFT  :: 16;
            _8TH_FROM_FRONT_RIGHT :: 17;
            _9TH_FROM_FRONT_LEFT  :: 18;
            _9TH_FROM_FRONT_RIGHT :: 19;

            eFRONT_LEFT           :: FRONT_LEFT;
            eFRONT_RIGHT          :: FRONT_RIGHT;
            e1ST_FROM_FRONT_LEFT  :: _1ST_FROM_FRONT_LEFT;
            e1ST_FROM_FRONT_RIGHT :: _1ST_FROM_FRONT_RIGHT;
            e2ND_FROM_FRONT_LEFT  :: _2ND_FROM_FRONT_LEFT;
            e2ND_FROM_FRONT_RIGHT :: _2ND_FROM_FRONT_RIGHT;
            e3RD_FROM_FRONT_LEFT  :: _3RD_FROM_FRONT_LEFT;
            e3RD_FROM_FRONT_RIGHT :: _3RD_FROM_FRONT_RIGHT;
            e4TH_FROM_FRONT_LEFT  :: _4TH_FROM_FRONT_LEFT;
            e4TH_FROM_FRONT_RIGHT :: _4TH_FROM_FRONT_RIGHT;
            e5TH_FROM_FRONT_LEFT  :: _5TH_FROM_FRONT_LEFT;
            e5TH_FROM_FRONT_RIGHT :: _5TH_FROM_FRONT_RIGHT;
            e6TH_FROM_FRONT_LEFT  :: _6TH_FROM_FRONT_LEFT;
            e6TH_FROM_FRONT_RIGHT :: _6TH_FROM_FRONT_RIGHT;
            e7TH_FROM_FRONT_LEFT  :: _7TH_FROM_FRONT_LEFT;
            e7TH_FROM_FRONT_RIGHT :: _7TH_FROM_FRONT_RIGHT;
            e8TH_FROM_FRONT_LEFT  :: _8TH_FROM_FRONT_LEFT;
            e8TH_FROM_FRONT_RIGHT :: _8TH_FROM_FRONT_RIGHT;
            e9TH_FROM_FRONT_LEFT  :: _9TH_FROM_FRONT_LEFT;
            e9TH_FROM_FRONT_RIGHT :: _9TH_FROM_FRONT_RIGHT;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief The control inputs for a PxVehicleDriveTank.
    
    \note The values of eANALOG_INPUT_THRUST_LEFT and eANALOG_INPUT_THRUST_RIGHT determine how much
    of the total available drive torque is diverted to the left and right wheels.  These entries in the
    enumerated list represent the state of the left and right control sticks of a tank. The total available
    drive torque available is controlled by eANALOG_INPUT_ACCEL, which represents the state of the acceleration
    pedal and controls how much torque will be applied to the engine.
    
    \note To accelerate forwards eANALOG_INPUT_ACCEL must be greater than zero so that torque is applied to drive the
    engine, while eANALOG_INPUT_THRUST_LEFT and eANALOG_INPUT_THRUST_RIGHT must also be greater than zero
    to divert the available drive torque to the left and wheels. If eANALOG_INPUT_THRUST_LEFT > eANALOG_INPUT_THRUST_RIGHT
    the tank will turn to the right.  If eANALOG_INPUT_THRUST_RIGHT > eANALOG_INPUT_THRUST_LEFT
    the tank will turn to the left.
    
    \see PxVehicleDriveDynData::setAnalogInput, PxVehicleDriveDynData::getAnalogInput
    */
    PxVehicleDriveTankControl :: struct {
        Enum :: enum s32 {
            ANALOG_INPUT_ACCEL             :: 0;
            ANALOG_INPUT_BRAKE_LEFT        :: 1;
            ANALOG_INPUT_BRAKE_RIGHT       :: 2;
            ANALOG_INPUT_THRUST_LEFT       :: 3;
            ANALOG_INPUT_THRUST_RIGHT      :: 4;
            MAX_NB_DRIVETANK_ANALOG_INPUTS :: 5;

            eANALOG_INPUT_ACCEL             :: ANALOG_INPUT_ACCEL;
            eANALOG_INPUT_BRAKE_LEFT        :: ANALOG_INPUT_BRAKE_LEFT;
            eANALOG_INPUT_BRAKE_RIGHT       :: ANALOG_INPUT_BRAKE_RIGHT;
            eANALOG_INPUT_THRUST_LEFT       :: ANALOG_INPUT_THRUST_LEFT;
            eANALOG_INPUT_THRUST_RIGHT      :: ANALOG_INPUT_THRUST_RIGHT;
            eMAX_NB_DRIVETANK_ANALOG_INPUTS :: MAX_NB_DRIVETANK_ANALOG_INPUTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Two driving models are supported.
    
    \note If eSTANDARD is chosen the left and right wheels are always driven in the same direction.  If the tank is in
    a forward gear the left and right wheels will all be driven forwards, while in reverse gear the left and right wheels
    will all be driven backwards. With eSTANDARD the legal range of left and right thrust is (0,1).
    
    \note If eSPECIAL is chosen it is possible to drive the left and right wheels in different directions.
    With eSPECIAL the legal range of left and right thrust is (-1,1).  In forward(reverse) gear negative thrust values drive the wheels
    backwards(forwards), while positive thrust values drives the wheels forwards(backwards).
    
    \note A sharp left turn can be achieved in eSTANDARD mode by braking with the left wheels and thrusting forward with the
    right wheels. A smaller turning circle can theoretically be achieved in eSPECIAL mode by applying negative thrust to the left wheels and positive
    thrust to the right wheels.
    
    \note In both modes the legal ranges of acceleration and left/right brake are all (0,1).
    
    \see PxVehicleDriveTank::setDriveModel
    */
    PxVehicleDriveTankControlModel :: struct {
        Enum :: enum s32 {
            TANDARD :: 0;
            PECIAL  :: 1;

            eSTANDARD :: TANDARD;
            eSPECIAL  :: PECIAL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Data structure with instanced dynamics data and configuration data of a tank.
    */
    PxVehicleDriveTank :: struct {
        #as using pxvehicledrive: PxVehicleDrive;

        /*
        \brief Simulation data that models vehicle components
        \see setup, create
        */
        mDriveSimData: PxVehicleDriveSimData;

        /*
        \brief Drive model
        \see setDriveModel, getDriveModel, PxVehicleDriveTankControlModel
        */
        mDriveModel:   PxVehicleDriveTankControlModel.Enum;

        mPad:          [3] PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Driving surface type. Each PxMaterial is associated with a corresponding PxVehicleDrivableSurfaceType.
    \see PxMaterial, PxVehicleDrivableSurfaceToTireFrictionPairs
    */
    PxVehicleDrivableSurfaceType :: struct {
        anon_enum_6 :: enum s32 {
            eSURFACE_TYPE_UNKNOWN :: -1;
        }

        mType: PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Friction for each combination of driving surface type and tire type.
    \see PxVehicleDrivableSurfaceType, PxVehicleTireData::mType
    */
    PxVehicleDrivableSurfaceToTireFrictionPairs :: struct {
        anon_enum_7 :: enum s32 {
            eMAX_NB_SURFACE_TYPES :: 256;
        }

        /*
        \brief Ptr to base address of a 2d PxReal array with dimensions [mNbSurfaceTypes][mNbTireTypes]
        
        \note Each element of the array describes the maximum friction provided by a surface type-tire type combination.
        eg the friction corresponding to a combination of surface type x and tire type y is  mPairs[x][y]
        */
        mPairs:                    *PxReal;

        /*
        \brief Ptr to 1d array of material ptrs that is of length mNbSurfaceTypes.
        
        \note If the PxMaterial that touches the tire corresponds to mDrivableSurfaceMaterials[x] then the drivable surface
        type is mDrivableSurfaceTypes[x].mType and the friction for that contact is mPairs[mDrivableSurfaceTypes[x].mType][y],
        assuming a tire type y.
        
        \note If the PxMaterial that touches the tire is not found in mDrivableSurfaceMaterials then the friction is
        mPairs[0][y], assuming a tire type y.
        */
        mDrivableSurfaceMaterials: **PxMaterial;

        /*
        \brief Ptr to 1d array of PxVehicleDrivableSurfaceType that is of length mNbSurfaceTypes.
        
        \note If the PxMaterial that touches the tire is found in mDrivableSurfaceMaterials[x] then the drivable surface
        type is mDrivableSurfaceTypes[x].mType and the friction for that contact is mPairs[mDrivableSurfaceTypes[x].mType][y],
        assuming a tire type y.
        
        \note If the PxMaterial that touches the tire is not found in mDrivableSurfaceMaterials then the friction is
        mPairs[0][y], assuming a tire type y.
        */
        mDrivableSurfaceTypes:     *PxVehicleDrivableSurfaceType;

        /*
        \brief A PxSerialObjectId per surface type used internally for serialization.
        */
        mMaterialSerialIds:        *PxSerialObjectId;

        /*
        \brief Number of different driving surface types.
        
        \note mDrivableSurfaceMaterials and mDrivableSurfaceTypes are both 1d arrays of length mMaxNbSurfaceTypes.
        
        \note mNbSurfaceTypes must be less than or equal to mMaxNbSurfaceTypes.
        */
        mNbSurfaceTypes:           PxU32;

        /*
        \brief Maximum number of different driving surface types.
        
        \note mMaxNbSurfaceTypes must be less than or equal to eMAX_NB_SURFACE_TYPES.
        */
        mMaxNbSurfaceTypes:        PxU32;

        /*
        \brief Number of different tire types.
        
        \note Tire types stored in PxVehicleTireData.mType
        */
        mNbTireTypes:              PxU32;

        /*
        \brief Maximum number of different tire types.
        
        \note Tire types stored in PxVehicleTireData.mType
        */
        mMaxNbTireTypes:           PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Structure containing data describing the non-persistent state of each suspension/wheel/tire unit.
    This structure is filled out in PxVehicleUpdates and PxVehicleUpdateSingleVehicleAndStoreTelemetryData
    \see PxVehicleUpdates, PxVehicleUpdateSingleVehicleAndStoreTelemetryData
    */
    PxWheelQueryResult :: struct {
        /*
        \brief Start point of suspension line raycast/sweep used in the raycast/sweep completed immediately before PxVehicleUpdates.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        \see PxVehicleSuspensionRaycasts, PxVehicleSuspensionRaycasts
        */
        suspLineStart:       PxVec3;

        /*
        \brief Directions of suspension line raycast/sweep used in the raycast/sweep completed immediately before PxVehicleUpdates.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        \see PxVehicleSuspensionRaycasts, PxVehicleSuspensionRaycasts
        */
        suspLineDir:         PxVec3;

        /*
        \brief Lengths of suspension line raycast/sweep used in raycast/sweep completed immediately before PxVehicleUpdates.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then 0 is stored.
        \see PxVehicleSuspensionRaycasts, PxVehicleSuspensionRaycasts
        */
        suspLineLength:      PxReal;

        /*
        \brief If suspension travel limits forbid the wheel from touching the drivable surface then isInAir is true.
        \note If the wheel can be placed on the contact plane of the most recent suspension line raycast/sweep then isInAir is false.
        \note If #PxVehicleWheelsSimFlag::eLIMIT_SUSPENSION_EXPANSION_VELOCITY is set, then isInAir will also be true if the suspension
        force is not large enough to expand to the target length in the given simulation time step.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then isInAir
        is computed using the contact plane that was hit by the most recent suspension line raycast/sweep.
        */
        isInAir:             bool;

        /*
        \brief PxActor instance of the driving surface under the corresponding vehicle wheel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireContactActor is NULL.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then NULL is stored.
        */
        tireContactActor:    *PxActor;

        /*
        \brief PxShape instance of the driving surface under the corresponding vehicle wheel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireContactShape is NULL.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then NULL is stored.
        */
        tireContactShape:    *PxShape;

        /*
        \brief PxMaterial instance of the driving surface under the corresponding vehicle wheel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireSurfaceMaterial is NULL.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then NULL is stored.
        */
        tireSurfaceMaterial: *PxMaterial;

        /*
        \brief Surface type integer that corresponds to the mapping between tireSurfaceMaterial and integer as
        described in PxVehicleDrivableSurfaceToTireFrictionPairs.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireSurfaceType is
        PxVehicleDrivableSurfaceType::eSURFACE_TYPE_UNKNOWN.
        \note If no raycast/sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then
        PxVehicleDrivableSurfaceType::eSURFACE_TYPE_UNKNOWN is stored.
        \see PxVehicleDrivableSurfaceToTireFrictionPairs
        */
        tireSurfaceType:     PxU32;

        /*
        \brief Point on the drivable surface hit by the most recent suspension raycast or sweep.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the contact point is (0,0,0).
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        */
        tireContactPoint:    PxVec3;

        /*
        \brief Normal on the drivable surface at the hit point of the most recent suspension raycast or sweep.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the contact normal is (0,0,0).
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then (0,0,0) is stored.
        */
        tireContactNormal:   PxVec3;

        /*
        \brief Friction experienced by the tire for the combination of tire type and surface type after accounting
        for the friction vs slip graph.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the tire friction is 0.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        stored tire friction is the value computed in PxVehicleUpdates that immediately followed the last raycast or sweep.
        \see PxVehicleDrivableSurfaceToTireFrictionPairs, PxVehicleTireData
        */
        tireFriction:        PxReal;

        /*
        \brief Compression of the suspension spring.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the jounce is -PxVehicleSuspensionData.mMaxDroop
        The jounce can never exceed PxVehicleSuspensionData.mMaxCompression. Positive values result when the suspension is compressed from
        the rest position, while negative values mean the suspension is elongated from the rest position.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        suspension compression is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        suspJounce:          PxReal;

        /*
        \brief Magnitude of force applied by the suspension spring along the direction of suspension travel.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then the force is 0
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        suspension spring force is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        \see PxVehicleWheelsSimData::getSuspTravelDirection
        */
        suspSpringForce:     PxReal;

        /*
        \brief Forward direction of the wheel/tire accounting for steer/toe/camber angle projected on to the contact plane of the drivable surface.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireLongitudinalDir is (0,0,0)
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire longitudinal direction is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        tireLongitudinalDir: PxVec3;

        /*
        \brief Lateral direction of the wheel/tire accounting for steer/toe/camber angle projected on to the contact plan of the drivable surface.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then tireLateralDir is (0,0,0)
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire lateral direction is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        tireLateralDir:      PxVec3;

        /*
        \brief Longitudinal slip of the tire.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then longitudinalSlip is 0.0
        \note The longitudinal slip is approximately (w*r - vz) / PxAbs(vz) where w is the angular speed of the wheel, r is the radius of the wheel, and
        vz component of rigid body velocity computed at the wheel base along the longitudinal direction of the tire.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire longitudinal slip is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        longitudinalSlip:    PxReal;

        /*
        \brief Lateral slip of the tire.
        \note If suspension travel limits forbid the wheel from touching the drivable surface then lateralSlip is 0.0
        \note The lateral slip angle is approximately PxAtan(vx / PxAbs(vz)) where vx and vz are the components of rigid body velocity at the wheel base
        along the wheel's lateral and longitudinal directions, respectively.
        \note If no raycast or sweep for the corresponding suspension was performed immediately prior to PxVehicleUpdates then the
        tire lateral slip is computed using the contact plane that was hit by the most recent suspension line raycast or sweep.
        */
        lateralSlip:         PxReal;

        /*
        \brief Steer angle of the wheel about the "up" vector accounting for input steer and toe and, if applicable, Ackermann steer correction.
        \see PxVehicleWheelData::mToeAngle
        */
        steerAngle:          PxReal;

        /*
        \brief Local pose of the wheel.
        */
        localPose:           PxTransform;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleWheelQueryResult :: struct {
        /*
        \brief Pointer to an PxWheelQueryResult buffer of length nbWheelQueryResults
        The wheelQueryResults buffer must persist until the end of PxVehicleUpdates
        A NULL pointer is permitted.
        The wheelQueryResults buffer is left unmodified in PxVehicleUpdates for vehicles with sleeping rigid bodies
        whose control inputs indicate they should remain inert.
        \see PxVehicleUpdates
        */
        wheelQueryResults:   *PxWheelQueryResult;

        /*
        \brief The length of the wheelQueryResults buffer.  This value corresponds to the
        number of wheels in the associated vehicle in PxVehicleUpdates.
        */
        nbWheelQueryResults: PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Structure containing data that is computed for a wheel during concurrent calls to PxVehicleUpdates or
    PxVehicleUpdateSingleVehicleAndStoreTelemetryData but which cannot be safely concurrently applied.
    
    \see PxVehicleUpdates, PxVehicleUpdateSingleVehicleAndStoreTelemetryData, PxVehiclePostUpdates, PxVehicleConcurrentUpdate
    */
    PxVehicleWheelConcurrentUpdateData :: struct {
        localPose:             PxTransform;
        hitActor:              *PxRigidDynamic;
        hitActorForce:         PxVec3;
        hitActorForcePosition: PxVec3;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Structure containing data that is computed for a vehicle and its wheels during concurrent calls to PxVehicleUpdates or
    PxVehicleUpdateSingleVehicleAndStoreTelemetryData but which cannot be safely concurrently applied.
    
    \see PxVehicleUpdates, PxVehicleUpdateSingleVehicleAndStoreTelemetryData, PxVehiclePostUpdates, PxVehicleWheelConcurrentUpdateData
    */
    PxVehicleConcurrentUpdateData :: struct {
        /*
        \brief Pointer to an PxVehicleWheelConcurrentUpdate buffer of length nbConcurrentWheelUpdates
        The concurrentWheelUpdates buffer must persist until the end of PxVehiclePostUpdates
        A NULL pointer is not permitted.
        \see PxVehicleUpdates, PxVehiclePostUpdates
        */
        concurrentWheelUpdates:   *PxVehicleWheelConcurrentUpdateData;

        /*
        \brief The length of the concurrentWheelUpdates buffer.  This value corresponds to the
        number of wheels in the associated vehicle passed to PxVehicleUpdates.
        */
        nbConcurrentWheelUpdates: PxU32;

        linearMomentumChange:     PxVec3;
        angularMomentumChange:    PxVec3;
        staySleeping:             bool;
        wakeup:                   bool;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief Data structure describing configuration data of a vehicle with up to PX_MAX_NB_WHEELS driven equally through the differential. The vehicle has an
    engine, clutch, gears, autobox, differential.
    \see PxVehicleDriveSimData
    */
    PxVehicleDriveSimDataNW :: struct {
        #as using pxvehicledrivesimdata: PxVehicleDriveSimData;

        /*
        \brief Differential simulation data
        \see setDiffData, getDiffData
        */
        mDiff: PxVehicleDifferentialNWData;
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief The control inputs for a PxVehicleDriveNW.
    
    \see PxVehicleDriveDynData::setAnalogInput, PxVehicleDriveDynData::getAnalogInput
    */
    PxVehicleDriveNWControl :: struct {
        Enum :: enum s32 {
            ANALOG_INPUT_ACCEL           :: 0;
            ANALOG_INPUT_BRAKE           :: 1;
            ANALOG_INPUT_HANDBRAKE       :: 2;
            ANALOG_INPUT_STEER_LEFT      :: 3;
            ANALOG_INPUT_STEER_RIGHT     :: 4;
            MAX_NB_DRIVENW_ANALOG_INPUTS :: 5;

            eANALOG_INPUT_ACCEL           :: ANALOG_INPUT_ACCEL;
            eANALOG_INPUT_BRAKE           :: ANALOG_INPUT_BRAKE;
            eANALOG_INPUT_HANDBRAKE       :: ANALOG_INPUT_HANDBRAKE;
            eANALOG_INPUT_STEER_LEFT      :: ANALOG_INPUT_STEER_LEFT;
            eANALOG_INPUT_STEER_RIGHT     :: ANALOG_INPUT_STEER_RIGHT;
            eMAX_NB_DRIVENW_ANALOG_INPUTS :: MAX_NB_DRIVENW_ANALOG_INPUTS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with up to PX_MAX_NB_WHEELS driven wheels.
    */
    PxVehicleDriveNW :: struct {
        #as using pxvehicledrive: PxVehicleDrive;

        /*
        \brief Simulation data that describes the configuration of the vehicle's drive model.
        \see setup, create
        */
        mDriveSimData: PxVehicleDriveSimDataNW;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Used to produce smooth steering values in the presence of discontinuities when a vehicle e.g. lands on the ground.
    Use a zero sharpness value to disable the feature (backward compatibility with previous PhysX versions).
    */
    PxVehicleSteerFilter :: struct {
        mSharpness:        PxReal;
        mFilteredMaxSteer: PxReal;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Used to produce smooth vehicle driving control values from key inputs.
    \see PxVehicle4WSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicle4WSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleKeySmoothingData :: struct {
        /*
        \brief Rise rate of each analog value if digital value is 1
        */
        mRiseRates: [16] PxReal;

        /*
        \brief Fall rate of each analog value if digital value is 0
        */
        mFallRates: [16] PxReal;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Used to produce smooth analog vehicle control values from analog inputs.
    \see PxVehicleDrive4WSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDrive4WSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehiclePadSmoothingData :: struct {
        /*
        \brief Rise rate of each analog value from previous value towards target if target>previous
        */
        mRiseRates: [16] PxReal;

        /*
        \brief Rise rate of each analog value from previous value towards target if target<previous
        */
        mFallRates: [16] PxReal;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Used to produce smooth vehicle driving control values from analog and digital inputs.
    \see PxVehicleDrive4WSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDrive4WSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleDrive4WRawInputData :: struct {
        vtable: *PxVehicleDrive4WRawInputData_VTable;
        mRawDigitalInputs: [5] bool;
        mRawAnalogInputs:  [5] PxReal;

        mGearUp:           bool;
        mGearDown:         bool;
    }
    PxVehicleDrive4WRawInputData_VTable :: struct #type_info_none {
        Destructor: (this: *PxVehicleDrive4WRawInputData, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }
    PxVehicleDrive4WRawInputData_Destructor :: inline (this: *PxVehicleDrive4WRawInputData, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxVehicleDrive4WRawInputData) -> *PxVehicleDrive4WRawInputData_VTable { return obj.vtable; }


    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Used to produce smooth vehicle driving control values from analog and digital inputs.
    \see PxVehicleDriveNWSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDriveNWSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleDriveNWRawInputData :: struct {
        #as using pxvehicledrive4wrawinputdata: PxVehicleDrive4WRawInputData;
    }

    /*
    \brief Used to produce smooth analog tank control values from analog and digital inputs.
    \see PxVehicleDriveTankSmoothDigitalRawInputsAndSetAnalogInputs, PxVehicleDriveTankSmoothAnalogRawInputsAndSetAnalogInputs
    */
    PxVehicleDriveTankRawInputData :: struct {
        mMode:             PxVehicleDriveTankControlModel.Enum;

        mRawAnalogInputs:  [5] PxReal;
        mRawDigitalInputs: [5] bool;

        mGearUp:           bool;
        mGearDown:         bool;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Used by PxVehicleCopyDynamicsData
    \see PxVehicleCopyDynamicsData
    */
    PxVehicleCopyDynamicsMap :: struct {
        sourceWheelIds: [20] PxU8;
        targetWheelIds: [20] PxU8;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleGraphDesc :: struct {
        /*
        \brief x-coord of graph centre.
        <b>Range:</b> (0,1)<br>
        */
        mPosX:            PxReal;

        /*
        \brief y-coord of graph centre.
        <b>Range:</b> (0,1)<br>
        */
        mPosY:            PxReal;

        /*
        \brief x-extents of graph (from mPosX-0.5f*mSizeX to mPosX+0.5f*mSizeX).
        <b>Range:</b> (0,1)<br>
        */
        mSizeX:           PxReal;

        /*
        \brief y-extents of graph (from mPosY-0.5f*mSizeY to mPosY+0.5f*mSizeY).
        <b>Range:</b> (0,1)<br>
        */
        mSizeY:           PxReal;

        /*
        \brief Background color of graph.
        */
        mBackgroundColor: PxVec3;

        /*
        \brief Alpha value of background color.
        */
        mAlpha:           PxReal;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleGraphChannelDesc :: struct {
        /*
        \brief Data values less than mMinY will be clamped at mMinY.
        */
        mMinY:      PxReal;

        /*
        \brief Data values greater than mMaxY will be clamped at mMaxY.
        */
        mMaxY:      PxReal;

        /*
        \brief Data values greater than mMidY will be drawn with color mColorHigh.
        Data values less than mMidY will be drawn with color mColorLow.
        */
        mMidY:      PxReal;

        /*
        \brief Color used to render data values lower than mMidY.
        */
        mColorLow:  PxVec3;

        /*
        \brief Color used to render data values greater than mMidY.
        */
        mColorHigh: PxVec3;

        /*
        \brief String to describe data channel.
        */
        mTitle:     *u8;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleWheelGraphChannel :: struct {
        Enum :: enum s32 {
            JOUNCE                    :: 0;
            SUSPFORCE                 :: 1;
            TIRELOAD                  :: 2;
            NORMALIZED_TIRELOAD       :: 3;
            WHEEL_OMEGA               :: 4;
            TIRE_FRICTION             :: 5;
            TIRE_LONG_SLIP            :: 6;
            NORM_TIRE_LONG_FORCE      :: 7;
            TIRE_LAT_SLIP             :: 8;
            NORM_TIRE_LAT_FORCE       :: 9;
            NORM_TIRE_ALIGNING_MOMENT :: 10;
            MAX_NB_WHEEL_CHANNELS     :: 11;

            eJOUNCE                    :: JOUNCE;
            eSUSPFORCE                 :: SUSPFORCE;
            eTIRELOAD                  :: TIRELOAD;
            eNORMALIZED_TIRELOAD       :: NORMALIZED_TIRELOAD;
            eWHEEL_OMEGA               :: WHEEL_OMEGA;
            eTIRE_FRICTION             :: TIRE_FRICTION;
            eTIRE_LONG_SLIP            :: TIRE_LONG_SLIP;
            eNORM_TIRE_LONG_FORCE      :: NORM_TIRE_LONG_FORCE;
            eTIRE_LAT_SLIP             :: TIRE_LAT_SLIP;
            eNORM_TIRE_LAT_FORCE       :: NORM_TIRE_LAT_FORCE;
            eNORM_TIRE_ALIGNING_MOMENT :: NORM_TIRE_ALIGNING_MOMENT;
            eMAX_NB_WHEEL_CHANNELS     :: MAX_NB_WHEEL_CHANNELS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleDriveGraphChannel :: struct {
        Enum :: enum s32 {
            ENGINE_REVS           :: 0;
            ENGINE_DRIVE_TORQUE   :: 1;
            CLUTCH_SLIP           :: 2;
            ACCEL_CONTROL         :: 3;
            BRAKE_CONTROL         :: 4;
            HANDBRAKE_CONTROL     :: 5;
            STEER_LEFT_CONTROL    :: 6;
            STEER_RIGHT_CONTROL   :: 7;
            GEAR_RATIO            :: 8;
            MAX_NB_DRIVE_CHANNELS :: 9;

            eENGINE_REVS           :: ENGINE_REVS;
            eENGINE_DRIVE_TORQUE   :: ENGINE_DRIVE_TORQUE;
            eCLUTCH_SLIP           :: CLUTCH_SLIP;
            eACCEL_CONTROL         :: ACCEL_CONTROL;
            eBRAKE_CONTROL         :: BRAKE_CONTROL;
            eHANDBRAKE_CONTROL     :: HANDBRAKE_CONTROL;
            eSTEER_LEFT_CONTROL    :: STEER_LEFT_CONTROL;
            eSTEER_RIGHT_CONTROL   :: STEER_RIGHT_CONTROL;
            eGEAR_RATIO            :: GEAR_RATIO;
            eMAX_NB_DRIVE_CHANNELS :: MAX_NB_DRIVE_CHANNELS;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleGraphType :: struct {
        Enum :: enum s32 {
            WHEEL :: 0;
            DRIVE :: 1;

            eWHEEL :: WHEEL;
            eDRIVE :: DRIVE;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleGraph :: struct {
        anon_enum_8 :: enum s32 {
            eMAX_NB_SAMPLES :: 256;
        }

        anon_enum_9 :: enum s32 {
            eMAX_NB_TITLE_CHARS :: 256;
        }

        anon_enum_10 :: enum s32 {
            eMAX_NB_CHANNELS :: 12;
        }

        //Min and max of each sample.
        mChannelMinY:      [12] PxReal;
        mChannelMaxY:      [12] PxReal;

        //Discriminate between high and low values with different colors.
        mChannelMidY:      [12] PxReal;

        //Different colors for values than midY and less than midY.
        mChannelColorLow:  [12] PxVec3;
        mChannelColorHigh: [12] PxVec3;

        //Title of graph
        mChannelTitle:     [12] [256] u8;

        //Graph data.
        mChannelSamples:   [12] [256] PxReal;

        //Background color,alpha,coords
        mBackgroundColor:  PxVec3;
        mBackgroundAlpha:  PxReal;
        mBackgroundMinX:   PxReal;
        mBackgroundMaxX:   PxReal;
        mBackgroundMinY:   PxReal;
        mBackgroundMaxY:   PxReal;

        mSampleTide:       PxU32;

        mNbChannels:       PxU32;

        mPad:              [2] PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    */
    PxVehicleTelemetryData :: struct {
        /*
        \brief Graph data for engine.
        Used for storing single timeslices of debug data for engine graph.
        \see PxVehicleGraph
        */
        mEngineGraph:        *PxVehicleGraph;

        /*
        \brief Graph data for each wheel.
        Used for storing single timeslices of debug data for wheel graphs.
        \see PxVehicleGraph
        */
        mWheelGraphs:        *PxVehicleGraph;

        /*
        \brief Application point of tire forces.
        */
        mTireforceAppPoints: *PxVec3;

        /*
        \brief Application point of susp forces.
        */
        mSuspforceAppPoints: *PxVec3;

        /*
        \brief Total number of active wheels
        */
        mNbActiveWheels:     PxU32;

        mPad:                [3] PxU32;
    }

    /*
    \deprecated This API is deprecated and is replaced by a new API, see the Vehicles section in the 4.0 to 5.1 migration guide.
    \brief Data structure with instanced dynamics data and configuration data of a vehicle with no drive model.
    */
    PxVehicleNoDrive :: struct {
        #as using pxvehiclewheels: PxVehicleWheels;

        mSteerAngles:  *PxReal;
        mDriveTorques: *PxReal;
        mBrakeTorques: *PxReal;

        mPad:          [2] PxU32;
    }

    /*
    \brief types of instrumentation that PVD can do.
    */
    PxPvdInstrumentationFlag :: struct {
        Enum :: enum s32 {
            DEBUG   :: 1;

            PROFILE :: 2;

            MEMORY  :: 4;

            ALL     :: 7;

            eDEBUG   :: DEBUG;

            ePROFILE :: PROFILE;

            eMEMORY  :: MEMORY;

            eALL     :: ALL;
        }
        __empty_struct_padding: u8; // C++ makes empty structs have length 1
    }

    /*
    \brief Bitfield that contains a set of raised flags defined in PxPvdInstrumentationFlag.
    
    \see PxPvdInstrumentationFlag
    */
    PxPvdInstrumentationFlags :: PxFlags(PxPvdInstrumentationFlag.Enum, u8);

    /*
    \brief PxPvd is the top-level class for the PVD framework, and the main customer interface for PVD
    configuration.It is a singleton class, instantiated and owned by the application.
    */
    PxPvd :: struct {
        #as using pxprofilercallback: PxProfilerCallback;
        #place pxprofilercallback; pxpvd_vtable: *PxPvd_VTable;
    }
    PxPvd_VTable :: struct #type_info_none {
        using pxprofilercallback: PxProfilerCallback_VTable;
        connect: (this: *PxPvd, transport: *PxPvdTransport, flags: PxPvdInstrumentationFlags) -> bool #cpp_method;

        disconnect: (this: *PxPvd) -> void #cpp_method;

        isConnected: (this: *PxPvd, useCachedStatus := true) -> bool #cpp_method;

        getTransport: (this: *PxPvd) -> *PxPvdTransport #cpp_method;

        getInstrumentationFlags: (this: *PxPvd) -> PxPvdInstrumentationFlags #cpp_method;

        release: (this: *PxPvd) -> void #cpp_method;
    }

    PxPvd_connect :: inline (this: *PxPvd, transport: *PxPvdTransport, flags: PxPvdInstrumentationFlags) -> bool { return this.pxpvd_vtable.connect(this, transport, flags); }

    PxPvd_disconnect :: inline (this: *PxPvd) { this.pxpvd_vtable.disconnect(this); }

    PxPvd_isConnected :: inline (this: *PxPvd, useCachedStatus := true) -> bool { return this.pxpvd_vtable.isConnected(this, useCachedStatus); }

    PxPvd_getTransport :: inline (this: *PxPvd) -> *PxPvdTransport { return this.pxpvd_vtable.getTransport(this); }

    PxPvd_getInstrumentationFlags :: inline (this: *PxPvd) -> PxPvdInstrumentationFlags { return this.pxpvd_vtable.getInstrumentationFlags(this); }

    PxPvd_release :: inline (this: *PxPvd) { this.pxpvd_vtable.release(this); }

    vtable :: (obj: *PxPvd) -> *PxPvd_VTable { return obj.pxpvd_vtable; }


    /*
    \brief	PxPvdTransport is an interface representing the data transport mechanism.
    This class defines all services associated with the transport: configuration, connection, reading, writing etc.
    It is owned by the application, and can be realized as a file or a socket (using one-line PxDefault<...> methods in
    PhysXExtensions) or in a custom implementation. This is a class that is intended for use by PVD, not by the
    application, the application entry points are PxPvd and PvdClient.
    */
    PxPvdTransport :: struct {
        vtable: *PxPvdTransport_VTable;
    }
    PxPvdTransport_VTable :: struct #type_info_none {
        connect: (this: *PxPvdTransport) -> bool #cpp_method;

        disconnect: (this: *PxPvdTransport) -> void #cpp_method;

        isConnected: (this: *PxPvdTransport) -> bool #cpp_method;

        write: (this: *PxPvdTransport, inBytes: *u8, inLength: u32) -> bool #cpp_method;

        lock: (this: *PxPvdTransport) -> *PxPvdTransport #cpp_method;

        unlock: (this: *PxPvdTransport) -> void #cpp_method;

        flush: (this: *PxPvdTransport) -> void #cpp_method;

        getWrittenDataSize: (this: *PxPvdTransport) -> u64 #cpp_method;

        release: (this: *PxPvdTransport) -> void #cpp_method;

        Destructor: (this: *PxPvdTransport, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;
    }

    PxPvdTransport_connect :: inline (this: *PxPvdTransport) -> bool { return this.vtable.connect(this); }

    PxPvdTransport_disconnect :: inline (this: *PxPvdTransport) { this.vtable.disconnect(this); }

    PxPvdTransport_isConnected :: inline (this: *PxPvdTransport) -> bool { return this.vtable.isConnected(this); }

    PxPvdTransport_write :: inline (this: *PxPvdTransport, inBytes: *u8, inLength: u32) -> bool { return this.vtable.write(this, inBytes, inLength); }

    PxPvdTransport_lock :: inline (this: *PxPvdTransport) -> *PxPvdTransport { return this.vtable.lock(this); }

    PxPvdTransport_unlock :: inline (this: *PxPvdTransport) { this.vtable.unlock(this); }

    PxPvdTransport_flush :: inline (this: *PxPvdTransport) { this.vtable.flush(this); }

    PxPvdTransport_getWrittenDataSize :: inline (this: *PxPvdTransport) -> u64 { return this.vtable.getWrittenDataSize(this); }

    PxPvdTransport_release :: inline (this: *PxPvdTransport) { this.vtable.release(this); }

    PxPvdTransport_Destructor :: inline (this: *PxPvdTransport, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

    vtable :: (obj: *PxPvdTransport) -> *PxPvdTransport_VTable { return obj.vtable; }

}

/*
\brief Creates an instance of the foundation class

The foundation class is needed to initialize higher level SDKs. There may be only one instance per process.
Calling this method after an instance has been created already will result in an error message and NULL will be
returned.

\param version Version number we are expecting (should be #PX_PHYSICS_VERSION)
\param allocator User supplied interface for allocating memory(see #PxAllocatorCallback)
\param errorCallback User supplied interface for reporting errors and displaying messages(see #PxErrorCallback)
\return Foundation instance on success, NULL if operation failed

\see PxFoundation
*/
PxCreateFoundation :: (version: physx.PxU32, allocator: *physx.PxAllocatorCallback, errorCallback: *physx.PxErrorCallback) -> *physx.PxFoundation #foreign physxfoundation_static;

PxSetFoundationInstance :: (foundation: *physx.PxFoundation) -> void #foreign physxfoundation_static;

PxGetFoundation :: () -> *physx.PxFoundation #foreign physxfoundation_static;

/*
\brief Similar to PxGetFoundation() except it handles the case if the foundation was not created already.
\return Pointer to the foundation if an instance is currently available, otherwise null.

\see PxCreateFoundation(), PxGetFoundation()
*/
PxIsFoundationValid :: () -> *physx.PxFoundation #foreign physxfoundation_static;

/*
\brief Get the callback that will be used for all profiling.
*/
PxGetProfilerCallback :: () -> *physx.PxProfilerCallback #foreign physxfoundation_static;

/*
\brief Set the callback that will be used for all profiling.
*/
PxSetProfilerCallback :: (profiler: *physx.PxProfilerCallback) -> void #foreign physxfoundation_static;

/*
\brief Get the allocator callback
*/
PxGetAllocatorCallback :: () -> *physx.PxAllocatorCallback #foreign physxfoundation_static;

/*
\brief Get the broadcasting allocator callback
*/
PxGetBroadcastAllocator :: (reportAllocationNames: *bool = null) -> *physx.PxAllocatorCallback #foreign physxfoundation_static;

/*
\brief Get the error callback
*/
PxGetErrorCallback :: () -> *physx.PxErrorCallback #foreign physxfoundation_static;

/*
\brief Get the broadcasting error callback
*/
PxGetBroadcastError :: () -> *physx.PxErrorCallback #foreign physxfoundation_static;

/*
\brief Get the warn once timestamp
*/
PxGetWarnOnceTimeStamp :: () -> physx.PxU32 #foreign physxfoundation_static;

/*
\brief Decrement the ref count of PxFoundation
*/
PxDecFoundationRefCount :: () -> void #foreign physxfoundation_static;

/*
\brief Increment the ref count of PxFoundation
*/
PxIncFoundationRefCount :: () -> void #foreign physxfoundation_static;

/*
\brief Creates a collection object.

Objects can only be serialized or deserialized through a collection.
For serialization, users must add objects to the collection and serialize the collection as a whole.
For deserialization, the system gives back a collection of deserialized objects to users.

\return The new collection object.

\see PxCollection, PxCollection::release()
*/
PxCreateCollection :: () -> *physx.PxCollection #foreign physxcommon_static;

CUdeviceptr :: u64;

CUdevice :: s32;

CUctx_st :: struct {}
CUcontext :: *CUctx_st;
CUmod_st :: struct {}
CUmodule :: *CUmod_st;
CUfunc_st :: struct {}
CUfunction :: *CUfunc_st;
CUstream_st :: struct {}
CUstream :: *CUstream_st;
CUevent_st :: struct {}
CUevent :: *CUevent_st;
CUgraphicsResource_st :: struct {}
CUgraphicsResource :: *CUgraphicsResource_st;

/*
\brief PxGpuLoadHook

This is a helper class for loading the PhysXGpu dll.
If a PhysXGpu dll with a non-default file name needs to be loaded,
PxGpuLoadHook can be sub-classed to provide the custom filenames.

Once the names are set, the instance must be set for use by PhysX.dll using PxSetPhysXGpuLoadHook(),

\see PxSetPhysXGpuLoadHook()
*/
PxGpuLoadHook :: struct {
    vtable: *PxGpuLoadHook_VTable;
}
PxGpuLoadHook_VTable :: struct #type_info_none {
    Destructor: (this: *PxGpuLoadHook, flags: Msvc_Destructor_Flags = .NONE) -> void #cpp_method;

    getPhysXGpuDllName: (this: *PxGpuLoadHook) -> *u8 #cpp_method;
}

PxGpuLoadHook_Destructor :: inline (this: *PxGpuLoadHook, flags: Msvc_Destructor_Flags = .NONE) { this.vtable.Destructor(this, flags); }

PxGpuLoadHook_getPhysXGpuDllName :: inline (this: *PxGpuLoadHook) -> *u8 { return this.vtable.getPhysXGpuDllName(this); }

vtable :: (obj: *PxGpuLoadHook) -> *PxGpuLoadHook_VTable { return obj.vtable; }


/*
\brief Sets GPU load hook instance for PhysX dll.

\param[in] hook GPU load hook.

\see PxGpuLoadHook
*/
PxSetPhysXGpuLoadHook :: (hook: *PxGpuLoadHook) -> void #foreign physx_static;

/*
* \brief Ask the NVIDIA control panel which GPU has been selected for use by
* PhysX.  Returns -1 if no PhysX capable GPU is found or GPU PhysX has
* been disabled.
*/
PxGetSuggestedCudaDeviceOrdinal :: (errc: *physx.PxErrorCallback) -> s32 #foreign physx_static;

/*
* \brief Allocate a CUDA Context manager, complete with heaps.
* You only need one CUDA context manager per GPU device you intend to use for
* CUDA tasks.
\param[in] foundation PhysXFoundation instance.
\param[in] desc Cuda context manager desc.
\param[in] profilerCallback PhysX profiler callback instance.
\param[in] launchSynchronous Set launchSynchronous to true for CUDA to report the actual point of failure.

\see PxGetProfilerCallback()
*/
PxCreateCudaContextManager :: (foundation: *physx.PxFoundation, desc: *physx.PxCudaContextManagerDesc, profilerCallback: *physx.PxProfilerCallback = null, launchSynchronous := false) -> *physx.PxCudaContextManager #foreign physx_static;
PxCreateCudaContextManager :: (foundation: *physx.PxFoundation, desc: physx.PxCudaContextManagerDesc, profilerCallback: *physx.PxProfilerCallback = null, launchSynchronous := false) -> *physx.PxCudaContextManager #no_context {
    return PxCreateCudaContextManager(foundation, *desc, profilerCallback, launchSynchronous);
}

/*
* \brief Sets profiler callback to PhysX GPU
\param[in] profilerCallback PhysX profiler callback instance.

\see PxGetProfilerCallback()
*/
PxSetPhysXGpuProfilerCallback :: (profilerCallback: *physx.PxProfilerCallback) -> void #foreign physx_static;

/*
\brief Internally used callback to register function names of cuda kernels
*/
PxCudaRegisterFunction :: (moduleIndex: s32, functionName: *u8) -> void #foreign physx_static;

/*
\brief Internally used callback to register cuda modules at load time
*/
PxCudaRegisterFatBinary :: (unknown0: *void) -> **void #foreign physx_static;

/*
\brief Access to the registered cuda modules
*/
PxGetCudaModuleTable :: () -> **void #foreign physx_static;

/*
\brief Number of registered cuda modules
*/
PxGetCudaModuleTableSize :: () -> physx.PxU32 #foreign physx_static;

/*
\brief Access to the loaded cuda functions (kernels)
*/
PxGetCudaFunctionTable :: () -> *physx.PxKernelIndex #foreign physx_static;

/*
\brief Number of loaded cuda functions (kernels)
*/
PxGetCudaFunctionTableSize :: () -> physx.PxU32 #foreign physx_static;

PxGetPhysicsGpu :: () -> *physx.PxPhysicsGpu #foreign physx_static;

/*
\brief Create a particle cloth preprocessor.
\deprecated Particle-cloth, -rigids, -attachments and -volumes have been deprecated.
\param[in] cudaContextManager A cuda context manager.

See #PxParticleClothDesc, #PxPartitionedParticleCloth.
*/
PxCreateParticleClothPreProcessor :: (cudaContextManager: *physx.PxCudaContextManager) -> *physx.PxParticleClothPreProcessor #foreign physx_static;

/*
\brief Creates an instance of the physics SDK.

Creates an instance of this class. May not be a class member to avoid name mangling.
Pass the constant #PX_PHYSICS_VERSION as the argument.
There may be only one instance of this class per process. Calling this method after an instance
has been created already will result in an error message and NULL will be returned.

\param version Version number we are expecting (should be #PX_PHYSICS_VERSION)
\param foundation Foundation instance (see PxFoundation)
\param scale values used to determine default tolerances for objects at creation time
\param trackOutstandingAllocations true if you want to track memory allocations
so a debugger connection partway through your physics simulation will get
an accurate map of everything that has been allocated so far. This could have a memory
and performance impact on your simulation hence it defaults to off.
\param pvd When pvd points to a valid PxPvd instance (PhysX Visual Debugger), a connection to the specified PxPvd instance is created.
If pvd is NULL no connection will be attempted.
\param omniPvd When omniPvd points to a valid PxOmniPvd instance PhysX will sample its internal structures to the defined OmniPvd output streams
set in the PxOmniPvd object.
\return PxPhysics instance on success, NULL if operation failed

\see PxPhysics
*/
PxCreatePhysics :: (version: physx.PxU32, foundation: *physx.PxFoundation, scale: *physx.PxTolerancesScale, trackOutstandingAllocations := false, pvd: *physx.PxPvd = null, omniPvd: *physx.PxOmniPvd = null) -> *physx.PxPhysics #foreign physx_static;
PxCreatePhysics :: (version: physx.PxU32, foundation: *physx.PxFoundation, scale: physx.PxTolerancesScale, trackOutstandingAllocations := false, pvd: *physx.PxPvd = null, omniPvd: *physx.PxOmniPvd = null) -> *physx.PxPhysics #no_context {
    return PxCreatePhysics(version, foundation, *scale, trackOutstandingAllocations, pvd, omniPvd);
}

PxGetPhysics :: () -> *physx.PxPhysics #foreign physx_static;

/*
\brief Creates the controller manager.

\param[in] scene			PhysX scene. You can only create one PxControllerManager per scene.
\param[in] lockingEnabled	Enables/disables internal locking.

\return New controller manager, or NULL in case of failure (e.g. when a manager has already been created for that scene)

The character controller is informed by #PxDeletionListener::onRelease() when actors or shapes are released, and updates its internal
caches accordingly. If character controller movement or a call to #PxControllerManager::shiftOrigin() may overlap with actor/shape releases,
internal data structures must be guarded against concurrent access.

Locking guarantees thread safety in such scenarios.

\note locking may result in significant slowdown for release of actors or shapes.

By default, locking is disabled.
*/
PxCreateControllerManager :: (scene: *physx.PxScene, lockingEnabled := false) -> *physx.PxControllerManager #foreign physxcharacterkinematic_static;

/*
\brief Gets standalone object insertion interface.

This interface allows the creation of standalone objects that can exist without a PxPhysics or PxScene object.

\see PxCreateTriangleMesh PxCreateHeightfield PxCreateTetrahedronMesh PxCreateBVH
*/
PxGetStandaloneInsertionCallback :: () -> *physx.PxInsertionCallback #foreign physxcooking_static;

/*
\brief Cooks a bounding volume hierarchy. The results are written to the stream.

PxCookBVH() allows a BVH description to be cooked into a binary stream
suitable for loading and performing BVH detection at runtime.

\param[in] desc		The BVH descriptor.
\param[in] stream	User stream to output the cooked data.
\return true on success.

\see PxBVH PxRigidActorExt::getRigidActorShapeLocalBoundsList
*/
PxCookBVH :: (desc: *physx.PxBVHDesc, stream: *physx.PxOutputStream) -> bool #foreign physxcooking_static;
PxCookBVH :: (desc: physx.PxBVHDesc, stream: *physx.PxOutputStream) -> bool #no_context {
    return PxCookBVH(*desc, stream);
}

/*
\brief Cooks and creates a bounding volume hierarchy without going through a stream.

\note This method does the same as PxCookBVH, but the produced BVH is not stored
into a stream but is either directly inserted in PxPhysics, or created as a standalone
object. Use this method if you are unable to cook offline.

\note PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback()
or PxGetStandaloneInsertionCallback().

\param[in] desc					The BVH descriptor.
\param[in] insertionCallback	The insertion interface.
\return PxBVH pointer on success

\see PxCookBVH() PxInsertionCallback
*/
PxCreateBVH :: (desc: *physx.PxBVHDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxBVH #foreign physxcooking_static;
PxCreateBVH :: (desc: physx.PxBVHDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxBVH #no_context {
    return PxCreateBVH(*desc, insertionCallback);
}

/*
\brief Cooks a heightfield. The results are written to the stream.

To create a heightfield object there is an option to precompute some of calculations done while loading the heightfield data.

PxCookHeightField() allows a heightfield description to be cooked into a binary stream
suitable for loading and performing collision detection at runtime.

\param[in] desc		The heightfield descriptor to read the HF from.
\param[in] stream	User stream to output the cooked data.
\return true on success

\see PxPhysics.createHeightField()
*/
PxCookHeightField :: (desc: *physx.PxHeightFieldDesc, stream: *physx.PxOutputStream) -> bool #foreign physxcooking_static;
PxCookHeightField :: (desc: physx.PxHeightFieldDesc, stream: *physx.PxOutputStream) -> bool #no_context {
    return PxCookHeightField(*desc, stream);
}

/*
\brief Cooks and creates a heightfield mesh and inserts it into PxPhysics.

\param[in] desc					The heightfield descriptor to read the HF from.
\param[in] insertionCallback	The insertion interface from PxPhysics.
\return PxHeightField pointer on success

\see PxCookHeightField() PxPhysics.createHeightField() PxInsertionCallback
*/
PxCreateHeightField :: (desc: *physx.PxHeightFieldDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxHeightField #foreign physxcooking_static;
PxCreateHeightField :: (desc: physx.PxHeightFieldDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxHeightField #no_context {
    return PxCreateHeightField(*desc, insertionCallback);
}

/*
\brief Cooks a convex mesh. The results are written to the stream.

To create a triangle mesh object it is necessary to first 'cook' the mesh data into
a form which allows the SDK to perform efficient collision detection.

PxCookConvexMesh() allows a mesh description to be cooked into a binary stream
suitable for loading and performing collision detection at runtime.

\note The number of vertices and the number of convex polygons in a cooked convex mesh is limited to 255.
\note If those limits are exceeded in either the user-provided data or the final cooked mesh, an error is reported.

\param[in] params		The cooking parameters
\param[in] desc			The convex mesh descriptor to read the mesh from.
\param[in] stream		User stream to output the cooked data.
\param[out] condition	Result from convex mesh cooking.
\return true on success.

\see PxCookTriangleMesh() PxConvexMeshCookingResult::Enum
*/
PxCookConvexMesh :: (params: *physx.PxCookingParams, desc: *physx.PxConvexMeshDesc, stream: *physx.PxOutputStream, condition: *physx.PxConvexMeshCookingResult.Enum = null) -> bool #foreign physxcooking_static;
PxCookConvexMesh :: (params: physx.PxCookingParams, desc: physx.PxConvexMeshDesc, stream: *physx.PxOutputStream, condition: *physx.PxConvexMeshCookingResult.Enum = null) -> bool #no_context {
    return PxCookConvexMesh(*params, *desc, stream, condition);
}

/*
\brief Cooks and creates a convex mesh without going through a stream.

\note This method does the same as PxCookConvexMesh, but the produced mesh is not stored
into a stream but is either directly inserted in PxPhysics, or created as a standalone
object. Use this method if you are unable to cook offline.

\note PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback()
or PxGetStandaloneInsertionCallback().

\param[in] params				The cooking parameters
\param[in] desc					The convex mesh descriptor to read the mesh from.
\param[in] insertionCallback	The insertion interface from PxPhysics.
\param[out] condition			Result from convex mesh cooking.
\return PxConvexMesh pointer on success

\see PxCookConvexMesh() PxInsertionCallback
*/
PxCreateConvexMesh :: (params: *physx.PxCookingParams, desc: *physx.PxConvexMeshDesc, insertionCallback: *physx.PxInsertionCallback, condition: *physx.PxConvexMeshCookingResult.Enum = null) -> *physx.PxConvexMesh #foreign physxcooking_static;
PxCreateConvexMesh :: (params: physx.PxCookingParams, desc: physx.PxConvexMeshDesc, insertionCallback: *physx.PxInsertionCallback, condition: *physx.PxConvexMeshCookingResult.Enum = null) -> *physx.PxConvexMesh #no_context {
    return PxCreateConvexMesh(*params, *desc, insertionCallback, condition);
}

/*
\brief Verifies if the convex mesh is valid. Prints an error message for each inconsistency found.

The convex mesh descriptor must contain an already created convex mesh - the vertices, indices and polygons must be provided.

\note This function should be used if PxConvexFlag::eDISABLE_MESH_VALIDATION is planned to be used in release builds.

\param[in] params	The cooking parameters
\param[in] desc		The convex mesh descriptor to read the mesh from.

\return true if all the validity conditions hold, false otherwise.

\see PxCookConvexMesh()
*/
PxValidateConvexMesh :: (params: *physx.PxCookingParams, desc: *physx.PxConvexMeshDesc) -> bool #foreign physxcooking_static;
PxValidateConvexMesh :: (params: physx.PxCookingParams, desc: physx.PxConvexMeshDesc) -> bool #no_context {
    return PxValidateConvexMesh(*params, *desc);
}

/*
\brief Compute hull polygons from given vertices and triangles. Polygons are needed for PxConvexMeshDesc rather than triangles.

Please note that the resulting polygons may have different number of vertices. Some vertices may be removed.
The output vertices, indices and polygons must be used to construct a hull.

The provided PxAllocatorCallback does allocate the out arrays. It is the user responsibility to deallocated those arrays.

\param[in] params			The cooking parameters
\param[in] mesh				Simple triangle mesh containing vertices and triangles used to compute polygons.
\param[in] inCallback		Memory allocator for out array allocations.
\param[out] nbVerts			Number of vertices used by polygons.
\param[out] vertices		Vertices array used by polygons.
\param[out] nbIndices		Number of indices used by polygons.
\param[out] indices			Indices array used by polygons.
\param[out] nbPolygons		Number of created polygons.
\param[out] hullPolygons	Polygons array.
\return true on success

\see PxCookConvexMesh() PxConvexFlags PxConvexMeshDesc PxSimpleTriangleMesh
*/
PxComputeHullPolygons :: (params: *physx.PxCookingParams, mesh: *physx.PxSimpleTriangleMesh, inCallback: *physx.PxAllocatorCallback, nbVerts: *physx.PxU32, vertices: **physx.PxVec3, nbIndices: *physx.PxU32, indices: **physx.PxU32, nbPolygons: *physx.PxU32, hullPolygons: **physx.PxHullPolygon) -> bool #foreign physxcooking_static;
PxComputeHullPolygons :: (params: physx.PxCookingParams, mesh: physx.PxSimpleTriangleMesh, inCallback: *physx.PxAllocatorCallback, nbVerts: *physx.PxU32, vertices: **physx.PxVec3, nbIndices: *physx.PxU32, indices: **physx.PxU32, nbPolygons: *physx.PxU32, hullPolygons: **physx.PxHullPolygon) -> bool #no_context {
    return PxComputeHullPolygons(*params, *mesh, inCallback, nbVerts, vertices, nbIndices, indices, nbPolygons, hullPolygons);
}

/*
\brief Verifies if the triangle mesh is valid. Prints an error message for each inconsistency found.

The following conditions are true for a valid triangle mesh:
1. There are no duplicate vertices (within specified vertexWeldTolerance. See PxCookingParams::meshWeldTolerance)
2. There are no large triangles (within specified PxTolerancesScale.)

\param[in] params	The cooking parameters
\param[in] desc		The triangle mesh descriptor to read the mesh from.

\return true if all the validity conditions hold, false otherwise.

\see PxCookTriangleMesh()
*/
PxValidateTriangleMesh :: (params: *physx.PxCookingParams, desc: *physx.PxTriangleMeshDesc) -> bool #foreign physxcooking_static;
PxValidateTriangleMesh :: (params: physx.PxCookingParams, desc: physx.PxTriangleMeshDesc) -> bool #no_context {
    return PxValidateTriangleMesh(*params, *desc);
}

/*
\brief Cooks a triangle mesh. The results are written to the stream.

To create a triangle mesh object it is necessary to first 'cook' the mesh data into
a form which allows the SDK to perform efficient collision detection.

PxCookTriangleMesh() allows a mesh description to be cooked into a binary stream
suitable for loading and performing collision detection at runtime.

\param[in] params		The cooking parameters
\param[in]	desc		The triangle mesh descriptor to read the mesh from.
\param[in]	stream		User stream to output the cooked data.
\param[out]	condition	Result from triangle mesh cooking.
\return true on success

\see PxCookConvexMesh() PxPhysics.createTriangleMesh() PxTriangleMeshCookingResult::Enum
*/
PxCookTriangleMesh :: (params: *physx.PxCookingParams, desc: *physx.PxTriangleMeshDesc, stream: *physx.PxOutputStream, condition: *physx.PxTriangleMeshCookingResult.Enum = null) -> bool #foreign physxcooking_static;
PxCookTriangleMesh :: (params: physx.PxCookingParams, desc: physx.PxTriangleMeshDesc, stream: *physx.PxOutputStream, condition: *physx.PxTriangleMeshCookingResult.Enum = null) -> bool #no_context {
    return PxCookTriangleMesh(*params, *desc, stream, condition);
}

/*
\brief Cooks and creates a triangle mesh without going through a stream.

\note This method does the same as PxCookTriangleMesh, but the produced mesh is not stored
into a stream but is either directly inserted in PxPhysics, or created as a standalone
object. Use this method if you are unable to cook offline.

\note PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback()
or PxGetStandaloneInsertionCallback().

\param[in] params				The cooking parameters
\param[in] desc					The triangle mesh descriptor to read the mesh from.
\param[in] insertionCallback	The insertion interface from PxPhysics.
\param[out] condition			Result from triangle mesh cooking.
\return PxTriangleMesh pointer on success.

\see PxCookTriangleMesh() PxPhysics.createTriangleMesh() PxInsertionCallback
*/
PxCreateTriangleMesh :: (params: *physx.PxCookingParams, desc: *physx.PxTriangleMeshDesc, insertionCallback: *physx.PxInsertionCallback, condition: *physx.PxTriangleMeshCookingResult.Enum = null) -> *physx.PxTriangleMesh #foreign physxcooking_static;
PxCreateTriangleMesh :: (params: physx.PxCookingParams, desc: physx.PxTriangleMeshDesc, insertionCallback: *physx.PxInsertionCallback, condition: *physx.PxTriangleMeshCookingResult.Enum = null) -> *physx.PxTriangleMesh #no_context {
    return PxCreateTriangleMesh(*params, *desc, insertionCallback, condition);
}

/*
\brief Cooks a tetrahedron mesh. The results are written to the stream.

To create a tetrahedron mesh object it is necessary to first 'cook' the mesh data into
a form which allows the SDK to perform efficient collision detection.

PxCookTetrahedronMesh() allows a mesh description to be cooked into a binary stream
suitable for loading and performing collision detection at runtime.

\param[in] params		The cooking parameters
\param[in] meshDesc		The tetrahedron mesh descriptor to read the mesh from.
\param[in] stream		User stream to output the cooked data.
\return true on success

\see PxCookConvexMesh() PxPhysics.createTetrahedronMesh()
*/
PxCookTetrahedronMesh :: (params: *physx.PxCookingParams, meshDesc: *physx.PxTetrahedronMeshDesc, stream: *physx.PxOutputStream) -> bool #foreign physxcooking_static;
PxCookTetrahedronMesh :: (params: physx.PxCookingParams, meshDesc: physx.PxTetrahedronMeshDesc, stream: *physx.PxOutputStream) -> bool #no_context {
    return PxCookTetrahedronMesh(*params, *meshDesc, stream);
}

/*
\brief Cooks and creates a tetrahedron mesh without going through a stream.

\note This method does the same as PxCookTetrahedronMesh, but the produced mesh is not stored
into a stream but is either directly inserted in PxPhysics, or created as a standalone
object. Use this method if you are unable to cook offline.

\note PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback()
or PxGetStandaloneInsertionCallback().

\param[in] params				The cooking parameters
\param[in] meshDesc				The tetrahedron mesh descriptor to read the mesh from.
\param[in] insertionCallback	The insertion interface from PxPhysics.
\return PxTetrahedronMesh pointer on success.

\see PxCookTetrahedronMesh() PxInsertionCallback
*/
PxCreateTetrahedronMesh :: (params: *physx.PxCookingParams, meshDesc: *physx.PxTetrahedronMeshDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxTetrahedronMesh #foreign physxcooking_static;
PxCreateTetrahedronMesh :: (params: physx.PxCookingParams, meshDesc: physx.PxTetrahedronMeshDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxTetrahedronMesh #no_context {
    return PxCreateTetrahedronMesh(*params, *meshDesc, insertionCallback);
}

/*
\brief Cooks a softbody mesh. The results are written to the stream.

To create a softbody mesh object it is necessary to first 'cook' the mesh data into
a form which allows the SDK to perform efficient collision detection and to store data
used during the FEM calculations.

PxCookSoftBodyMesh() allows a mesh description to be cooked into a binary stream
suitable for loading and performing collision detection at runtime.

\param[in] params				The cooking parameters
\param[in] simulationMeshDesc	The tetrahedron mesh descriptor to read the simulation mesh from.
\param[in] collisionMeshDesc	The tetrahedron mesh descriptor to read the collision mesh from.
\param[in] softbodyDataDesc		The softbody data descriptor to read mapping information from.
\param[in] stream				User stream to output the cooked data.
\return true on success

\see PxCookConvexMesh() PxPhysics.createTriangleMesh() PxTriangleMeshCookingResult::Enum
*/
PxCookSoftBodyMesh :: (params: *physx.PxCookingParams, simulationMeshDesc: *physx.PxTetrahedronMeshDesc, collisionMeshDesc: *physx.PxTetrahedronMeshDesc, softbodyDataDesc: *physx.PxSoftBodySimulationDataDesc, stream: *physx.PxOutputStream) -> bool #foreign physxcooking_static;
PxCookSoftBodyMesh :: (params: physx.PxCookingParams, simulationMeshDesc: physx.PxTetrahedronMeshDesc, collisionMeshDesc: physx.PxTetrahedronMeshDesc, softbodyDataDesc: physx.PxSoftBodySimulationDataDesc, stream: *physx.PxOutputStream) -> bool #no_context {
    return PxCookSoftBodyMesh(*params, *simulationMeshDesc, *collisionMeshDesc, *softbodyDataDesc, stream);
}

/*
\brief Cooks and creates a softbody mesh without going through a stream.

\note This method does the same as PxCookSoftBodyMesh, but the produced mesh is not stored
into a stream but is either directly inserted in PxPhysics, or created as a standalone
object. Use this method if you are unable to cook offline.

\note PxInsertionCallback can be obtained through PxPhysics::getPhysicsInsertionCallback()
or PxGetStandaloneInsertionCallback().

\param[in] params				The cooking parameters
\param[in] simulationMeshDesc	The tetrahedron mesh descriptor to read the simulation mesh from.
\param[in] collisionMeshDesc	The tetrahedron mesh descriptor to read the collision mesh from.
\param[in] softbodyDataDesc		The softbody data descriptor to read mapping information from.
\param[in] insertionCallback	The insertion interface from PxPhysics.
\return PxSoftBodyMesh pointer on success.

\see PxCookTriangleMesh() PxPhysics.createTriangleMesh() PxInsertionCallback
*/
PxCreateSoftBodyMesh :: (params: *physx.PxCookingParams, simulationMeshDesc: *physx.PxTetrahedronMeshDesc, collisionMeshDesc: *physx.PxTetrahedronMeshDesc, softbodyDataDesc: *physx.PxSoftBodySimulationDataDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxSoftBodyMesh #foreign physxcooking_static;
PxCreateSoftBodyMesh :: (params: physx.PxCookingParams, simulationMeshDesc: physx.PxTetrahedronMeshDesc, collisionMeshDesc: physx.PxTetrahedronMeshDesc, softbodyDataDesc: physx.PxSoftBodySimulationDataDesc, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxSoftBodyMesh #no_context {
    return PxCreateSoftBodyMesh(*params, *simulationMeshDesc, *collisionMeshDesc, *softbodyDataDesc, insertionCallback);
}

/*
\brief Computes the mapping between collision and simulation mesh

The softbody deformation is computed on the simulation mesh. To deform the collision mesh accordingly
it needs to be specified how its vertices need to be placed and updated inside the deformation mesh.
This method computes that embedding information.

\param[in] params			The cooking parameters
\param[in] simulationMesh	A tetrahedral mesh that defines the shape of the simulation mesh which is used to compute the body's deformation
\param[in] collisionMesh	A tetrahedral mesh that defines the shape of the collision mesh which is used for collision detection
\param[in] collisionData	A data container that contains acceleration structures and surface information of the collision mesh
\param[in] vertexToTet		Optional indices (array of integers) that specifies the index of the tetrahedron in the simulation mesh that
contains a collision mesh vertex. If not provided, the embedding will be computed internally. If the simulation mesh is obtained from
PxTetMaker::createVoxelTetrahedronMesh, then the vertexToTet map createVoxelTetrahedronMesh returned should be used here.
\return PxCollisionMeshMappingData pointer that describes how the collision mesh is embedded into the simulation mesh

\see PxTetMaker::createVoxelTetrahedronMesh
*/
PxComputeModelsMapping :: (params: *physx.PxCookingParams, simulationMesh: *physx.PxTetrahedronMeshData, collisionMesh: *physx.PxTetrahedronMeshData, collisionData: *physx.PxSoftBodyCollisionData, vertexToTet: *physx.PxBoundedData = null) -> *physx.PxCollisionMeshMappingData #foreign physxcooking_static;
PxComputeModelsMapping :: (params: physx.PxCookingParams, simulationMesh: *physx.PxTetrahedronMeshData, collisionMesh: physx.PxTetrahedronMeshData, collisionData: physx.PxSoftBodyCollisionData, vertexToTet: *physx.PxBoundedData = null) -> *physx.PxCollisionMeshMappingData #no_context {
    return PxComputeModelsMapping(*params, simulationMesh, *collisionMesh, *collisionData, vertexToTet);
}

/*
\brief Computes data to accelerate collision detection of tetrahedral meshes

Computes data structures to speed up collision detection with tetrahedral meshes.

\param[in] params				The cooking parameters
\param[in] collisionMeshDesc	Raw tetrahedral mesh descriptor which will be used for collision detection
\return PxCollisionTetrahedronMeshData pointer that describes the collision mesh
*/
PxComputeCollisionData :: (params: *physx.PxCookingParams, collisionMeshDesc: *physx.PxTetrahedronMeshDesc) -> *physx.PxCollisionTetrahedronMeshData #foreign physxcooking_static;
PxComputeCollisionData :: (params: physx.PxCookingParams, collisionMeshDesc: physx.PxTetrahedronMeshDesc) -> *physx.PxCollisionTetrahedronMeshData #no_context {
    return PxComputeCollisionData(*params, *collisionMeshDesc);
}

/*
\brief Computes data to accelerate collision detection of tetrahedral meshes

Computes data to compute and store a softbody's deformation using FEM.

\param[in] params				The cooking parameters
\param[in] simulationMeshDesc	Raw tetrahedral mesh descriptor which will be used for FEM simulation
\return PxSimulationTetrahedronMeshData pointer that describes the simulation mesh
*/
PxComputeSimulationData :: (params: *physx.PxCookingParams, simulationMeshDesc: *physx.PxTetrahedronMeshDesc) -> *physx.PxSimulationTetrahedronMeshData #foreign physxcooking_static;
PxComputeSimulationData :: (params: physx.PxCookingParams, simulationMeshDesc: physx.PxTetrahedronMeshDesc) -> *physx.PxSimulationTetrahedronMeshData #no_context {
    return PxComputeSimulationData(*params, *simulationMeshDesc);
}

/*
\brief Bundles all data required for softbody simulation

Creates a container that provides everything to create a PxSoftBody

\param[in] simulationMesh		The geometry (tetrahedral mesh) to be used as simulation mesh
\param[in] simulationData		Additional non-tetmesh data that contains mass information etc. for the simulation mesh
\param[in] collisionMesh		The geometry (tetrahedral mesh) to be used for collision detection
\param[in] collisionData		Additional non-tetmesh data that contains surface information, acceleration structures etc. for the simulation mesh
\param[in] mappingData			Mapping that describes how the collision mesh's vertices are embedded into the simulation mesh
\param[in] insertionCallback	The insertion interface from PxPhysics.
\return PxSoftBodyMesh pointer that represents a softbody mesh bundling all data (simulation mesh, collision mesh etc.)

\see PxSoftBody createSoftBody()
*/
PxAssembleSoftBodyMesh :: (simulationMesh: *physx.PxTetrahedronMeshData, simulationData: *physx.PxSoftBodySimulationData, collisionMesh: *physx.PxTetrahedronMeshData, collisionData: *physx.PxSoftBodyCollisionData, mappingData: *physx.PxCollisionMeshMappingData, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxSoftBodyMesh #foreign physxcooking_static;

/*
\brief Bundles all data required for softbody simulation

Creates a container that provides everything to create a PxSoftBody

\param[in] simulationMesh		Container that provides all information about the simulation mesh (geometry, mass distribution etc.)
\param[in] collisionMesh		Container that provides all information about the collision mesh (geometry, surface information, acceleration structures etc.)
\param[in] mappingData			Mapping that describes how the collision mesh's vertices are embedded into the simulation mesh
\param[in] insertionCallback	The insertion interface from PxPhysics.
\return PxSoftBodyMesh pointer that represents a softbody mesh bundling all data (simulation mesh, collision mesh etc.)

\see PxSoftBody createSoftBody()
*/
PxAssembleSoftBodyMesh_Sim :: (simulationMesh: *physx.PxSimulationTetrahedronMeshData, collisionMesh: *physx.PxCollisionTetrahedronMeshData, mappingData: *physx.PxCollisionMeshMappingData, insertionCallback: *physx.PxInsertionCallback) -> *physx.PxSoftBodyMesh #foreign physxcooking_static;

PxFileHandle :: *FILE;

OmniPvdWriter :: struct {}

#scope_file

#import "Basic"; // For push_context

physxfoundation_static :: #library,no_dll "windows/PhysXFoundation_static";
physxcharacterkinematic_static :: #library,no_dll "windows/PhysXCharacterKinematic_static";
physxcommon_static :: #library,no_dll "windows/PhysXCommon_static";
physxcooking_static :: #library,no_dll "windows/PhysXCooking_static";
physx_static :: #library,no_dll "windows/PhysX_static";
